<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
          // alert('此文章并不公开, 输入文章密码方可阅读');
          var password = prompt('此文章并不公开, 输入文章密码方可阅读');
          if (password !== ''){
            if (password != null) // 如果用户点击了确认而且密码错误的时候, 因为当password == null的时候说明用户点了取消
            {
              alert('Error!');
            }
            if (history.length > 1)
            {
              history.back();
            }
            else
            {
              window.location.href = "about:blank";
            }
          }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/dist/jquery.fancybox.css?v=3.2.10" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">
<meta property="og:type" content="website">
<meta property="og:title" content="烫">
<meta property="og:url" content="https://hulinhong.com/page/22/index.html">
<meta property="og:site_name" content="烫">
<meta property="og:description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="烫">
<meta name="twitter:description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":222,"transition":{"header":"slideDownIn","menu":"slideDownIn","logo":"slideDownIn","post_block_else":"slideDownIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"slideDownIn","footer":"slideDownIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>烫 - 烫烫烫烫烫</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">烫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">烫烫烫烫烫</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <form class="site-search-form">
    <span class="search-icon fa fa-search"></span>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">×</i>
  </form>


<script type="text/javascript" id="local.search.active">
var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2016/11/16/virtual_connection_over_udp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/16/virtual_connection_over_udp/" itemprop="url">游戏网络开发三之基于UDP的虚拟连接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-16T22:20:34+00:00">
                2016-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/virtual_connection_over_udp/" target="_blank" rel="noopener">原文出处</a></p>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I&rsquo;m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <a href="https://gafferongames.com/categories/game-networking/" target="_blank" rel="noopener"><strong>Networking for Game Programmers</strong></a>.</p><br><p>In the <a href="https://gafferongames.com/post/sending_and_receiving_packets" target="_blank" rel="noopener">previous article</a> we sent and received packets over UDP. Since UDP is connectionless, one UDP socket can be used to exchange packets with any number of different computers. In multiplayer games however, we usually only want to exchange packets between a small set of connected computers.</p><br><p>As the first step towards a general connection system, we&rsquo;ll start with the simplest case possible: creating a virtual connection between two computers on top of UDP.</p><br><p>But first, we&rsquo;re going to dig in a bit deeper about how the Internet really works!</p><br><h2 id="the-internet-u-not-u-a-series-of-tubes">The Internet <u>NOT</u> a series of tubes</h2><br><p>In 2006, Senator Ted Stevens made internet history with his <a href="https://en.wikipedia.org/wiki/Series_of_tubes" target="_blank" rel="noopener">famous speech</a> on the net neutrality act:</p><br><blockquote>“The internet is not something that you just dump something on. It’s not a big truck. It’s a series of tubes”</blockquote><br><p>When I first started using the Internet, I was just like Ted. Sitting in the computer lab in University of Sydney in 1995, I was &ldquo;surfing the web&rdquo; with this new thing called Netscape Navigator, and I had absolutely no idea what was going on.</p><br><p>You see, I thought each time you connected to a website there was some actual connection going on, like a telephone line. I wondered, how much does it cost each time I connect to a new website? 30 cents? A dollar? Was somebody from the university going to tap me on the shoulder and ask me to pay the long distance charges? :)</p><br><p>Of course, this all seems silly now.</p><br><p>There is no switchboard somewhere that directly connects you via a physical phone line to the other computer you want to talk to, let alone a series of pneumatic tubes like Sen. Stevens would have you believe.</p><br><h2 id="no-direct-connections">No Direct Connections</h2><br><p>Instead your data is sent over Internet Protocol (IP) via packets that hop from computer to computer.</p><br><p>A packet may pass through several computers before it reaches its destination. You cannot know the exact set of computers in advance, as it changes dynamically depending on how the network decides to route packets. You could even send two packets A and B to the same address, and they may take different routes.</p><br><p>On unix-like systems can inspect the route that packets take by calling &ldquo;traceroute&rdquo; and passing in a destination hostname or IP address.</p><br><p>On windows, replace &ldquo;traceroute&rdquo; with &ldquo;tracert&rdquo; to get it to work.</p><br><p>Try it with a few websites like this:</p><br><pre>    traceroute slashdot.org<br>    traceroute amazon.com<br>    traceroute google.com<br>    traceroute bbc.co.uk<br>    traceroute news.com.au<br></pre><br><p>Take a look and you should be able to convince yourself pretty quickly that there is no direct connection.</p><br><h2 id="how-packets-get-delivered">How Packets Get Delivered</h2><br><p>In the <a href="https://gafferongames.com/post/udp_vs_tcp/" target="_blank" rel="noopener">first article</a>, I presented a simple analogy for packet delivery, describing it as somewhat like a note being passed from person to person across a crowded room.</p><br><p>While this analogy gets the basic idea across, it is much too simple. The Internet is <u>not</u> a flat network of computers, it is a network of networks. And of course, we don&rsquo;t just need to pass letters around a small room, we need to be able to send them anywhere in the world.</p><br><p>It should be pretty clear then that the best analogy is the postal service!</p><br><p>When you want to send a letter to somebody you put your letter in the mailbox and you trust that it will be delivered correctly. It&rsquo;s not really relevant to you <i>how</i> it gets there, as long as it does. Somebody has to physically deliver your letter to its destination of course, so how is this done?</p><br><p>Well first off, the postman sure as hell doesn&rsquo;t take your letter and deliver it personally! It seems that the postal service is not a series of tubes either. Instead, the postman takes your letter to the local post office for processing.</p><br><p>If the letter is addressed locally then the post office just sends it back out, and another postman delivers it directly. But, if the address is is non-local then it gets interesting! The local post office is not able to deliver the letter directly, so it passes it &ldquo;up&rdquo; to the next level of hierarchy, perhaps to a regional post office which services cities nearby, or maybe to a mail center at an airport, if the address is far away. Ideally, the actual transport of the letter would be done using a <u>big truck</u>.</p><br><p>Lets be complicated and assume the letter is sent from Los Angeles to Sydney, Australia. The local post office receives the letter and given that it is addressed internationally, sends it directly to a mail center at LAX. The letter is processed again according to address, and gets routed on the next flight to Sydney.</p><br><p>The plane lands at Sydney airport where an <i>entirely different postal system</i> takes over. Now the whole process starts operating in reverse. The letter travels &ldquo;down&rdquo; the hierarchy, from the general, to the specific. From the mail hub at Sydney Airport it gets sent out to a regional center, the regional center delivers it to the local post office, and eventually the letter is hand delivered by a mailman with a funny accent. Crikey! :)</p><br><p>Just like post offices determine how to deliver letters via their address, networks deliver packets according to their IP address. The low-level details of this delivery and the actual routing of packets from network to network is actually quite complex, but the basic idea is that each router is just another computer, with a routing table describing where packets matching sets of addresses should go, as well as a default gateway address describing where to pass packets for which there is no matching entry in the table. It is routing tables, and the physical connections they represent that define the network of networks that is the Internet.</p><br><p>The job of configuring these routing tables is up to network administrators, not programmers like us. But if you want to read more about it, then this article from <a href="https://arstechnica.com/guides/other/peering-and-transit.ars" target="_blank" rel="noopener">ars technica</a> provides some fascinating insight into how networks exchange packets between each other via peering and transit relationships. You can also read more details about <a href="http://www.faqs.org/docs/linux_network/x-087-2-issues.routing.html" target="_blank" rel="noopener">routing tables</a> in this linux faq, and about the <a href="https://en.wikipedia.org/wiki/Border_Gateway_Protocol" target="_blank" rel="noopener">border gateway protocol</a> on wikipedia, which automatically discovers how to route packets between networks, making the internet a truly distributed system capable of dynamically routing around broken connectivity.</p><br><h2 id="virtual-connections">Virtual Connections</h2><br><p>Now back to connections.</p><br><p>If you have used TCP sockets then you know that they sure <i>look</i> like a connection, but since TCP is implemented on top of IP, and IP is just packets hopping from computer to computer, it follows that TCP&rsquo;s concept of connection must be a <i>virtual connection.</i></p><br><p>If TCP can create a virtual connection over IP, it follows that we can do the same over UDP.</p><br><p>Lets define our virtual connection as two computers exchanging UDP packets at some fixed rate like 10 packets per-second. As long as the packets are flowing, we consider the two computers to be virtually connected.</p><br><p>Our connection has two sides:</p><br><ul><br><li>One computer sits there and <i>listens</i> for another computer to connect to it. We’ll call this computer the <u>server</u>.</li><br><li>Another computer <i>connects</i> to a server by specifying an IP address and port. We’ll call this computer the <u>client</u>.</li><br></ul><br><p>In our case, we only allow one client to connect to the server at any time. We&rsquo;ll generalize our connection system to support multiple simultaneous connections in a later article. Also, we assume that the IP address of the server is on a fixed IP address that the client may directly connect to.</p><br><h2 id="protocol-id">Protocol ID</h2><br><p>Since UDP is connectionless our UDP socket can receive packets sent from any computer.</p><br><p>We&rsquo;d like to narrow this down so that the server only receives packets sent from the client, and the client only receives packets sent from the server. We can&rsquo;t just filter out packets by address, because the server doesn&rsquo;t know the address of the client in advance. So instead, we prefix each UDP packet with small header containing a 32 bit protocol id as follows:</p><br><pre>    [uint protocol id]<br>    <i>(packet data…)</i><br></pre><br><p>The protocol id is just some unique number representing our game protocol. Any packet that arrives from our UDP socket first has its first four bytes inspected. If they don&rsquo;t match our protocol id, then the packet is ignored. If the protocol id does match, we strip out the first four bytes of the packet and deliver the rest as payload.</p><br><p>You just choose some number that is reasonably unique, perhaps a hash of the name of your game and the protocol version number. But really you can use anything. The whole point is that from the point of view of our connection based protocol, packets with different protocol ids are ignored.</p><br><h2 id="detecting-connection">Detecting Connection</h2><br><p>Now we need a way to detect connection.</p><br><p>Sure we could do some complex handshaking involving multiple UDP packets sent back and forth. Perhaps a client &ldquo;request connection&rdquo; packet is sent to the server, to which the server responds with a &ldquo;connection accepted&rdquo; sent back to the client, or maybe an &ldquo;i&rsquo;m busy&rdquo; packet if a client tries to connect to server which already has a connected client.</p><br><p>Or&hellip; we could just setup our server to take the first packet it receives with the correct protocol id, and consider a connection to be established.</p><br><p>The client just starts sending packets to the server assuming connection, when the server receives the first packet from the client, it takes note of the IP address and port of the client, and starts sending packets back.</p><br><p>The client already knows the address and port of the server, since it was specified on connect. So when the client receives packets, it filters out any that don&rsquo;t come from the server address. Similarly, once the server receives the first packet from the client, it gets the address and port of the client from &ldquo;recvfrom&rdquo;, so it is able to ignore any packets that don&rsquo;t come from the client address.</p><br><p>We can get away with this shortcut because we only have two computers involved in the connection. In later articles, we&rsquo;ll extend our connection system to support more than two computers in a client/server or peer-to-peer topology, and at this point we&rsquo;ll upgrade our connection negotiation to something more robust.</p><br><p>But for now, why make things more complicated than they need to be?</p><br><h2 id="detecting-disconnection">Detecting Disconnection</h2><br><p>How do we detect disconnection?</p><br><p>Well if a connection is defined as receiving packets, we can define disconnection as <i>not</i> receiving packets.</p><br><p>To detect when we are not receiving packets, we keep track of the number of seconds since we last received a packet from the other side of the connection. We do this on both sides.</p><br><p>Each time we receive a packet from the other side, we reset our accumulator to 0.0, each update we increase the accumulator by the amount of time that has passed.</p><br><p>If this accumulator exceeds some value like 10 seconds, the connection &ldquo;times out&rdquo; and we disconnect.</p><br><p>This also gracefully handles the case of a second client trying to connect to a server that has already made a connection with another client. Since the server is already connected it ignores packets coming from any address other than the connected client, so the second client receives no packets in response to the packets it sends, so the second client times out and disconnects.</p><br><h2 id="conclusion">Conclusion</h2><br><p>And that&rsquo;s all it takes to setup a virtual connection: some way to establish connection, filtering for packets not involved in the connection, and timeouts to detect disconnection.</p><br><p>Our connection is as real as any TCP connection, and the steady stream of UDP packets it provides is a suitable starting point for a multiplayer action game.</p><br><p>Now that you have your virtual connection over UDP, you can easily setup a client/server relationship for a two player multiplayer game without TCP.</p>

<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p><a href="http://gad.qq.com/program/translateview/7161829" target="_blank" rel="noopener">译文出处</a></p>
<div class="WordSection1"><p class="MsoNormal"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">译者：张华栋<span>(wcby) </span>审校：崔国军（飞扬<span>971</span>）</span> </span></p><p class="MsoNormal" align="left" style="line-height: 20.25pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑; color: rgb(51, 51, 51); font-size: 12pt;"> </span></p><p class="MsoTitle" align="left"><span style="font-family:微软雅黑;"><span style="border: 1pt none windowtext; padding: 0cm;"><span style="font-size:large;"><br><h2 id="序言">序言</h2><br></span></span> </span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">大家好，我是<span>Glenn Fiedler</span>，欢迎阅读《<a rel="noopener" href="http://gafferongames.com/networking-for-game-programmers/" target="_blank">针对游戏程序员的网络知识</a>》系列教程的第三篇文章。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在之前的文章中，我向你展示了如何使用<span>UDP</span>协议来发送和接收数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">由于<span>UDP</span>协议是无连接的传输层协议，一个<span>UDP</span>套接字可以用来与任意数目的不同电脑进行数据包交换。但是在多人在线网络游戏中，我们通常只需要在一小部分互相连接的计算机之间交换数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span><br></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">作为实现通用连接系统的第一步，我们将从最简单的可能情况开始：创建两台电脑之间构建于<span>UDP</span>协议之上的虚拟连接。</span><span style="color: rgb(34, 34, 34);"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">但是首先，我们将对互联网到底是如何工作的进行一点深度挖掘！</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoTitle" align="left"><span style="font-family:微软雅黑;"><span style="border: 1pt none windowtext; padding: 0cm;"><br><h2 id="互联网不是一连串的管子">互联网不是一连串的管子</h2><br></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在<span>2006</span>年，参议院特德<span>·</span>史蒂文斯<span>(Ted Stevens) </span>用他关于互联网中立（<span>netneutrality</span>）法案的著名演讲创造了互联网的历史：</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">”</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">互联网不是那种你随便丢点什么东西进去就能运行的东西。它不是一个大卡车。它是一连串的管子<span>“</span></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">当我第一次开始使用互联网的时候，我也像<span>Ted</span>一样无知。那是<span>1995</span>年，我坐在悉尼大学的计算机实验室里，在用一种叫做<span>Netscape</span>的网络浏览器（最早最热门的网页浏览工具）“在网上冲浪（<span>surfing the web</span>）“，那个时候我对发生了什么根本一无所知。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);"> </span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">你看那个时候，我觉得每次连到一个网站上就一定有某个真实存在的连接在帮我们传递信息，就像电话线一样。那时候我在想，当我每次连到一个新的网站上需要花费多少钱<span>? 30</span>美分吗<span>?</span>一美元吗<span>? </span>会有大学里的某个人过来拍拍我的肩膀让我付长途通信的费用么？</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">当然，现在回头看那时候一切的想法都非常的愚蠢。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">并没有在某个地方存在一个物理交换机用物理电话线将你和你希望通话的某个电脑直接连起来。更不用说像参议院史蒂文斯想让你相信的那样存在一串气压输送管。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span class="Char1"><br><h2 id="没有直接的连接">没有直接的连接</h2><br></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">相反你的数据是基于<span>IP</span>协议<span>(</span></span><span style="color: rgb(34, 34, 34);">InternetProtocol</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">)</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">通过在电脑到电脑之间发送数据包来传递信息的</span><b><span style="font-size: 13.5pt; color: rgb(43, 43, 43); background: rgb(248, 248, 248);">。</span></b> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">一个数据包可能在到达它的目的地之前要经过几个电脑。你没有办法提前知道数据包会经过具体哪些电脑，因为它会依赖当前网络的情况对数据包进行路由来动态的改变路径。甚至有可能给同一个地址发送<span>A</span>和<span>B</span>两个数据包，这两个数据包都采用不同的路由。这就是为什么<span>UDP</span>协议不能保证数据包的到达顺序。（其实这么说稍微容易有点引起误解，<span>TCP</span>协议是能保证数据包的到达顺序的，但是他也是基于<span>IP</span>协议进行数据包的发送，并且往同一个地址发送的两个数据包也有可能采用完全不同的路由，这主要是因为<span>TCP</span>在自己这一层做了一些控制而<span>UDP</span>没有，所以导致<span>TCP</span>协议可以保证数据包的有序性，而<span>UDP</span>协议不能，当然这种保证需要付出性能方面的代价）。</span><span style="color: rgb(34, 34, 34);"><br></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">在类<span>unix</span>的系统中可以通过调用<span>“traceroute”</span>函数并传递一个目的地主机名或<span>IP</span>地址来检查数据包的路由。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在<span>Windows</span>系统中，可以用<span>“tracert”</span>代替<span>“traceroute”</span>，其他不变，就能检查数据包的路由了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">像下面这样用一些网址来尝试下这种方法：</span> </span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">   traceroute slashdot.org</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">   traceroute amazon.com</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">   traceroute google.com</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">   traceroute bbc.co.uk</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">   traceroute news.com.au</span> </span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">运行下看下输出结果，你应该很快就能说服你自己确实连接到了网站上，但是并没有一个直接的连接。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoTitle" align="left"><span style="font-family:微软雅黑;"><span style="border: 1pt none windowtext; padding: 0cm;"><br><h2 id="数据包是如何传递到目的地的？">数据包是如何传递到目的地的？</h2><br></span><span style="color: rgb(34, 34, 34);"><br></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">在<a rel="noopener" href="http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/" target="_blank">第一篇文章</a>中，我对数据包传递到目的地这个事情做了一个简单的类比，把这个过程描述的有点像在一个拥挤的房间内一个人接着一个人的把便条传递下去。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">虽然这个类比的基本思想还是表达出来了，但是它有点过于简单了。互联网并不是电脑组成的一个平面的网络，实际上它是网络的网络。当然，我们不只是要在一个小房间里面传递信件，我们要做的事能够把信息传递到全世界。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);"><br></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">这就应该很清楚了，数据包传递到目的地的最好的类比是邮政服务<span>!</span></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">当你想给某人写信的时候，你会把你的信件放到邮箱里并且你相信它将正确的传递到目的地。这封信件具体是怎么到达目的地的和你并不是十分相关，尽管它是否正确到达会对你有影响。当然会有某个人在物理上帮你把信件传递到目的地，所以这是怎么做的呢<span>?</span></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">首先，邮递员肯定不需要自己去把你的信件送到目的地！看起来邮政服务也不是一串管子。相反，邮递员是把你的信件带到当地的邮政部门进行处理。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果这封信件是发送给本地的，那么邮政部门就会把这封信件发送回来，另外一个邮递员会直接投递这封信件。但是，如果这封信件不是发送给本地的，那么这个处理过程就有意思了！当地的邮政部门不能直接投递这封信件，所以这封信件会被向上传递到层次结构的上一层，这个上一层也许是地区级的邮政部门它会负责服务附近的几个城市，如果要投递的地址非常远的话，这个上一层也许是位于机场的一个邮件中心。理想情况下，信件的实际运输将通过一个大卡车来完成。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">让我们通过一个例子来把上面说的过程具体的走一遍，假设有一封信件要从洛杉矶发送到澳大利亚的悉尼。当地的邮政部门收到信件以后考虑到这封信件是一封跨国投递的信件，所以会直接把它发送到位于洛杉矶机场的邮件中心。在那里，这封信件会再次根据它的地址进行处理，并被安排通过下一个到悉尼的航班投递到悉尼去。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">当飞机降落到悉尼机场以后，一个完全不同的邮政系统会负责接管这封信件。现在整个过程开始逆向操作。这封信件会沿着层次结构向下传递，从大的管理部门到具体的投递区域。这封信件会从悉尼机场的邮件中心被送往一个地区级的中心，然后地区级的中心会把这封信件投递到当地的邮政部门，最终这封信件会是由一个操着有趣的本地口音的邮政人员用手投递到真正的目的地的。哎呀<span>! !</span></span><span style="color: rgb(34, 34, 34);"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);"> </span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">就像邮局是通过信件的地址来决定这些信件是该如何投递的一样，网络也是根据这些数据包的<span>IP</span>地址来决定它们是该如何传递的。投递机制的底层细节以及数据包从网络到网络的实际路由其实都是相当复杂的，但是基本的想法都是一样的，就是每个路由器都只是另外一台计算机，它会携带一张路由表用来描述如果数据包的<span>IP</span>地址匹配了这张表上的某个地址集，那么这个数据包该如何传递，这张表还会记载着默认的网关地址，如果数据包的<span>IP</span>地址和这张路由表上的一个地址都匹配不上，那么这个数据包该传递到默认的网关地址那里。其实是路由表以及它们代表的物理连接定义了网络的网络，也就是互联网（互联网也被称为万维网）。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span><a rel="nofollow" href="http://baike.baidu.com/view/1706.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>因特网</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">于<span>1969</span>年诞生于</span><span><a rel="nofollow" href="http://baike.baidu.com/view/2398.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>美国</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">。最初名为<span>“</span></span><span><a rel="nofollow" href="http://baike.baidu.com/view/108095.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>阿帕网</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">”</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">（<span>ARPAnet</span>）是一个军用研究系统，后来又成为连接大学及高等院校计算机的学术系统，则已</span><span><a rel="nofollow" href="http://baike.baidu.com/view/141536.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>发展</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">成为一个覆盖五大洲<span>150</span>多个国家的开放型全球</span><span><a rel="nofollow" href="http://baike.baidu.com/view/541460.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>计算机网络系统</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">，拥有许多服务商。普通电脑用户只需要一台个人计算机用电话线通过</span><span><a rel="nofollow" href="http://baike.baidu.com/view/1074.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>调制解调器</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">和</span><span><a rel="nofollow" href="http://baike.baidu.com/view/1706.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>因特网</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">服务商连接，便可进入因特网。但</span><span><a rel="nofollow" href="http://baike.baidu.com/view/1706.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>因特网</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">并不是全球唯一的</span><span><a rel="nofollow" href="http://baike.baidu.com/view/380232.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>互联网络</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">。例如在</span><span><a rel="nofollow" href="http://baike.baidu.com/view/3622.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>欧洲</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">，跨国的</span><span><a rel="nofollow" href="http://baike.baidu.com/view/380232.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>互联网络</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">就有<span>“</span>欧盟网<span>”</span>（<span>Euronet</span>），<span>“</span>欧洲学术与研究网<span>”</span>（<span>EARN</span>），<span>“</span>欧洲信息网<span>”</span>（<span>EIN</span>），在美国还有<span>“</span>国际学术网<span>”</span>（</span><span><a rel="nofollow" href="http://baike.baidu.com/view/370280.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;">BITNET</span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">），世界范围的还有<span>“</span>飞多网<span>”</span>（全球性的</span><span><a rel="nofollow" href="http://baike.baidu.com/view/66.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;">BBS</span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">系统）等。但这些网络其实根本就不需要知道，感谢<span>IP</span>协议的帮助，只要知道他们是可以互联互通的就可以。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这些路由表的配置工作是由网络管理员完成的，而不是由像我们这样的程序员来做。但是如果你想要了解这方面的更多内容，</span><span style="color: rgb(34, 34, 34);"> </span><span style="color: rgb(34, 34, 34);">那么来自</span><span><a rel="noopener" href="http://arstechnica.com/guides/other/peering-and-transit.ars" target="_blank"><span style="color: rgb(221, 51, 51);">ars technica</span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">的这篇文章将提供网络是如何在端与端之间互联来交换数据包以及传输关系方面一些非常有趣的见解。你还可以通过<span>linux</span>常见问题中路由表（</span><span><a rel="noopener" href="http://www.faqs.org/docs/linux_network/x-087-2-issues.routing.html" target="_blank"><span style="color: rgb(221, 51, 51);">routing tables</span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">）方面的文章以及维基百科上面的边界网关协议（</span><span><a rel="noopener" href="http://en.wikipedia.org/wiki/Border_Gateway_Protocol" target="_blank"><span style="color: rgb(221, 51, 51);">border gateway protocol</span></a></span><span style="color: rgb(34, 34, 34);"> </span><span style="font-size: 12pt; color: rgb(34, 34, 34);">）的解释来获得更多的细节。边界网关协议是用来自动发现如何在网络之间路由数据包的协议，有了它才真正的让互联网成为一个分布式系统，能够在不稳定的连接里面进行动态的路由。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">边界网关协议（<span>BGP</span>）是运行于<span> TCP </span>上的一种</span><span><a rel="nofollow" href="http://baike.baidu.com/view/2663.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>自治系统</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">的</span><span><a rel="nofollow" href="http://baike.baidu.com/view/7031.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>路由协议</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">。<span> BGP </span>是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关</span><span><a rel="nofollow" href="http://baike.baidu.com/view/4303246.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>路由域</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">间的多路连接的协议。<span> BGP </span>构建在<span> EGP </span>的经验之上。<span> BGP </span>系统的主要功能是和其他的<span> BGP </span>系统交换网络可达信息。网络可达信息包括列出的</span><span><a rel="nofollow" href="http://baike.baidu.com/view/2663.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>自治系统</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">（<span>AS</span>）的信息。这些信息有效地构造了<span> AS </span>互联的拓朴图并由此清除了</span><span><a rel="nofollow" href="http://baike.baidu.com/view/2098835.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>路由环路</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">，同时在<span> AS </span>级别上可实施策略决策。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><br><h2 id="虚拟的连接">虚拟的连接</h2><br></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在让我们回到连接本身。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果你已经使用过<span>TCP</span>套接字，那么你会知道它们看起来真的像是一个连接，但是由于<span>TCP</span>协议是在<span>IP</span>协议之上实现的，而<span>IP</span>协议是通过在计算机之间进行跳转来传递数据包的，所以<span>TCP</span>的连接仍然是一个虚拟连接。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果<span>TCP</span>协议可以基于<span>IP</span>协议建立虚拟连接，那么我们在<span>UDP</span>协议上所做的一切都可以应用于<span>TCP</span>协议上。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">让我们给虚拟连接下个定义：两个计算机之间以某个固定频率比如说每秒<span>10</span>个数据包来交换<span>UDP</span>的数据包。只要数据包仍然在传输，我们就认为这两台计算机之间存在一个虚拟连接。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们的连接有两侧：</span> </span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-family:微软雅黑;"><span style="font-size: 12pt;">一个计算机坐在那儿侦听是否有另一台计算机连接到它。我们称负责监听的这台计算机为服务器（<span>server</span>）。</span> </span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-family:微软雅黑;"><span style="font-size: 12pt;">另一台计算机会通过一个指定的<span>IP</span>地址和端口连接到一个服务器。我们称主动连接的这台电脑为客户端（<span>client</span>）。</span> </span></li></ul><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在我们的场景里，我们只允许一个客户端在任意的时候连接到服务器。我们将在下一篇文章里面拓展我们的连接系统以支持多个客户端的同时连接。此外，我们假定服务器的<span>IP</span>地址是一个固定的<span>IP</span>地址，客户端可以随时直接连接上来。我们将在后面的文章里面介绍匹配（<span>matchmaking</span>）和<span>NAT</span>打穿（<span>NATpunch-through</span>）。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoTitle" align="left"><span style="font-family:微软雅黑;"><br><h2 id="协议ID">协议ID</h2><br></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">由于<span>UDP</span>协议是无连接的传输层协议，所以我们的<span>UDP</span>套接字可以接受来自任何电脑的数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们想要缩小接收数据包的范围，以便我们的服务器只接收那些从我们的客户端发送出来的数据包，并且我们的客户端只接收那些从我们的服务端发送出来的数据包。我们不能只通过地址来过滤我们的数据包，因为服务器没有办法提前知道客户端的地址。所以，我们会在每一个<span>UDP</span>数据包前面加上一个包含<span>32</span>位协议<span>id</span>的头<span>,</span>如下所示<span>:</span></span> </span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">   [uint protocol id]</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">    <i><span style="border:none windowtext 1.0pt;padding:0cm">(packet data…)</span></i></span> </span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">协议<span>ID</span>只是一些独特的代表我们的游戏协议的数字。我们的<span>UDP</span>套接字收到的任意数据包首先都要检查数据包的首四位。如果它们和我们的协议<span>ID</span>不匹配的话，这个数据包就会被忽略。如果它们和我们的协议<span>ID</span>匹配的话，我们会剔除数据包的第一个四个字节并把剩下的部分发给我们的系统进行处理。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">你只要选择一些非常独特的数字就可以了，这些数字可以是你的游戏名字和协议版本号的散列值。不过说真的，你可以使用任何东西。这种做法的重点是把我们的连接视为基于协议进行通信的连接，如果协议<span>ID</span>不同，那么这样的数据包将被丢弃掉。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><br><h2 id="检测连接">检测连接</h2><br></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在我们需要一个方法来检测连接。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">当然我们可以实现一些复杂的握手协议，牵扯到多个<span>UDP</span>数据包来回传递。比如说客户端发送一个<span>”</span>请求连接（<span>request connection</span>）<span>“</span>的数据包给服务器，当服务器收到这个数据包的时候会回应一个<span>”</span>连接接受（<span>connection accepted</span>）<span>“</span>的数据包给客户端，或者如果这个服务器已经有超过一个连接的客户端以后，会回复一个“我很忙（<span>i’m busy</span>）<span>”</span>的数据包给客户端。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);"> </span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">或者。。我们可以设置我们的服务器，让它以它收到的第一个数据包的协议<span>ID</span>作为正确的协议<span>ID</span>，并在收到第一个数据包的时候就认为连接已经建立起来了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">客户端只是开始给服务器发送数据包，当服务器收到客户端发过来的第一个数据包的时候，它会记录下客户端的<span>IP</span>地址和端口号，然后开始给客户端回包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">客户端已经知道了服务器的地址和端口，因为这些信息是在连接的时候指定的。所以当客户端收到数据包的时候，它会过滤掉任何不是来自于服务器地址的数据包。同样的，一旦服务器收到客户端的第一个数据包，它就会从<span>“recvfrom”</span>函数里面得到客户端的地址和端口号，所以它也可以忽略任何不是发自客户端地址的数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们可以通过一个捷径来避开这个问题，因为我们的系统只有两台计算机会建立连接。在后面的文章里，我们将拓展我们的连接系统来支持超过两台计算机参与客户端<span>/</span>服务器或者端对端（<span>peer-to-peer</span>，<span>p2p</span>）网络模型，并且在那个时候我们会升级我们的连接协议方式来让它变得更加健壮。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">但是现在，为什么我们要让事情变得超出需求的复杂度呢？（作者的意思是因为我们现在不需要解决这个问题，因为我们的场景是面对只有两台计算机的情况，所以我们可以先放过这个问题。）</span> </span></p><p class="MsoTitle" align="left"><span style="font-family:微软雅黑;"><span style="border: 1pt none windowtext; padding: 0cm;"><br></span></span></p><p class="MsoTitle" align="left"><span style="font-family:微软雅黑;"><span style="border: 1pt none windowtext; padding: 0cm;"><br></span></span></p><p class="MsoTitle" align="left"><span style="font-family:微软雅黑;"><span style="border: 1pt none windowtext; padding: 0cm;"><br><h2 id="检测断线的情况">检测断线的情况</h2><br></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们该如何检测断线（<span>disconnection</span>）的情况？</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">那么，如果一个连接被定义为接收数据包，我们可以定义断线为收不到数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">为了检测什么时候开始我们收不到数据包，我们要记录上一次我们从连接的另外一侧收到数据包到现在过去了多少秒，我们在连接的两侧都做了这个事情。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">每次我们从连接的另外一端收到数据包的时候，我们都会重置我们的计数器为<span>0.0</span>，每一次更新的时候我们都会把这次更新到上一次更新逝去的时间量加到计数器上。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果计数器的值超过某一个值，比如说<span>10</span>秒，那么我们就认定这个连接“超时<span>”</span>了并且我们会断开连接。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这也可以很优雅的处理当服务器已经与一个客户端建立连接以后，有第二个客户端试图与服务器建立连接的情况。因为服务器已经建立了连接，它会忽略掉不是来自连接的客户端地址发出来的数据包，所以第二个客户端在发出了数据包以后得不到任何回应，这样它就会判断连接超时并断开连接。</span> </span></p><br><h2 id="总结">总结</h2><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">而这一切都需要设置一个虚拟连接：用某种方法建立一个连接，过滤掉那些不是来自这个连接的数据包，并且如果发现连接超时就断开连接。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们的连接就跟任何<span>TCP</span>连接一样真实，并且<span>UDP</span>数据包构成的稳定数据流为多人在线动作网络游戏提供了一个很好的起点。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们还获得了一些互联网是如何路由数据包的见解。举个例子来说，我们现在知道<span>UDP</span>数据包有时候会在到达的时候是乱序的原因是因为它们在<span>IP</span>层传输的时候采用不同的路由！看下互联网的地图，你会不会对你的数据包能够到达正确的目的点感到非常的神奇？如果你想对这个问题进行更加深入的了解，维基百科上的这篇文章<span>(<a rel="noopener" href="https://en.wikipedia.org/wiki/Internet_backbone" target="_blank">Internet backbone</a>)</span>是一个很好的起点。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在，既然你已经有了一个基于<span>UDP</span>协议的虚拟连接，你可以轻松的在两个玩家的多人在线游戏里面设置一个客户端<span>/</span>服务器关系而不需要使用<span>TCP</span>协议。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">你可以在这篇文章的示例源代码（</span><span><a rel="noopener" href="http://netgame.googlecode.com/files/VirtualConnectionOverUDP.zip" target="_blank"><span style="color: rgb(221, 51, 51);">examplesource code</span></a></span><span class="apple-converted-space"><span style="color: rgb(34, 34, 34);"> </span></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">）找到一个具体实现。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这是一个简单的客户端<span>/</span>服务器程序，每秒交换<span>30</span>个数据包。你可以在任意你喜欢的机器上运行这个服务器，只要给它提供一个公共的<span>IP</span>地址就可以了，需要公共<span>IP</span>地址的原因是我们目前还不支持<span>NAT</span>打穿</span><span style="color: rgb(34, 34, 34);">（</span><span><a rel="noopener" href="http://www.jenkinssoftware.com/raknet/manual/natpunchthrough.html" target="_blank"><span style="color: rgb(221, 51, 51);">NAT punch-through</span></a></span><span style="color: rgb(34, 34, 34);"> </span><span style="color: rgb(34, 34, 34);">）。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">NAT</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">穿越（<span>NATtraversal</span>）涉及<span>TCP/IP</span>网络中的一个常见问题，即在处于使用了<span>NAT</span>设备的私有<span>TCP/IP</span>网络中的</span><span><a rel="nofollow" href="http://baike.baidu.com/view/23880.htm" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;"><span>主机</span></span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">之间建立连接的问题。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">像这样来运行客户端：</span> </span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">   ./Client 205.10.40.50</span> </span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">它会尝试连接到你在命令行输入的地址。如果你不输入地址的话，默认情况下它会连接到<span>127.0.0.1</span>。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">当一个客户端已经与服务器建立连接的时候，你可以尝试用另外一个客户端来连接这个服务器，你会注意到这次连接的尝试失败了。这么设计是故意的。因为到目前为止，一次只允许一个客户端连接上服务器。 </span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">你也可以在客户端和服务器连接的状态下尝试停止客户端或者服务器，你会注意到<span>10</span>秒以后连接的另外一侧会判断连接超时并断开连接。当客户端超时的时候它会退到<span>shell</span>窗口，但是服务器会退到监听状态为下一次的连接做好准备。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">预告下接下来的一篇文章的题目<span>:</span>《基于<span>UDP</span>的可靠、有序和拥塞避免的传输》，欢迎继续阅读。</span> </span></p><p class="MsoNormal"><span style="font-family:微软雅黑;"><b><u><span style="color: rgb(34, 34, 34); border: 1pt none windowtext; padding: 0cm;"><span style="text-decoration: none"> </span></span></u></b> </span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果你喜欢这篇文章的话，请考虑对我做一个小小的捐赠。捐款会鼓励我写更多的文章<span>!</span>（原文作者在原文的地址上提供了一个捐赠网址，有兴趣的读者可以在文章开始的地方找到原文地址进行捐赠）</span> </span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">【版权声明】</span> </span></p><p class="MsoNormal"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权。</span></span><span style="font-size:9.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333"> </span></p><p class="MsoNormal" align="left" style="text-indent: 24pt;"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p></div>                    <br>                



<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p>因 Gaffer On Games 的源码原下载地址失效, 所以特地补上.</p>
<p><a href="https://github.com/no5ix/ReliableUDP" target="_blank" rel="noopener">请点击</a></p>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2016/11/15/游戏网络开发二之数据的发送与接收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/15/游戏网络开发二之数据的发送与接收/" itemprop="url">游戏网络开发二之数据的发送与接收</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-15T22:20:34+00:00">
                2016-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/sending_and_receiving_packets/" target="_blank" rel="noopener">原文出处</a></p>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I&rsquo;m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <a href="https://gafferongames.com/categories/game-networking/" target="_blank" rel="noopener"><strong>Networking for Game Programmers</strong></a>.</p><br><p>In the <a href="https://gafferongames.com/post/udp_vs_tcp/" target="_blank" rel="noopener">previous article</a> we discussed options for sending data between computers and decided to use UDP instead of TCP for time critical data.</p><br><p>In this article I am going to show you how to send and receive UDP packets.</p><br><h2 id="bsd-sockets">BSD sockets</h2><br><p>For most modern platforms you have some sort of basic socket layer available based on BSD sockets.</p><br><p>BSD sockets are manipulated using simple functions like &ldquo;socket&rdquo;, &ldquo;bind&rdquo;, &ldquo;sendto&rdquo; and &ldquo;recvfrom&rdquo;. You can of course work directly with these functions if you wish, but it becomes difficult to keep your code platform independent because each platform is slightly different.</p><br><p>So although I will first show you BSD socket example code to demonstrate basic socket usage, we won&rsquo;t be using BSD sockets directly for long. Once we&rsquo;ve covered all basic socket functionality we&rsquo;ll abstract everything away into a set of classes, making it easy to you to write platform independent socket code.</p><br><h2 id="platform-specifics">Platform specifics</h2><br><p>First let&rsquo;s setup a define so we can detect what our current platform is and handle the slight differences in sockets from one platform to another:</p><br><pre><code>    // platform detection<br><br>    #define PLATFORM_WINDOWS  1<br>    #define PLATFORM_MAC      2<br>    #define PLATFORM_UNIX     3<br><br>    #if defined(_WIN32)<br>    #define PLATFORM PLATFORM_WINDOWS<br>    #elif defined(<strong>APPLE</strong>)<br>    #define PLATFORM PLATFORM_MAC<br>    #else<br>    #define PLATFORM PLATFORM_UNIX<br>    #endif<br></code></pre><br><p>Now let&rsquo;s include the appropriate headers for sockets. Since the header files are platform specific, we&rsquo;ll use the platform #define to include different sets of files depending on the platform:</p><br><pre><code>    #if PLATFORM == PLATFORM_WINDOWS<br><br>        #include &lt;winsock2.h&gt;<br><br>    #elif PLATFORM == PLATFORM_MAC ||<br>          PLATFORM == PLATFORM_UNIX<br><br>        #include &lt;sys/socket.h&gt;<br>        #include &lt;netinet/in.h&gt;<br>        #include &lt;fcntl.h&gt;<br><br>    #endif<br></code></pre><br><p>Sockets are built in to the standard system libraries on unix-based platforms so we don&rsquo;t have to link to any additonal libraries. However, on Windows we need to link to the winsock library to get socket functionality.</p><br><p>Here is a simple trick to do this without having to change your project or makefile:</p><br><pre><code>    #if PLATFORM == PLATFORM_WINDOWS<br>    #pragma comment( lib, &quot;wsock32.lib&quot; )<br>    #endif<br></code></pre><br><p>I like this trick because I&rsquo;m super lazy. You can always link from your project or makefile if you wish.</p><br><h2 id="initializing-the-socket-layer">Initializing the socket layer</h2><br><p>Most unix-like platforms (including macosx) don&rsquo;t require any specific steps to initialize the sockets layer, however Windows requires that you jump through some hoops to get your socket code working.</p><br><p>You must call &ldquo;WSAStartup&rdquo; to initialize the sockets layer before you call any socket functions, and &ldquo;WSACleanup&rdquo; to shutdown when you are done.</p><br><p>Let&rsquo;s add two new functions:</p><br><pre><code>    bool InitializeSockets()<br>    {<br>        #if PLATFORM == PLATFORM_WINDOWS<br>        WSADATA WsaData;<br>        return WSAStartup( MAKEWORD(2,2),<br>                           &amp;WsaData )<br>            == NO_ERROR;<br>        #else<br>        return true;<br>        #endif<br>    }<br><br>    void ShutdownSockets()<br>    {<br>        #if PLATFORM == PLATFORM_WINDOWS<br>        WSACleanup();<br>        #endif<br>    }<br></code></pre><br><p>Now we have a platform independent way to initialize the socket layer.</p><br><h2 id="creating-a-socket">Creating a socket</h2><br><p>It&rsquo;s time to create a UDP socket, here&rsquo;s how to do it:</p><br><pre><code>    int handle = socket( AF_INET,<br>                         SOCK_DGRAM,<br>                         IPPROTO_UDP );<br><br>    if ( handle &lt;= 0 )<br>    {<br>        printf( &quot;failed to create socket\n&quot; );<br>        return false;<br>    }<br></code></pre><br><p>Next we bind the UDP socket to a port number (eg. 30000). Each socket must be bound to a unique port, because when a packet arrives the port number determines which socket to deliver to. Don&rsquo;t use ports lower than 1024 because they are reserved for the system. Also try to avoid using ports above 50000 because they used when dynamically assigning ports.</p><br><p>Special case: if you don&rsquo;t care what port your socket gets bound to just pass in &ldquo;0&rdquo; as your port, and the system will select a free port for you.</p><br><pre><code>    sockaddr_in address;<br>    address.sin_family = AF_INET;<br>    address.sin_addr.s_addr = INADDR_ANY;<br>    address.sin_port =<br>        htons( (unsigned short) port );<br><br>    if ( bind( handle,<br>               (const sockaddr<em>) &amp;address,<br>               sizeof(sockaddr_in) ) &lt; 0 )<br>    {<br>        printf( &quot;failed to bind socket\n&quot; );<br>        return false;<br>    }<br></em></code></pre><br><p>Now the socket is ready to send and receive packets.</p><br><p>But what is this mysterious call to &ldquo;htons&rdquo; in the code above? This is just a helper function that converts a 16 bit integer value from host byte order (little or big-endian) to network byte order (big-endian). This is required whenever you directly set integer members in socket structures.</p><br><p>You&rsquo;ll see &ldquo;htons&rdquo; (host to network short) and its 32 bit integer sized cousin &ldquo;htonl&rdquo; (host to network long) used several times throughout this article, so keep an eye out, and you&rsquo;ll know what is going on.</p><br><h2 id="setting-the-socket-as-non-blocking">Setting the socket as non-blocking</h2><br><p>By default sockets are set in what is called &ldquo;blocking mode&rdquo;.</p><br><p>This means that if you try to read a packet using &ldquo;recvfrom&rdquo;, the function will not return until a packet is available to read. This is not at all suitable for our purposes. Video games are realtime programs that simulate at 30 or 60 frames per second, they can&rsquo;t just sit there waiting for a packet to arrive!</p><br><p>The solution is to flip your sockets into &ldquo;non-blocking mode&rdquo; after you create them. Once this is done, the &ldquo;recvfrom&rdquo; function returns immediately when no packets are available to read, with a return value indicating that you should try to read packets again later.</p><br><p>Here&rsquo;s how put a socket in non-blocking mode:</p><br><pre><code>    #if PLATFORM == PLATFORM_MAC ||<br>        PLATFORM == PLATFORM_UNIX<br><br>        int nonBlocking = 1;<br>        if ( fcntl( handle,<br>                    F_SETFL,<br>                    O_NONBLOCK,<br>                    nonBlocking ) == -1 )<br>        {<br>            printf( &quot;failed to set non-blocking\n&quot; );<br>            return false;<br>        }<br><br>    #elif PLATFORM == PLATFORM_WINDOWS<br><br>        DWORD nonBlocking = 1;<br>        if ( ioctlsocket( handle,<br>                          FIONBIO,<br>                          &amp;nonBlocking ) != 0 )<br>        {<br>            printf( &quot;failed to set non-blocking\n&quot; );<br>            return false;<br>        }<br><br>    #endif<br></code></pre><br><p>Windows does not provide the &ldquo;fcntl&rdquo; function, so we use the &ldquo;ioctlsocket&rdquo; function instead.</p><br><h2 id="sending-packets">Sending packets</h2><br><p>UDP is a connectionless protocol, so each time you send a packet you must specify the destination address. This means you can use one UDP socket to send packets to any number of different IP addresses, there&rsquo;s no single computer at the other end of your UDP socket that you are connected to.</p><br><p>Here&rsquo;s how to send a packet to a specific address:</p><br><pre><code>    int sent_bytes =<br>        sendto( handle,<br>                (const char)packet_data,<br>                packet_size,<br>                0,<br>                (sockaddr<em>)&amp;address,<br>                sizeof(sockaddr_in) );<br><br>    if ( sent_bytes != packet_size )<br>    {<br>        printf( &quot;failed to send packet\n&quot; );<br>        return false;<br>    }<br></em></code></pre><br><p>Important! The return value from &ldquo;sendto&rdquo; only indicates if the packet was successfully sent from the local computer. It does <em>not</em> tell you whether or not the packet was received by the destination computer. UDP has no way of knowing whether or not the the packet arrived at its destination!</p><br><p>In the code above we pass a &ldquo;sockaddr_in&rdquo; structure as the destination address. How do we setup one of these structures?</p><br><p>Let&rsquo;s say we want to send to the address 207.45.186.98:30000</p><br><p>Starting with our address in this form:</p><br><pre><code>    unsigned int a = 207;<br>    unsigned int b = 45;<br>    unsigned int c = 186;<br>    unsigned int d = 98;<br>    unsigned short port = 30000;<br></code></pre><br><p>We have a bit of work to do to get it in the form required by &ldquo;sendto&rdquo;:</p><br><pre><code>    unsigned int address = ( a &lt;&lt; 24 ) |<br>                           ( b &lt;&lt; 16 ) |<br>                           ( c &lt;&lt; 8  ) |<br>                             d;<br><br>    sockaddr_in addr;<br>    addr.sin_family = AF_INET;<br>    addr.sin_addr.s_addr = htonl( address );<br>    addr.sin_port = htons( port );<br></code></pre><br><p>As you can see, we first combine the a,b,c,d values in range [0,255] into a single unsigned integer, with each byte of the integer now corresponding to the input values. We then initialize a &ldquo;sockaddr_in&rdquo; structure with the integer address and port, making sure to convert our integer address and port values from host byte order to network byte order using &ldquo;htonl&rdquo; and &ldquo;htons&rdquo;.</p><br><p>Special case: if you want to send a packet to yourself, there&rsquo;s no need to query the IP address of your own machine, just pass in the loopback address 127.0.0.1 and the packet will be sent to your local machine.</p><br><h2 id="receiving-packets">Receiving packets</h2><br><p>Once you have a UDP socket bound to a port, any UDP packets sent to your sockets IP address and port are placed in a queue. To receive packets just loop and call &ldquo;recvfrom&rdquo; until it fails with EWOULDBLOCK indicating there are no more packets to receive.</p><br><p>Since UDP is connectionless, packets may arrive from any number of different computers. Each time you receive a packet &ldquo;recvfrom&rdquo; gives you the IP address and port of the sender, so you know where the packet came from.</p><br><p>Here&rsquo;s how to loop and receive all incoming packets:</p><br><pre><code>    while ( true )<br>    {<br>        unsigned char packet_data[256];<br><br>        unsigned int max_packet_size =<br>            sizeof( packet_data );<br><br>        #if PLATFORM == PLATFORM_WINDOWS<br>        typedef int socklen_t;<br>        #endif<br><br>        sockaddr_in from;<br>        socklen_t fromLength = sizeof( from );<br><br>        int bytes = recvfrom( socket,<br>                              (char)packet_data,<br>                              max_packet_size,<br>                              0,<br>                              (sockaddr<em>)&amp;from,<br>                              &amp;fromLength );<br><br>        if ( bytes &lt;= 0 )<br>            break;<br><br>        unsigned int from_address =<br>            ntohl( from.sin_addr.s_addr );<br><br>        unsigned int from_port =<br>            ntohs( from.sin_port );<br><br>        // process received packet<br>    }<br></em></code></pre><br><p>Any packets in the queue larger than your receive buffer will be silently discarded. So if you have a 256 byte buffer to receive packets like the code above, and somebody sends you a 300 byte packet, the 300 byte packet will be dropped. You <em>will not</em> receive just the first 256 bytes of the 300 byte packet.</p><br><p>Since you are writing your own game network protocol, this is no problem at all in practice, just make sure your receive buffer is big enough to receive the largest packet your code could possibly send.</p><br><h2 id="destroying-a-socket">Destroying a socket</h2><br><p>On most unix-like platforms, sockets are file handles so you use the standard file &ldquo;close&rdquo; function to clean up sockets once you are finished with them. However, Windows likes to be a little bit different, so we have to use &ldquo;closesocket&rdquo; instead:</p><br><pre>#if PLATFORM == PLATFORM_MAC ||<br>    PLATFORM == PLATFORM_UNIX<br>close( socket );<br>#elif PLATFORM == PLATFORM_WINDOWS<br>closesocket( socket );<br>#endif</pre><br><p>Hooray windows.</p><br><h2 id="socket-class">Socket class</h2><br><p>So we&rsquo;ve covered all the basic operations: creating a socket, binding it to a port, setting it to non-blocking, sending and receiving packets, and destroying the socket.</p><br><p>But you&rsquo;ll notice most of these operations are slightly platform dependent, and it&rsquo;s pretty annoying to have to remember to #ifdef and do platform specifics each time you want to perform socket operations.</p><br><p>We&rsquo;re going to solve this by wrapping all our socket functionality up into a &ldquo;Socket&rdquo; class. While we&rsquo;re at it, we&rsquo;ll add an &ldquo;Address&rdquo; class to make it easier to specify internet addresses. This avoids having to manually encode or decode a &ldquo;sockaddr_in&rdquo; structure each time we send or receive packets.</p><br><p>So let&rsquo;s add a socket class:</p><br><pre><code>    class Socket<br>    {<br>    public:<br><br>        Socket();<br><br>        ~Socket();<br><br>        bool Open( unsigned short port );<br><br>        void Close();<br><br>        bool IsOpen() const;<br><br>        bool Send( const Address &amp; destination,<br>                   const void  data,<br>                   int size );<br><br>        int Receive( Address &amp; sender,<br>                     void * data,<br>                     int size );<br><br>    private:<br><br>        int handle;<br>    };<br></code></pre><br><p>and an address class:</p><br><pre><code>    class Address<br>    {<br>    public:<br><br>        Address();<br><br>        Address( unsigned char a,<br>                 unsigned char b,<br>                 unsigned char c,<br>                 unsigned char d,<br>                 unsigned short port );<br><br>        Address( unsigned int address,<br>                 unsigned short port );<br><br>        unsigned int GetAddress() const;<br><br>        unsigned char GetA() const;<br>        unsigned char GetB() const;<br>        unsigned char GetC() const;<br>        unsigned char GetD() const;<br><br>        unsigned short GetPort() const;<br><br>    private:<br><br>        unsigned int address;<br>        unsigned short port;<br>    };<br></code></pre><br><p>Here&rsquo;s how to to send and receive packets with these classes:</p><br><pre><code>    // create socket<br><br>    const int port = 30000;<br><br>    Socket socket;<br><br>    if ( !socket.Open( port ) )<br>    {<br>        printf( &quot;failed to create socket!\n&quot; );<br>        return false;<br>    }<br><br>    // send a packet<br><br>    const char data[] = &quot;hello world!&quot;;<br><br>    socket.Send( Address(127,0,0,1,port), data, sizeof( data ) );<br><br>    // receive packets<br><br>    while ( true )<br>    {<br>        Address sender;<br>        unsigned char buffer[256];<br>        int bytes_read =<br>            socket.Receive( sender,<br>                            buffer,<br>                            sizeof( buffer ) );<br>        if ( !bytes_read )<br>            break;<br><br>        // process packet<br>    }<br></code></pre><br><p>As you can see it&rsquo;s much simpler than using BSD sockets directly.</p><br><p>As an added bonus the code is the same on all platforms because everything platform specific is handled inside the socket and address classes.</p><br><h2 id="conclusion">Conclusion</h2><br><p>You now have a platform independent way to send and receive packets. <em>Enjoy</em> :)</p>

<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p><a href="http://gad.qq.com/program/translateview/7165089" target="_blank" rel="noopener">译文出处</a></p>
<div style="display:none"><br><br><!--     把下文中的 $hhd$ 改为 <h 就可以恢复原状, 当时把 <h 改为 $hhd$ 是为了防止生成toc      --><br><br>因译文很多地方均有疏漏, 本文已经对部分疏漏做了修正.<br><br><div class="WordSection1"><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">翻译：杨嘉鑫（矫情到死的仓鼠君，</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">）审校：赵菁菁（轩语轩缘）</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></span></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">序言</span><span style="font-size:9.0pt;line-height:240%"> </span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">大家好，我是</span><span>Glenn Fiedler</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">，欢迎阅读《</span><span><a rel="noopener" href="http://gafferongames.com/networking-for-game-programmers/" title="针对游戏程序员的网络知识" target="_blank"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#383838;text-decoration:none"><span>针对游戏程序员的网络知识</span></span></a></span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">》系列教程的第二篇文章。</span><span style="color: rgb(51, 51, 51);"> </span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">在前面的文章中我们讨论了在不同计算机之间发送数据的方法，并决定使用</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">而非</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">传输控制协议（</span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#333333">TCP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">。我们之所以使用</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">，是因为它能够使数据在不等待重发包而造成数据聚集的情况下按时被送达。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">现在我将要告诉各位如何使用</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">发送和接收数据包。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">伯克利套接字</span><span style="font-size:9.0pt;line-height:240%"> </span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">（</span><span>BSD socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">）</span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">对于大多数现代的平台来说你都可以找到建立在伯克利套接字上的</span><span>sockets</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">。伯克利套接字主要通过</span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">“socket”,“bind”, “sendto” and “recvfr</span><span>om”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">几个简单函数进行控制。如果你愿意的话你当然可以直接对这几个函数进行调用，但是由于每个平台之间有细微差别，保持代码平台的独立性将会变得有些困难。因此，尽管我将先给各位介绍伯克利套接字的示例代码用以说明它的基本使用功能，我们也不会大量的直接使用伯克利套接字。所以当我们掌握了所有基础</span><span>socket </span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">功能后，我们将会把所有内容汇总到一个系列的课中，以便你可以轻松地编写代码。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></span></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">平台的特殊性</span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">首先</span> <span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">我们先建立<span style="border:none windowtext 1.0pt;padding:0cm">一个“</span></span><span style="border:none windowtext 1.0pt;padding:0cm">define</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">”程序用</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">来测试我们现有的平台是什么，这样我们就可以发现不同平台间间各个</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">里的细微差别。</span></span></p><div><div id="highlighter_477809" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp comments">// platform detection</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp preprocessor">#define PLATFORM_WINDOWS  1</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp preprocessor">#define PLATFORM_MAC      2</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp preprocessor">#define PLATFORM_UNIX     3</code></div><div class="line number8 index7 alt1"> </div><div class="line number9 index8 alt2"><code class="cpp preprocessor">#if defined(_WIN32)</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp preprocessor">#define PLATFORM PLATFORM_WINDOWS</code></div><div class="line number12 index11 alt1"> </div><div class="line number13 index12 alt2"><code class="cpp preprocessor">#elif defined(<strong>APPLE</strong>)</code></div><div class="line number14 index13 alt1"> </div><div class="line number15 index14 alt2"><code class="cpp preprocessor">#define PLATFORM PLATFORM_MAC</code></div><div class="line number16 index15 alt1"> </div><div class="line number17 index16 alt2"><code class="cpp preprocessor">#else</code></div><div class="line number18 index17 alt1"> </div><div class="line number19 index18 alt2"><code class="cpp preprocessor">#define PLATFORM PLATFORM_UNIX</code></div><div class="line number20 index19 alt1"> </div><div class="line number21 index20 alt2"><code class="cpp preprocessor">#endif</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">接下来我们为</span><span>sockets</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">写入适当的标头，由于头文件具有平台的特殊性所以我们将使用“</span><span>#define</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">”来根据不同的平台引用不同的文件。</span></span></p><div><div id="highlighter_806491" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp preprocessor">#if PLATFORM == PLATFORM_WINDOWS</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#include &lt;winsock2.h&gt;</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp preprocessor">#elif PLATFORM == PLATFORM_MAC ||</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">      </code><code class="cpp plain">PLATFORM == PLATFORM_UNIX</code></div><div class="line number8 index7 alt1"> </div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#include &lt;sys socket.h=””&gt;</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#include &lt;netinet in.h=””&gt;</code></div><div class="line number12 index11 alt1"> </div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#include &lt;fcntl.h&gt;</code></div><div class="line number14 index13 alt1"> </div><div class="line number15 index14 alt2"><code class="cpp preprocessor">#endif&lt;/fcntl.h&gt;&lt;/netinet&gt;&lt;/sys&gt;&lt;/winsock2.h&gt;</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果</span><span>sockets</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是建立在</span><span>unix</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">平台上，我们就不需要任何其他多余的连接，若它是建立在</span><span>windows</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">系统里，为了确保</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">正常使用我们就需要连接到“</span><span>winsock</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">”库内。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><span style="font-size:medium;">以下是一个简单的技巧，它可以在不改变已有项目或生成文件的前提下完成上述工作。</span></span></p><div><div id="highlighter_251577" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp preprocessor">#if PLATFORM == PLATFORM_WINDOWS</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp preprocessor">#pragma comment( lib, “wsock32.lib” )</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp preprocessor">#endif</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt; text-indent: 24pt;"><br></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">我之所以非常喜欢这个小技巧是因为我太懒了</span><span>~</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">当然啦，如果你愿意每次都进行项目链接或生成文件也未尝不可。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></p>$hhd$1&gt;<span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">层的初始化</span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">大多数“</span><span>unix-like</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">”的平台</span><span> (</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">包括</span><span>macosx) </span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是不需要任何特殊的步骤去初始化</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">层的。但是</span><span>Windows</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">需要进行一些特殊设置来确保你的</span><span>sockets</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">代码正常工作。在你使用其他任何</span><span>sockets</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">功能前你必须先调用</span><span> “WSAStartup” </span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">来初始化它们，在你的程序段结束时你也必须使用</span><span> “WSACleanup”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">来结束。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><span style="font-size:medium;">下面让我们来添加以上两个新功能：</span></span></p><div><div id="highlighter_446190" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">bool</code> <code class="cpp plain">InitializeSockets()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#if PLATFORM == PLATFORM_WINDOWS</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">WSADATA WsaData;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp plain">WSAStartup( MAKEWORD(2,2), &amp;WsaData ) == NO_ERROR;</code></div><div class="line number7 index6 alt2"> </div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp preprocessor">#else</code></div><div class="line number9 index8 alt2"> </div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number11 index10 alt2"> </div><div class="line number12 index11 alt1"><code class="cpp spaces">    </code><code class="cpp preprocessor">#endif</code></div><div class="line number13 index12 alt2"><code class="cpp plain">}</code></div><div class="line number14 index13 alt1"> </div><div class="line number15 index14 alt2"> </div><div class="line number16 index15 alt1"> </div><div class="line number17 index16 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">ShutdownSockets()</code></div><div class="line number18 index17 alt1"><code class="cpp plain">{</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#if PLATFORM == PLATFORM_WINDOWS</code></div><div class="line number20 index19 alt1"> </div><div class="line number21 index20 alt2"><code class="cpp spaces">    </code><code class="cpp plain">WSACleanup();</code></div><div class="line number22 index21 alt1"> </div><div class="line number23 index22 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#endif</code></div><div class="line number24 index23 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt; text-indent: 24pt;"><br></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">这样我们就得到了一个初始化</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">层的方法。对于那些不需要</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">初始化的平台来说这些功能可以忽略不计。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></span></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">建立一个</span><span>socket</span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">现在是时候来建立一个基于</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">）的</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">了，下面是实施的方法：</span></span></p><div><div id="highlighter_572686" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">handle = socket( AF_INET, SOCK_DGRAM,IPPROTO_UDP );</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp keyword bold">if</code> <code class="cpp plain">( handle &lt;= 0 )</code></div><div class="line number4 index3 alt1"><code class="cpp plain">{</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp functions bold">printf</code><code class="cpp plain">( </code><code class="cpp string">“failed to create socket\n”</code> <code class="cpp plain">);</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;</code></div><div class="line number8 index7 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">接下来我们把用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">）的</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">对应到一个端口上（比如</span><span>30000</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">这个端口）。每一个</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">都必须对应到一个独一无二的端口上。这么做的原因是端口号决定了每个数据包发送到的位置。不要使用</span><span>1024</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">以下的端口，因为这是为系统调用所预留的。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">有一种特殊情况，如</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;display:none">果你不在乎</span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#333333;display:none">socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;display:none">指定到哪个端口上，你就</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">可以输入“</span><span>0</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">”，这样系统将会自动为你选择一个闲置的端口。</span></span></p><div><div id="highlighter_845519" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">sockaddr_in address;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">address.sin_family = AF_INET;</code></div><div class="line number3 index2 alt2"><code class="cpp plain">address.sin_addr.s_addr = INADDR_ANY;</code></div><div class="line number4 index3 alt1"><code class="cpp plain">address.sin_port = htons( (unsigned </code><code class="cpp color1 bold">short</code><code class="cpp plain">) port );</code></div><div class="line number5 index4 alt2"> </div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp keyword bold">if</code> <code class="cpp plain">( bind( handle, (</code><code class="cpp keyword bold">const</code> <code class="cpp plain">sockaddr<em>) &amp;address, </em></code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">(sockaddr_in) ) &lt; 0 )</code></div><div class="line number8 index7 alt1"><code class="cpp plain">{</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp functions bold">printf</code><code class="cpp plain">( </code><code class="cpp string">“failed to bind socket\n”</code> <code class="cpp plain">);</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;</code></div><div class="line number12 index11 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">这样我们的</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">已经准备就绪并可以发送和接收包了。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">那么上面提到的</span><span>“htons”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是起什么作用</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;display:none">呢？这是一个辅助功能，它将一个</span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#333333;display:none">16</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;display:none">位整数的值由主机字节序列（小端或大端）转换成网络字节序列（大端）。</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">这就要求你在任何时候都直接在</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">结构里设置整数数字。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">你会看到</span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#333333">“htons”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">（主机到网络短字节）及其</span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#333333">32</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">位整数大小的表兄妹”htonl”</span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#333333"></span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">（主机到网络长字节）这在这篇文章中被多次使用，你留意了以后你在下文中再次遇到就会明白。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333"><br></span></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">将</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">设置为非阻塞形式</span><span>            </span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span> </span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">默认情况下，</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是被设置在</span><span> “</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">阻塞模式</span><span>”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">的状态下。这意味着，如果你想使用</span><span>“recvfrom”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">功能读一个包，在一个数据包被读取前该函数值将不能被返回。这与我们的目标完全不符。视频游戏是拟态在</span><span>30</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">或</span><span>60</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">帧每秒实时的程序，他们不能只是坐在那里等待数据包的到达！</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">解决方案是你将</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">转换成以</span><span>“</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">非阻塞模式</span><span>”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">后再创建他们。一旦做到这一点，当没有包可供阅读时，</span><span>“recvfrom”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">函数就可以立<span style="border:none windowtext 1.0pt;padding:0cm">即返回，返回值显示你应该稍后再尝试读取包。</span></span><span style="border:none windowtext 1.0pt;padding:0cm"> </span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">下面是如何将</span><span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">设置为非阻塞模式的方法：</span></span></p><div><div id="highlighter_979158" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp preprocessor">#if PLATFORM == PLATFORM_MAC || PLATFORM == PLATFORM_UNIX</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">nonBlocking = 1;</code></div><div class="line number4 index3 alt1"><code class="cpp keyword bold">if</code> <code class="cpp plain">( fcntl( handle, F_SETFL, O_NONBLOCK, nonBlocking ) == -1 )</code></div><div class="line number5 index4 alt2"><code class="cpp plain">{</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp functions bold">printf</code><code class="cpp plain">( </code><code class="cpp string">“failed to set non-blocking\n”</code> <code class="cpp plain">);</code></div><div class="line number7 index6 alt2"> </div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;</code></div><div class="line number9 index8 alt2"><code class="cpp plain">}</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp preprocessor">#elif PLATFORM == PLATFORM_WINDOWS</code></div><div class="line number12 index11 alt1"><code class="cpp color1 bold">DWORD</code> <code class="cpp plain">nonBlocking = 1;</code></div><div class="line number13 index12 alt2"><code class="cpp keyword bold">if</code> <code class="cpp plain">( ioctlsocket( handle, FIONBIO, &amp;nonBlocking ) != 0 )</code></div><div class="line number14 index13 alt1"><code class="cpp plain">{</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">    </code><code class="cpp functions bold">printf</code><code class="cpp plain">( </code><code class="cpp string">“failed to set non-blocking\n”</code> <code class="cpp plain">);</code></div><div class="line number16 index15 alt1"> </div><div class="line number17 index16 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;</code></div><div class="line number18 index17 alt1"><code class="cpp plain">}</code></div><div class="line number19 index18 alt2"> </div><div class="line number20 index19 alt1"><code class="cpp preprocessor">#endif</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">从上面的程序我们可以发现，</span><span>Windows</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">本身并不提供</span><span>“</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">框架</span><span>”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">的功能，所以我们使用</span><span>“ioctlsocket”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">功能来实现。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></span></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">发送数据包</span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是一种无连接协议，所以每次你发送一个数据包前都要指定一个目的地址。你可以使用一个</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">发送数据包到任意数量的不同的</span><span>IP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">地址，而在你</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">）</span> <span>socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">的另一端并没有连接某一台计算机。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">下面是如何发送一个数据包到一个特定的地址方法：</span></p><div><div id="highlighter_169965" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">sent_bytes = </code><code class="cpp plain">sendto( handle,</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">            </code><code class="cpp plain">(</code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">char</code><code class="cpp plain">)packet_data,</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">            </code><code class="cpp plain">packet_size,</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">            </code><code class="cpp plain">0,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">            </code><code class="cpp plain">(sockaddr<em>)&amp;address,</em></code></div><div class="line number7 index6 alt2"><code class="cpp spaces">            </code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">(sockaddr_in) );</code></div><div class="line number8 index7 alt1"> </div><div class="line number9 index8 alt2"><code class="cpp keyword bold">if</code> <code class="cpp plain">( sent_bytes != packet_size )</code></div><div class="line number10 index9 alt1"><code class="cpp plain">{</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp functions bold">printf</code><code class="cpp plain">( </code><code class="cpp string">“failed to send packet\n”</code> <code class="cpp plain">);</code></div><div class="line number12 index11 alt1"> </div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;</code></div><div class="line number14 index13 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">很重要的一点！“</span><span style="border:none windowtext 1.0pt;padding:0cm">sendto”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">的返回值只是表明数据包是否被成功地从本地计算机发送，它并不能表明目标计算机是否成功接收到你的数据包！用户数据报协议（</span><span style="border:none windowtext 1.0pt;padding:0cm">UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">）没有办法知道数据包是否能到达目的地。</span><span style="border:none windowtext 1.0pt;padding:0cm">             </span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">上面的代码中，我们通<span style="border:none windowtext 1.0pt;padding:0cm">过</span></span><span style="border:none windowtext 1.0pt;padding:0cm">“sockaddr_in”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">结构为目的地址。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm"><span style="font-size:medium;">那么我们如何设置这些结构呢？</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">现在让我们以发送到</span><span style="border:none windowtext 1.0pt;padding:0cm">207.45.186.98:30000 </span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">这个地址为例</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm"><span style="font-size:medium;">我们从以下这个程序开始：</span></span></p><div><div id="highlighter_656029" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">a = 207;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">b = 45;</code></div><div class="line number3 index2 alt2"><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">c = 186;</code></div><div class="line number4 index3 alt1"><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">d = 98;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code> <code class="cpp plain">port = 30000;</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp plain">我们还要在形式上进行设置从而符合“sendto”的要求：</code></div><div class="line number8 index7 alt1"><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">address = ( a &lt;&lt; 24 ) |</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">                       </code><code class="cpp plain">( b &lt;&lt; 16 ) |</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">                       </code><code class="cpp plain">( c &lt;&lt; 8  ) | d;</code></div><div class="line number11 index10 alt2"> </div><div class="line number12 index11 alt1"> </div><div class="line number13 index12 alt2"><code class="cpp plain">sockaddr_in addr;</code></div><div class="line number14 index13 alt1"><code class="cpp plain">addr.sin_family = AF_INET;</code></div><div class="line number15 index14 alt2"><code class="cpp plain">addr.sin_addr.s_addr = htonl( address );</code></div><div class="line number16 index15 alt1"><code class="cpp plain">addr.sin_port = htons( port );</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">正如您所看到的，我们首先将</span><span style="border:none windowtext 1.0pt;padding:0cm">A</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">、</span><span style="border:none windowtext 1.0pt;padding:0cm">B</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">、</span><span style="border:none windowtext 1.0pt;padding:0cm">C</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">、</span><span style="border:none windowtext 1.0pt;padding:0cm">D</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">值在范围[ 0, 255 ]内的值</span><span style="border:none windowtext 1.0pt;padding:0cm"></span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">转化为一个单一的无符号整数，从而使这个整数的每个字节对应输入值。然后以整数地址和端口来初始化一个</span><span style="border:none windowtext 1.0pt;padding:0cm">“sockaddr_in”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">结构，这样就确保使用“</span><span style="border:none windowtext 1.0pt;padding:0cm">htonl” </span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">和</span><span style="border:none windowtext 1.0pt;padding:0cm">“htons</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">”来将整型地址和端口值从主机字节序列转换为为网络字节序列。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">一种特殊情况：如果你想给自己发送一个数据包，不需要查询自己机器的</span><span style="border:none windowtext 1.0pt;padding:0cm">IP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">地址，在回送地址</span><span style="border:none windowtext 1.0pt;padding:0cm">127.0.0.1</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">中数据包就将被发送到你的本地机器。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm"><br></span></span></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">接收数据包</span> <p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">一旦你将一个</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">套接字绑定到一个端口，任何发送到您</span><span style="border:none windowtext 1.0pt;padding:0cm">scoket IP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">地址和端口的</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">数据包都将放在一个队列里。接收数据包的话, 只需要循环调用</span><span style="border:none windowtext 1.0pt;padding:0cm"> <span>“recvfrom”</span></span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">函数直到他失败并返回”EWOULDBLOCK”，这就意味着队列里有没有留下其他的数据包了。由于</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">是无连接性的，数据包可以到达许多不同的计算机。每当你收到一个数据包，</span><span style="border:none windowtext 1.0pt;padding:0cm">“recvfrom”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">都会给你发送者的</span><span style="border:none windowtext 1.0pt;padding:0cm">IP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">地址和端口以便你知道这是来自哪里的数据包。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm"><span style="font-size:medium;">下面是如何进行循环接收传入的数据包的方法：</span></span></p><div><div id="highlighter_421199" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">while</code> <code class="cpp plain">( </code><code class="cpp keyword bold">true</code> <code class="cpp plain">)</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">packet_data[256];</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">max_packet_size = </code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">( packet_data );</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#if PLATFORM == PLATFORM_WINDOWS</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">socklen_t;</code></div><div class="line number8 index7 alt1"> </div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp preprocessor">#endif</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp plain">sockaddr_in from;</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">    </code><code class="cpp plain">socklen_t fromLength = </code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">( from );</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">bytes = recvfrom( socket,</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">        </code><code class="cpp plain">(</code><code class="cpp color1 bold">char</code><code class="cpp plain">)packet_data,</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">        </code><code class="cpp plain">max_packet_size,</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">         </code><code class="cpp plain">0,</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">        </code><code class="cpp plain">(sockaddr<em>)&amp;from,</em></code></div><div class="line number18 index17 alt1"><code class="cpp spaces">        </code><code class="cpp plain">&amp;fromLength );</code></div><div class="line number19 index18 alt2"> </div><div class="line number20 index19 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( bytes &lt;= 0 )</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">break</code><code class="cpp plain">; </code></div><div class="line number22 index21 alt1"> </div><div class="line number23 index22 alt2"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">from_address = ntohl( from.sin_addr.s_addr );</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">from_port = ntohs( from.sin_port );</code></div><div class="line number25 index24 alt2"> </div><div class="line number26 index25 alt1"><code class="cpp spaces">    </code><code class="cpp comments">// process received packet</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">    </code> </div><div class="line number28 index27 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">在队列中，数据包一旦大于你接收缓冲区的范围，他们都会被系统悄悄舍弃。因此，如果你有一个</span><span style="border:none windowtext 1.0pt;padding:0cm">256</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">字节的缓冲区用来接收数据包，有人给你一个发送</span><span style="border:none windowtext 1.0pt;padding:0cm">300</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">字节的数据包，</span><span style="border:none windowtext 1.0pt;padding:0cm">300</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">字节的数据包都将被删除。您将不会接收到</span><span style="border:none windowtext 1.0pt;padding:0cm">300</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">字节数据包的前</span><span style="border:none windowtext 1.0pt;padding:0cm">256</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">个字节。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm"><span style="font-size:medium;">因为您正在编写自己的游戏网络协议，以上这些操作这是没有什么影响的。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm"><span style="font-size:medium;">在实践中您就要确保您的接收缓冲区足够大，以接收最大的数据包。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm"><span style="font-size:medium;"><br></span></span></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">关闭一个</span><span>socket</span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">在大多数</span><span style="border:none windowtext 1.0pt;padding:0cm">Unix</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">平台，一旦你完成了自己所需的程序后，在</span><span style="border:none windowtext 1.0pt;padding:0cm">socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">文件中只要使用标准的文件</span><span style="border:none windowtext 1.0pt;padding:0cm">“close”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">函数来清理即可。然而，在</span><span style="border:none windowtext 1.0pt;padding:0cm">Windows</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">系统中以上情形会有点不同，我们要用</span><span style="border:none windowtext 1.0pt;padding:0cm">“closesocket”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">函数来操作：</span></span></p><div><div id="highlighter_757088" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp preprocessor">#if PLATFORM == PLATFORM_MAC ||  PLATFORM == PLATFORM_UNIX</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp plain">close( socket );</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp preprocessor">#elif PLATFORM == PLATFORM_WINDOWS</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp plain">closesocket( socket );</code></div><div class="line number8 index7 alt1"> </div><div class="line number9 index8 alt2"><code class="cpp preprocessor">#endif</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="border:none windowtext 1.0pt;padding:0cm"> </span></p>$hhd$1&gt;<span>Socket class</span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">现在，我们已经完成了所有的基本操作：创建一个</span><span style="border:none windowtext 1.0pt;padding:0cm">socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">，将他绑定到一个端口并设置为非阻塞，发送和接收数据包，清除</span><span style="border:none windowtext 1.0pt;padding:0cm">socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">但是你会发现以上这些操作中多多少少都是依赖于平台的，在每一次你想执行</span><span style="border:none windowtext 1.0pt;padding:0cm">socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">操作时，你不得不记住“</span><span style="border:none windowtext 1.0pt;padding:0cm"># ifdef</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">”指令和针对不同平台的各种细节，这些繁琐的操作是很令人抓狂的。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">为了解决这个问题，我们可以将所有的</span><span style="border:none windowtext 1.0pt;padding:0cm">socket</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">功能封装成一个“</span><span style="border:none windowtext 1.0pt;padding:0cm">socket class</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">‘’。当我们在使用它的时候，我们将添加一个</span><span style="border:none windowtext 1.0pt;padding:0cm">“Address class</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">‘’，这样使它更容易指定互联网地址。这避免了我们每次发送或接收数据包时进行手动编码或解码</span><span style="border:none windowtext 1.0pt;padding:0cm">“sockaddr_in”</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">结构。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">下面是“</span><span style="border:none windowtext 1.0pt;padding:0cm">socket class</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">‘’的程序：</span></span></p><div><div id="highlighter_13343" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">class</code> <code class="cpp plain">Socket</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp keyword bold">public</code><code class="cpp plain">:</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">Socket();</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">~Socket();</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Open( unsigned </code><code class="cpp color1 bold">short</code> <code class="cpp plain">port );</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">void</code> <code class="cpp plain">Close();</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">IsOpen() </code><code class="cpp keyword bold">const</code><code class="cpp plain">;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Send( </code><code class="cpp keyword bold">const</code> <code class="cpp plain">Address &amp; destination,</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">               </code><code class="cpp keyword bold">const</code> <code class="cpp keyword bold">void</code> <code class="cpp plain"> data,</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">               </code><code class="cpp color1 bold">int</code> <code class="cpp plain">size );</code></div><div class="line number13 index12 alt2"> </div><div class="line number14 index13 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">Receive( Address &amp; sender,</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">                 </code><code class="cpp keyword bold">void</code> <code class="cpp plain">* data,</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">                 </code><code class="cpp color1 bold">int</code> <code class="cpp plain">size );</code></div><div class="line number17 index16 alt2"> </div><div class="line number18 index17 alt1"><code class="cpp keyword bold">private</code><code class="cpp plain">:</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">handle;</code></div><div class="line number20 index19 alt1"> </div><div class="line number21 index20 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt; text-indent: 24pt;"><br></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">下面是“</span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">address class</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">”的程序：</span></span></p><div><div id="highlighter_501052" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">class</code> <code class="cpp plain">Address</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp keyword bold">public</code><code class="cpp plain">:</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">Address();</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">Address( unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">a,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">             </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">b,</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">             </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">c,</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">             </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">d,</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">             </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code> <code class="cpp plain">port );</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp plain">Address( unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">address,</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">             </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code> <code class="cpp plain">port );</code></div><div class="line number13 index12 alt2"> </div><div class="line number14 index13 alt1"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">GetAddress() </code><code class="cpp keyword bold">const</code><code class="cpp plain">;</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">GetA() </code><code class="cpp keyword bold">const</code><code class="cpp plain">;</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">GetB() </code><code class="cpp keyword bold">const</code><code class="cpp plain">;</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">GetC() </code><code class="cpp keyword bold">const</code><code class="cpp plain">;</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">GetD() </code><code class="cpp keyword bold">const</code><code class="cpp plain">;</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code> <code class="cpp plain">GetPort() </code><code class="cpp keyword bold">const</code><code class="cpp plain">;</code></div><div class="line number20 index19 alt1"> </div><div class="line number21 index20 alt2"><code class="cpp keyword bold">private</code><code class="cpp plain">:</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code> <code class="cpp plain">address;</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code> <code class="cpp plain">port;</code></div><div class="line number24 index23 alt1"> </div><div class="line number25 index24 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">下面是这些</span><span style="border:none windowtext 1.0pt;padding:0cm">class</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;padding:0cm">如何接收和发送数据包的程序：</span></p><div><div id="highlighter_565095" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp comments">// create socket</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">port = 30000;</code></div><div class="line number3 index2 alt2"><code class="cpp plain">Socket socket;</code></div><div class="line number4 index3 alt1"><code class="cpp keyword bold">if</code> <code class="cpp plain">( !socket.Open( port ) )</code></div><div class="line number5 index4 alt2"><code class="cpp plain">{</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp functions bold">printf</code><code class="cpp plain">( </code><code class="cpp string">“failed to create socket!\n”</code> <code class="cpp plain">);</code></div><div class="line number7 index6 alt2"> </div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;</code></div><div class="line number9 index8 alt2"><code class="cpp plain">}</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp comments">// send a packet</code></div><div class="line number12 index11 alt1"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">char</code> <code class="cpp plain">data[] = </code><code class="cpp string">“hello world!”</code><code class="cpp plain">;</code></div><div class="line number13 index12 alt2"><code class="cpp plain">socket.Send( Address(127,0,0,1,port), data, </code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">( data ) );</code></div><div class="line number14 index13 alt1"> </div><div class="line number15 index14 alt2"> </div><div class="line number16 index15 alt1"><code class="cpp comments">// receive packets</code></div><div class="line number17 index16 alt2"><code class="cpp keyword bold">while</code> <code class="cpp plain">( </code><code class="cpp keyword bold">true</code> <code class="cpp plain">)</code></div><div class="line number18 index17 alt1"><code class="cpp plain">{</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">    </code><code class="cpp plain">Address sender;</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">    </code><code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code> <code class="cpp plain">buffer[256];</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">bytes_read =</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">        </code><code class="cpp plain">socket.Receive( sender,</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">                        </code><code class="cpp plain">buffer,</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">                        </code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">( buffer ) );</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !bytes_read )</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">break</code><code class="cpp plain">;</code></div><div class="line number27 index26 alt2"> </div><div class="line number28 index27 alt1"> </div><div class="line number29 index28 alt2"><code class="cpp spaces">    </code><code class="cpp comments">// process packet</code></div><div class="line number30 index29 alt1"> </div><div class="line number31 index30 alt2"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt; text-indent: 24pt;"><br></p>$hhd$1&gt;<span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">结论</span><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">我们现在有了一种不限平台的方法来发送和接收</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）的</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">数据包。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">用户数据报协议（</span><span>UDP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">）</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是无连接性的，因此我编写了一个简单的示例程序，它可以从文本文件中读取</span><span>IP</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">地址，并能够每秒向这些地址发送一个数据包。每当这个程序接收到一个数据包时，它就会告诉你它们来自哪个机器，以及接收到的数据包的大小。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><span style="font-size:medium;">您可以很容易地设置它，然后你就拥有了一系列在本地机器上互相发送数据包的节点。这样你就可以利用以下程序通过不同的端口，进入不同的应用程序：</span></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt; text-indent: 24pt;"><em><span style="border:none"><span style="border:none"><span style="font-size:medium;">   &gt; Node30000</span></span></span></em></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt; text-indent: 24pt;"><em><span style="border:none"><span style="border:none"><span style="font-size:medium;">   &gt; Node 30001</span></span></span></em></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt; text-indent: 24pt;"><em><span style="border:none"><span style="border:none"><span style="font-size:medium;">   &gt; Node 30002</span></span></span></em></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt; text-indent: 24pt;"><em><span style="border:none"><span style="border:none"><span style="font-size:medium;">   etc…</span></span></span></em></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">然后每个节点都将尝试发送数据包到每个其他节点，它的工作原理就像一个小型的“</span><span>peer-to-peer</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">”设置。</span></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">我是在</span><span>MacOSX</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">系统中开发的这个程序，但我想你应该能够轻松地在任何</span><span>Unix</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">系统或</span><span>Windows</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">上对他进行编译。如果你有任何应用在其他不同机器上的兼容性补丁，也非常欢迎您与我取得联系。</span></span></p><p class="MsoNormal" align="left" style="text-indent: 24pt;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><span style="font-size:medium;"><br></span></span></p><p class="MsoNormal" align="left" style="text-indent: 0cm; line-height: 18pt;"><span style="font-size:medium;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">【版权声明】</span><span style="font-family: 微软雅黑, sans-serif; color: rgb(51, 51, 51);"> </span></span></p><p class="MsoNormal" align="left" style="text-indent: 0cm;"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><span style="font-size:medium;">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权。</span></span><span style="font-size:9.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333"> </span></p><p class="MsoNormal" align="left" style="text-indent: 24pt;"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p></div>                    </div><br>                

<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p>因 Gaffer On Games 的源码原下载地址失效, 所以特地补上.</p>
<p><a href="https://github.com/no5ix/ReliableUDP" target="_blank" rel="noopener">请点击</a></p>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2016/11/14/游戏网络开发一之TCPvsUDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/14/游戏网络开发一之TCPvsUDP/" itemprop="url">游戏网络开发一之TCPvsUDP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-14T22:20:34+00:00">
                2016-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/udp_vs_tcp/" target="_blank" rel="noopener">原文出处</a></p>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I&rsquo;m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <a href="https://gafferongames.com/categories/game-networking/" target="_blank" rel="noopener"><strong>Networking for Game Programmers</strong></a>.</p><br><p>In this article we start with the most basic aspect of network programming: sending and receiving data over the network. This is perhaps the simplest and most basic part of what network programmers do, but still it is quite intricate and non-obvious as to what the best course of action is.</p><br><p>You have most likely heard of sockets, and are probably aware that there are two main types: TCP and UDP. When writing a network game, we first need to choose what type of socket to use. Do we use TCP sockets, UDP sockets or a mixture of both? Take care because if you get this wrong it will have terrible effects on your multiplayer game!</p><br><p>The choice you make depends entirely on what sort of game you want to network. So from this point on and for the rest of this article series, I assume you want to network an action game. You know, games like Halo, Battlefield 1942, Quake, Unreal, CounterStrike and Team Fortress.</p><br><p>In light of the fact that we want to network an action game, we&rsquo;ll take a very close look at the properties of each protocol, and dig a bit into how the internet actually works. Once we have all this information, the correct choice is clear.</p><br><h2 id="tcp-ip">TCP/IP</h2><br><p>TCP stands for &ldquo;transmission control protocol&rdquo;. IP stands for &ldquo;internet protocol&rdquo;. Together they form the backbone for almost everything you do online, from web browsing to IRC to email, it&rsquo;s all built on top of TCP/IP.</p><br><p>If you have ever used a TCP socket, then you know it&rsquo;s a reliable connection based protocol. This means you create a connection between two machines, then you exchange data much like you&rsquo;re writing to a file on one side, and reading from a file on the other.</p><br><p>TCP connections are reliable and ordered. All data you send is guaranteed to arrive at the other side and in the order you wrote it. It&rsquo;s also a stream protocol, so TCP automatically splits your data into packets and sends them over the network for you.</p><br><h2 id="ip">IP</h2><br><p>The simplicity of TCP is in stark contrast to what actually goes on underneath TCP at the IP or &ldquo;internet protocol&rdquo; level.</p><br><p>Here there is no concept of connection, packets are simply passed from one computer to the next. You can visualize this process being somewhat like a hand-written note passed from one person to the next across a crowded room, eventually, reaching the person it&rsquo;s addressed to, but only after passing through many hands.</p><br><p>There is also no guarantee that this note will actually reach the person it is intended for. The sender just passes the note along and hopes for the best, never knowing whether or not the note was received, unless the other person decides to write back!</p><br><p>Of course IP is in reality a little more complicated than this, since no one computer knows the exact sequence of computers to pass the packet along to so that it reaches its destination quickly. Sometimes IP passes along multiple copies of the same packet and these packets make their way to the destination via different paths, causing packets to arrive out of order and in duplicate.</p><br><p>This is because the internet is designed to be self-organizing and self-repairing, able to route around connectivity problems rather than relying on direct connections between computers. It&rsquo;s actually quite cool if you think about what&rsquo;s <em>really</em> going on at the low level. You can read all about this in the classic book <a href="http://www.cs.newpaltz.edu/~pletcha/NET_PY/the-protocols-tcp-ip-illustrated-volume-1.9780201633467.24290.pdf" target="_blank" rel="noopener">TCP/IP Illustrated</a>.</p><br><h2 id="udp">UDP</h2><br><p>Instead of treating communications between computers like writing to files, what if we want to send and receive packets directly?</p><br><p>We can do this using UDP.</p><br><p>UDP stands for &ldquo;user datagram protocol&rdquo; and it&rsquo;s another protocol built on top of IP, but unlike TCP, instead of adding lots of features and complexity, UDP is a very thin layer over IP.</p><br><p>With UDP we can send a packet to a destination IP address (eg. 112.140.20.10) and port (say 52423), and it gets passed from computer to computer until it arrives at the destination or is lost along the way.</p><br><p>On the receiver side, we just sit there listening on a specific port (eg. 52423) and when a packet arrives from <em>any</em> computer (remember there are no connections!), we get notified of the address and port of the computer that sent the packet, the size of the packet, and can read the packet data.</p><br><p>Like IP, UDP is an unreliable protocol. In practice however, most packets that are sent <em>will</em> get through, but you&rsquo;ll usually have around 1-5% packet loss, and occasionally you&rsquo;ll get periods where no packets get through at all (remember there are lots of computers between you and your destination where things can go wrong&hellip;)</p><br><p>There is also no guarantee of ordering of packets with UDP. You could send 5 packets in order 1,2,3,4,5 and they could arrive completely out of order like 3,1,2,5,4. In practice, packets tend to arrive in order <em>most</em> of the time, but you cannot rely on this!</p><br><p>UDP also provides a 16 bit checksum, which in theory is meant to protect you from receiving invalid or truncated data, but you can&rsquo;t even trust this, since 16 bits is just not enough protection when you are sending UDP packets rapidly over a long period of time. Statistically, you can&rsquo;t even rely on this checksum and must add your own.</p><br><p>So in short, when you use UDP you&rsquo;re pretty much on your own!</p><br><h2 id="tcp-vs-udp">TCP vs. UDP</h2><br><p>We have a decision to make here, do we use TCP sockets or UDP sockets?</p><br><p>Lets look at the properties of each:</p><br><p>TCP:</p><br><ul><br><li>Connection based</li><br><li>Guaranteed reliable and ordered</li><br><li>Automatically breaks up your data into packets for you</li><br><li>Makes sure it doesn’t send data too fast for the internet connection to handle (flow control)</li><br><li>Easy to use, you just read and write data like its a file</li><br></ul><br><p>UDP:</p><br><ul><br><li>No concept of connection, you have to code this yourself</li><br><li>No guarantee of reliability or ordering of packets, they may arrive out of order, be duplicated, or not arrive at all!</li><br><li>You have to manually break your data up into packets and send them</li><br><li>You have to make sure you don’t send data too fast for your internet connection to handle</li><br><li>If a packet is lost, you need to devise some way to detect this, and resend that data if necessary</li><br><li>You can’t even rely on the UDP checksum so you must add your own</li><br></ul><br><p>The decision seems pretty clear then, TCP does everything we want and its super easy to use, while UDP is a huge pain in the ass and we have to code everything ourselves from scratch.</p><br><p>So obviously we just use TCP right?</p><br><p>Wrong!</p><br><p>Using TCP is the worst possible mistake you can make when developing a multiplayer game! To understand why, you need to see what TCP is actually doing above IP to make everything look so simple.</p><br><h2 id="how-tcp-really-works">How TCP really works</h2><br><p>TCP and UDP are both built on top of IP, but they are radically different. UDP behaves very much like the IP protocol underneath it, while TCP abstracts everything so it looks like you are reading and writing to a file, hiding all complexities of packets and unreliability from you.</p><br><p>So how does it do this?</p><br><p>Firstly, TCP is a stream protocol, so you just write bytes to a stream, and TCP makes sure that they get across to the other side. Since IP is built on packets, and TCP is built on top of IP, TCP must therefore break your stream of data up into packets. So, some internal TCP code queues up the data you send, then when enough data is pending the queue, it sends a packet to the other machine.</p><br><p>This can be a problem for multiplayer games if you are sending very small packets. What can happen here is that TCP may decide it&rsquo;s not going to send data until you have buffered up enough data to make a reasonably sized packet to send over the network.</p><br><p>This is a problem because you want your client player input to get to the server <em>as quickly as possible</em>, if it is delayed or &ldquo;clumped up&rdquo; like TCP can do with small packets, the client&rsquo;s user experience of the multiplayer game will be very poor. Game network updates will arrive late and infrequently, instead of on-time and frequently like we want.</p><br><p>TCP has an option to fix this behavior called <a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm" target="_blank" rel="noopener">TCP_NODELAY</a>. This option instructs TCP not to wait around until enough data is queued up, but to flush any data you write to it immediately. This is referred to as disabling Nagle&rsquo;s algorithm.</p><br><p>Unfortunately, even if you set this option TCP still has serious problems for multiplayer games and it all stems from how TCP handles lost and out of order packets to present you with the &ldquo;illusion&rdquo; of a reliable, ordered stream of data.</p><br><h2 id="how-tcp-implements-reliability">How TCP implements reliability</h2><br><p>Fundamentally TCP breaks down a stream of data into packets, sends these packets over unreliable IP, then takes the packets received on the other side and reconstructs the stream.</p><br><p>But what happens when a packet is lost?</p><br><p>What happens when packets arrive out of order or are duplicated?</p><br><p>Without going too much into the details of how TCP works because its super-complicated (please refer to <a href="http://www.cs.newpaltz.edu/~pletcha/NET_PY/the-protocols-tcp-ip-illustrated-volume-1.9780201633467.24290.pdf" target="_blank" rel="noopener">TCP/IP Illustrated</a>) in essence TCP sends out a packet, waits a while until it detects that packet was lost because it didn&rsquo;t receive an ack (or acknowledgement), then resends the lost packet to the other machine. Duplicate packets are discarded on the receiver side, and out of order packets are resequenced so everything is reliable and in order.</p><br><p>The problem is that if we were to send our time critical game data over TCP, whenever a packet is dropped it has to stop and wait for that data to be resent. Yes, even if more recent data arrives, that new data gets put in a queue, and you cannot access it until that lost packet has been retransmitted. How long does it take to resend the packet?</p><br><p>Well, it&rsquo;s going to take <em>at least</em> round trip latency for TCP to work out that data needs to be resent, but commonly it takes 2*RTT, and another one way trip from the sender to the receiver for the resent packet to get there. So if you have a 125ms ping, you&rsquo;ll be waiting roughly 1/5th of a second for the packet data to be resent <em>at best</em>, and in worst case conditions you could be waiting up to half a second or more (consider what happens if the attempt to resend the packet fails to get through?). What happens if TCP decides the packet loss indicates network congestion and it backs off? Yes it actually does this. Fun times!</p><br><h2 id="never-use-tcp-for-time-critical-data">Never use TCP for time critical data</h2><br><p>The problem with using TCP for realtime games like FPS is that unlike web browsers, or email or most other applications, these multiplayer games have a <em>real time requirement</em> on packet delivery.</p><br><p>What this means is that for many parts of a game, for example player input and character positions, it really doesn&rsquo;t matter what happened a second ago, the game only cares about the most recent data.</p><br><p>TCP was simply not designed with this in mind.</p><br><p>Consider a very simple example of a multiplayer game, some sort of action game like a shooter. You want to network this in a very simple way. Every frame you send the input from the client to the server (eg. keypresses, mouse input controller input), and each frame the server processes the input from each player, updates the simulation, then sends the current position of game objects back to the client for rendering.</p><br><p>So in our simple multiplayer game, whenever a packet is lost, everything has to <em>stop and wait</em> for that packet to be resent. On the client game objects stop receiving updates so they appear to be standing still, and on the server input stops getting through from the client, so the players cannot move or shoot. When the resent packet finally arrives, you receive this stale, out of date information that you don&rsquo;t even care about! Plus, there are packets backed up in queue waiting for the resend which arrive at same time, so you have to process all of these packets in one frame. Everything is clumped up!</p><br><p>Unfortunately, there is nothing you can do to fix this behavior, it&rsquo;s just the fundamental nature of TCP. This is just what it takes to make the unreliable, packet-based internet look like a reliable-ordered stream.</p><br><p>Thing is we don&rsquo;t want a reliable ordered stream.</p><br><p>We want our data to get as quickly as possible from client to server without having to wait for lost data to be resent.</p><br><p>This is why you should <strong>never</strong> use TCP when networking time-critical data!</p><br><h2 id="wait-why-can-t-i-use-both-udp-and-tcp">Wait? Why can&rsquo;t I use <em>both</em> UDP and TCP?</h2><br><p>For realtime game data like player input and state, only the most recent data is relevant, but for other types of data, say perhaps a sequence of commands sent from one machine to another, reliability and ordering can be very important.</p><br><p>The temptation then is to use UDP for player input and state, and TCP for the reliable ordered data. If you&rsquo;re sharp you&rsquo;ve probably even worked out that you may have multiple &ldquo;streams&rdquo; of reliable ordered commands, maybe one about level loading, and another about AI. Perhaps you think to yourself, &ldquo;Well, I&rsquo;d really not want AI commands to stall out if a packet is lost containing a level loading command - they are completely unrelated!&rdquo;. You are right, so you may be tempted to create one TCP socket for each stream of commands.</p><br><p>On the surface, this seems like a great idea. The problem is that since TCP and UDP are both built on top of IP, the underlying packets sent by each protocol will affect each other. Exactly how they affect each other is quite complicated and relates to how TCP performs reliability and flow control, but fundamentally you should remember that TCP tends to <em>induce</em> packet loss in UDP packets. For more information, read <a href="http://www.isoc.org/INET97/proceedings/F3/F3_1.HTM" target="_blank" rel="noopener">this paper</a> on the subject.</p><br><p>Also, it&rsquo;s pretty complicated to mix UDP and TCP. If you mix UDP and TCP you lose a certain amount of control. Maybe you can implement reliability in a more efficient way that TCP does, better suited to your needs? Even if you need reliable-ordered data, it&rsquo;s possible, provided that data is small relative to the available bandwidth to get that data across faster and more reliably that it would if you sent it over TCP. Plus, if you have to do NAT to enable home internet connections to talk to each other, having to do this NAT once for UDP and once for TCP (not even sure if this is possible&hellip;) is kind of painful.</p><br><h2 id="conclusion">Conclusion</h2><br><p>My recommendation is not only that you use UDP, but that you <em>only</em> use UDP for your game protocol. Don&rsquo;t mix TCP and UDP! Instead, learn how to implement the specific features of TCP that you need <em>inside</em> your own custom UDP based protocol.</p><br><p>Of course, it is no problem to use HTTP to talk to some RESTful services while your game is running. I&rsquo;m not saying you can&rsquo;t do that. A few TCP connections running while your game is running isn&rsquo;t going to bring everything down. The point is, don&rsquo;t split your <em>game protocol</em> across UDP and TCP. Keep your game protocol running over UDP so you are fully in control of the data you send and receive and how reliability, ordering and congestion avoidance are implemented.</p><br><p>The rest of this article series show you how to do this, from creating your own virtual connection on top of UDP, to creating your own reliability, flow control and congestion avoidance.</p>


<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p><a href="http://gad.qq.com/program/translateview/7167380" target="_blank" rel="noopener">译文出处</a></p>
<div style="display:none"><br><br><!--     把下文中的 $hhd$ 改为 <h 就可以恢复原状, 当时把 <h 改为 $hhd$ 是为了防止生成toc      --><br><br><div><div class="WordSection1">$hhd$2 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-weight: normal;font-size:medium;font-family:微软雅黑;">翻译：<a rel="noopener" href="http://www.cnblogs.com/xueweihan/p/5452873.html" target="_blank">削微寒</a>     审校：<a rel="noopener" href="http://www.cnblogs.com/xueweihan/p/5452873.html" target="_blank">削微寒</a></span><div><span style="font-family: 微软雅黑, sans-serif;"><br></span></div>$hhd$2 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-family: 微软雅黑, sans-serif;">介绍</span><p style="margin: 0cm 0cm 0.0001pt; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">你一定听说过<span>sokcet(</span></span><span><a rel="noopener" href="http://www.cnblogs.com/xueweihan/p/5445483.html" target="_blank"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black"><span>初探socket</span></span></a></span><span style="font-family: 微软雅黑, sans-serif;">)</span><span style="font-family: 微软雅黑, sans-serif;">，它分为两种常用类型：<span>TCP</span>和<span>UDP</span>。当要写一个网络游戏，我们首先要选择使用哪种类型的<span>socket</span>。是用<span>TCP</span>、<span>UDP</span>还是两者都用？</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">选择哪种类型，完全取决于你要写的游戏的类型。后面的文章，我都将假设你要写一个<span>‘</span>动作<span>’</span>网游。就像：光环系列，战地<span>1942</span>，雷神之锤，这些游戏。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">我们将非常仔细的分析这两种<span>socket</span>类型的优劣，并且深入到底层，弄清楚互联网是如何工作的什么。当我们弄清楚这些信息后，就很容易做出正确的选择了。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$2 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-family: 微软雅黑, sans-serif;">TCP/IP</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">TCP</span><span style="font-family: 微软雅黑, sans-serif;">代表<span>“</span>传输控制协议<span>”</span>，<span>IP</span>代表：<span>“</span>互联网协议<span>”</span>，你在互联网上做任何事情，都是建立在这两者的基础上，比如：浏览网页、收发邮件等等。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$4 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">TCP</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">如果你曾经用过<span>TCP socket</span>，你肯定知道它是可靠连接的协议，面向连接的传输协议。简单的说：两台机器先建立起连接，然后两台机器相互发送数据，就像你在一台计算机上写文件，在另外一个台读文件一样。（我是这么理解的：<span>TCP socket</span>就像建立起连接的计算机，之间共享的一个<span>‘</span>文件<span>‘</span>对象，两者通过读写这个<span>‘</span>文件<span>‘</span>实现数据的传输）</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">这个连接是可靠的、有序的，代表着：发送的所有的数据，保证到达传输的另一端的时候。另一端得到的数据，和发送数据一摸一样（可靠，有序。例如：<span>A</span>发送数据<span>‘abc’</span>，通过<span>TCPsocket</span>传输数据到<span>B</span>，<span>B</span>得到数据一定是：<span>‘abc’</span>。而不是<span>‘bca’</span>或者<span>‘xueweihan’</span>之类的鬼！）。传输的数据是<span>‘</span>数据流<span>’</span>的形式<span>(</span>数据流：用于操作数据集合的最小的有序单位，与操作本地文件中的<span>stream</span>一样。所以<span>TCP socket</span>和文件对象很像<span>)</span>，也就是说：<span>TCP</span>把你的数据拆分后，包装成数据包，然后通过网络发送出去。</span></p><p style="margin: 0cm 0cm 0.0001pt; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><strong><span style="font-family: 微软雅黑, sans-serif;">注意</span></strong><span style="font-family: 微软雅黑, sans-serif;">：就像读写文件那样，这样比较好理解。</span></p><p style="margin: 0cm 0cm 0.0001pt; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$4 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">IP</span><p style="margin: 0cm 0cm 0.0001pt; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">“IP”</span><span style="font-family: 微软雅黑, sans-serif;">协议是在<span>TCP</span>协议的下面（这个牵扯到七层互联网协议栈，我就简单的贴个图不做详细的介绍）<span><br><img width="713" height="442" id="图片 8" src="http://gameweb-img.qq.com/gad/20160809/image001.1470706683.gif" alt="游戏网络开发(一)：UDP vs. TCP"></span></span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">“IP”</span><span style="font-family: 微软雅黑, sans-serif;">协议是没有连接的概念，它做的只是把上一层<span>(</span>传输层<span>)</span>的数据包从一个计算传递到下一个计算机。你可以理解成：这个过程就像一堆人手递手传递纸条一样，传递了很多次，最终到达纸条上标记的<span>xxx</span>手里（纸条上写着<span>‘xxx</span>亲启，偷看者<span>3cm’</span>）。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">在传递的过程中，不保证这个纸条<span>(</span>信件<span>)</span>能能够准确的送到收信人的手上。发信人发送信件，但是永远不知道信件是否可以准确到达收件人的手上，除非收件人回信告诉他（发信人）：<span>“</span>兄弟我收到信了！<span>”</span>（<span>IP</span>层只是用于传递信息，并不做信息的校验等其它操作）</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">当然，传递信息的这个过程还是还是很复杂的。因为，不知道具体的传递次序，也就是说，因为不知道最优的传递路线（能够让数据包快速的到达目的地的最优路径）所以，有些时候<span>“IP”</span>协议就传递多份一样的数据，这些数据通过不同的路线到达目的地，从而发现最优的传递路线。</span></p><p style="margin: 0cm 0cm 0.0001pt; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">这就是互联网设计中的：自动优化和自动修复，解决了连接的问题。这真的是一个很酷的设计，如果你想知道更多的底层实现，可以阅读关于<span>TCP/IP</span>的书。（推荐</span><span><a rel="noopener" href="http://item.jd.com/11519010.html" target="_blank"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black"><span>上野宣的图解系列</span></span></a></span><span style="font-family: 微软雅黑, sans-serif;">)</span></p><p style="margin: 0cm 0cm 0.0001pt; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$4 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">UDP</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">如果我们想要直接发送和接受数据包，那么就要使用另一种<span>socket</span>。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">我们叫它<span>UDP</span>。<span>UDP</span>代表<span>“</span>用户数据包协议<span>”</span>，它是另外一种建立在<span>IP</span>协议之上的协议，就像<span>TCP</span>一样，但是没有<span>TCP</span>那么多功能（例如：建立连接，信息的校验，数据流的拆分合并等）</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">使用<span>UDP</span>我们能够向目标<span>IP</span>和端口（例如<span>80</span>），发送数据包。数据包会达到目标计算机或者丢失。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">收件人（目标计算机），我们只需要监听具体的端口（例如：<span>80</span>），当从任意一台计算机（注意：<span>UDP</span>是不建立连接的）接受到数据包后，我们会得知发送数据包的计算机地址（<span>IP</span>地址）和端口、数据包的大小、内容。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">UDP</span><span style="font-family: 微软雅黑, sans-serif;">是不可靠协议。现实使用的过程中，发送的大多数的数据包都会被接收到，但是通常会丢失<span>1-5%</span>，偶尔，有的时候还可能啥都接收不到（数据包全部丢失一个都没接收到，传递数据的计算机之间的计算机的数量越多，出错的概率越大）。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">UDP</span><span style="font-family: 微软雅黑, sans-serif;">协议中的数据包也是没有顺序的。比如：你发送<span>5</span>个包，顺序是<span>1</span>，<span>2</span>，<span>3</span>，<span>4</span>，<span>5</span>。但是，即接收到的顺序可能是<span>3</span>，<span>1</span>，<span>4</span>，<span>2</span>，<span>5</span>。现实使用的过程中，大多时候，接收到的数据的顺序是正确的，但是并不是每次都是这样。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">最后，尽管<span>UDP</span>并没有比<span>“IP”</span>协议高级多少，而且不可靠。但是你发送的数据，要么全部到达，要么全部丢失。比如：你发送一个大小为<span>256 byte</span>的数据包给另外一台计算机，这台计算机不会只接收到<span>100 byte</span>的数据包，它只可能接收到<span>256 byte</span>的数据包，或者什么都没接收到。这是<span>UDP</span>唯一可以保证的事情，其它所有的事情都需要你来决定（我的理解，<span>UDP</span>协议只是个简单的传输协议，只保证数据包的完整性，注意是数据包而不是信息。其他的事情需要自己去做，完善这个协议，达到自己使用的需求。）</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$2 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-family: 微软雅黑, sans-serif;">TCP vs. UDP</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">我们如何选择是使用<span>TCP socket</span>还是<span>UDPsocket</span>呢？</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">我们先看看两者的特征吧：</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">TCP</span><span style="font-family: 微软雅黑, sans-serif;">：</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">面向连接</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">可靠、有序</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">自动把数据拆分成数据包</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">确保数据的发送一直在控制中（流量控制）</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">使用简单，就像读写文件一样</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">UDP</span><span style="font-family: 微软雅黑, sans-serif;">：</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">没有连接的概念，你需要自己通过代码实现（这个我也没自己实现过，应该还会讲）</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">不可靠，数据包无序，数据包可能无序，重复，或者丢失</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">你需要手动地把数据拆分成数据包，然后发送数据包</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">你需要自己做流量控制</span></p><p style="margin: 7.5pt 0cm 7.5pt 22.5pt; t : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">      </span></span><span style="font-family: 微软雅黑, sans-serif;">如果数据包太多，你需要设计重发和统计机制</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">通过上面的描述，不难发现：<span>TCP</span>做了所有我们想做的事情，而且使用十分简单。反观<span>UDP</span>就十分难用了，我们需要自己编写设计一切。很显然，我们只要用<span>TCP</span>就好了！</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">不，你想的简单了（原来，是我太年轻了！）</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">当你开发一个像上面说过的<span>FPS</span>（动作网游）的时候使用<span>TCP</span>协议，会是一个错误的决定，这个<span>TCP</span>协议就不好用了！为什么这么说？那么你就需要知道<span>TCP</span>到底做了什么，使得一起看起来十分简单。（让我们继续往下看，这是我最好奇的地方！！！有没有兴奋起来？）</span></p>$hhd$4 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">TCP</span><span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">内部的工作原理</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">TCP</span><span style="font-family: 微软雅黑, sans-serif;">和<span>UDP</span>都是建立在<span>“IP”</span>协议上的，但是它俩完全不同。<span>UDP</span>和<span>“IP”</span>协议很像，然而<span>TCP</span>隐藏了数据包的所有的复杂和不可靠的部分，抽象成了类似文件的对象。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">那么<span>TCP</span>是如何做到这一点呢？</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">首先，<span>TCP</span>是一个数据流的协议，所以你只需要把输入的内容变成数据流，然后<span>TCP</span>协议就会确保数据会到达发送的目的地。因为<span>“IP”</span>协议是通过数据包传递信息，<span>TCP</span>是建立在<span>“IP”</span>协议之上，所以<span>TCP</span>必须把用户输入的数据流分成数据包的形式。<span>TCP</span>协议会对需要发送的数据进行排队，然后当有足够的排除数据的时候，就发送数据包到目标计算机。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">当在多人在线的网络游戏中发送非常小的数据包的时候，这样做就有一个问题。这个时候会发生什么？如果数据没有达到缓冲区设定的数值，数据包是不会发送的。这就会出现个问题：因为客户端的用户输入请求后，需要尽快的从服务器得到响应，如果像上面<span>TCP </span>等待缓冲区满后才发送的话，就会出现延时，那么客户端的用户体验就会非常差！网络游戏几乎不能出现延时，我们希望看到的是<span>“</span>实时<span>”</span>和流畅。</span></p><p style="margin: 0cm 0cm 0.0001pt; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">TCP</span><span style="font-family: 微软雅黑, sans-serif;">有一个选项可以修复，上面说的那种等待缓冲区满才发送的情况，就是<strong><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">TCP_NODELAY</span></strong>。这个选项使得<span>TCP socket</span>不需要等待缓冲区满才发送，而是输入数据后就立即发送。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">然而，即使你已经设置了<span>TCP_NODELAY</span>选项，在多人网游中还是会有一系列的问题。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">这一切的源头都由于<span>TCP</span>处理丢包和乱序包的方式。使得你产生有序和可靠的<span>“</span>错觉<span>”</span>。</span></p>$hhd$4 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">TCP</span><span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">如何保证数据的可靠性</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">本质上<span>TCP</span>做的事情，分解数据流，成为数据包，使用在不可靠的<span>“IP”</span>协议，发送这些数据包。然后使得数据包到达目标计算机，然后重组成数据流。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">但是，如何处理当丢包？如何处理重复的数据包和乱序数据包？</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">这里不会介绍<span>TCP</span>处理这些事情的细节，因为这些都是非常复杂的（想弄清楚的同学可以看我上面推荐的书单），大体上：<span>TCP</span>发送一个数据包，等待一段时间，直到检测到数据包丢失了，因为没有接收到它的<span>ACK</span>（一种传输类控制符号，用于确认接收无误），接下来就重新发送丢失的数据包到目标计算机。重复的数据包将被丢弃在接收端，乱序的数据包将被重新排序。所以保证了数据包的可靠性和有序性。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">如果我们用<span>TCP</span>实现数据的实时传输，就会出现一个问题：<span>TCP</span>无论什么情况，只要数据包出错，就必须等待数据包的重发。也就是说，即使最新的数据已经到达，但还是不能访问这些数据包，新到的数据会被放在一个队列中，需要等待丢失的包重新发过来之后，所有数据没有丢失才可以访问。需要等待多长时间才能重新发送数据包？举个例子：如果的延时是<span>125ms</span>，那么需要最好的情况下重发数据包需要<span>250ms</span>，但是如果遇到糟糕的情况，将会等待<span>500ms</span>以上，比如：网络堵塞等情况。那就没救了。。。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$4 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">为什么<span>TCP</span>不应该用于对网络延时要求极高的条件下</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">如果<span>FPS</span>（第一人称射击）这类的网络游戏使用<span>TCP</span>就出现问题，但是<span>web</span>浏览器、邮箱、大多数应用就没问题，因为多人网络游戏有实时性的要求。比如：玩家输入角色的位置，重要的不是前一秒发生了什么，而是最新的情况！<span>TCP</span>并没有考虑这类需求，它并不是为这种需求而设计的。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">这里举一个简单的多人网游的例子，比如射击的游戏。对网络的要求很简单。玩家通过客户端发送给服务器的每个场景（用鼠标和键盘输入的行走的位置），服务器处理每个用户发送过来的所有场景，处理完再返回给客户端，客户端解析响应，渲染最新的场景展示给玩家。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">在上面说的哪个多人游戏的例子中，如果出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据，所以玩家操作的任务就会出现站着不动的情况（卡！卡！卡！），不能射击也不能移动。当重发的数据包到达后，你接收到这个过时的数据包，然而玩家并不关心过期的数据（激战中，卡了<span>1</span>秒，等能动了，都已经死了）</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">不幸的是，没有办法修复<span>TCP</span>的这个问题，这是它本质的东西，没办法修复。这就是<span>TCP</span>如何做到让不可靠，无序的数据包，看起来像有序，可靠的数据流。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">我并不需要可靠，有序的数据流，我们希望的是客户端和服务端之间的延时越低越好，不需要等待重发丢失的包。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">所以，这就是为什么在对数据的实时性要求的下，我们不用<span>TCP</span>。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$4 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">那为什么不<span>UDP</span>和<span>TCP</span>一起用呢？</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">像玩家输入实时游戏数据和状态的变更，只和最新的数据有关（这些数据强调实时性）。但是另外的一些数据，例如，从一台计算机发送给另外一个台计算机的一些列指令（交易请求，聊天？），可靠、有序的传输还是非常重要的！</span></p><p style="margin: 0cm 0cm 0.0001pt; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">那么，用户输入和状态用<span>UDP</span>，<span>TCP</span>用于可靠、有序的数据传输，看起来是个不错的点子。但是，问题在于<span>TCP</span>和<span>UDP</span>都是建立<span>“IP”</span>协议之上，所以协议之间都是发送数据包，从而相互通信。协议之间的互相影响是相当复杂的，涉及到<span>TCP</span>性能、可靠性和流量控制。简而言之，<span>TCP</span>会导致<span>UDP</span>丢包，请参考</span><span><a rel="noopener" href="http://www.isoc.org/INET97/proceedings/F3/F3_1.HTM" target="_blank"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black"><span>这篇论文</span></span></a></span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">此外，<span>UDP</span>和<span>TCP</span>混合使用是非常复杂的，而且实现起来是非常痛苦的。（这段我就不翻译了，总而言之：不要混用<span>UDP</span>和<span>TCP</span>，容易失去对传输数据的控制）</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$2 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size: 24pt; font-family: 微软雅黑, sans-serif;">总结</span><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">我的建议并不是就一定要使用<span>UDP</span>，但是<span>UDP</span>协议应该用于游戏。请不要混合使用<span>TCP</span>和<span>UDP</span>，你应该学习<span>TCP</span>中一些地方是如何实现的技巧，然后可以把这些技巧用在<span>UDP</span>上，从而实现适合你的需求的协议（借鉴<span>TCP</span>中的实现，在<span>UDP</span>上，完善功能，从而达到你的需求）。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;">这个系列，接下来会讲到：如何在<span>UDP</span>上创建一个虚拟的连接（因为<span>UDP</span>本身，是没有连接的概念的）、如何使得<span>UDP</span>实现可靠性，流量控制，非阻塞。</span></p><p style="margin: 7.5pt 0cm; line-height: 16.2pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family: 微软雅黑, sans-serif;"> </span></p>$hhd$2 style=”margin: 11.25pt 0cm 1.5pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;”&gt;<span style="font-size: 24pt; font-family: 微软雅黑, sans-serif;">参考</span><p class="MsoNormal" align="left" style="margin-l : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">         </span></span><span><a rel="noopener" href="http://wiki.mbalib.com/wiki/%C3%A6%E2%80%A2%C2%B0%C3%A6%C2%8D%C2%AE%C3%A6%C2%B5%C2%81" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black">MBA lib</span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black"><span>数据流</span></span></a></span></p><p class="MsoNormal" align="left" style="margin-l : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">         </span></span><span><a rel="noopener" href="https://zh.wikipedia.org/wiki/TCP/IP%C3%A5%C2%8D%C2%8F%C3%A8%C2%AE%C2%AE%C3%A6%E2%80%94%C2%8F" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black">WiKi TCP/IP</span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black"><span>协议族</span></span></a></span></p><p class="MsoNormal" align="left" style="margin-l : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">         </span></span><span><a rel="noopener" href="http://www.w3school.com.cn/tcpip/tcpip_protocols.asp" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black">W3SchoolTCP/IP </span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black"><span>协议</span></span></a></span></p><p class="MsoNormal" align="left" style="margin-l : initial; background-repeat: initial;"><span style="font-size: 10pt; font-family: Symbol;">·<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">         </span></span><span><a rel="noopener" href="http://liangjiabin.com/blog/2015/03/difference-between-tcp-vs-udp-protocol.html" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black">UDP</span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black"><span>和TCP</span></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:black"><span>的区</span></span></a></span></p><p class="MsoNormal"><span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"> </span></p><p class="MsoNormal"><span style="font-size:16.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></p></div></div>                    </div><br>                

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2016/11/01/快速编译技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/01/快速编译技巧/" itemprop="url">快速编译技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-01T22:57:29+00:00">
                2016-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <blockquote>
<p>项目越来越大，每次需要重新编译整个项目都是一件很浪费时间的事情。Research了一下，找到以下可以帮助提高速度的方法，总结一下。</p>
</blockquote>
<h1 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h1><blockquote>
<p>有人说在Windows下用了RAMDisk把一个项目编译时间从4.</p>
</blockquote>
<p>5小时减少到了5分钟，也许这个数字是有点夸张了，不过粗想想，把文件放到内存上做编译应该是比在磁盘</p>
<p>上快多了吧，尤其如果编译器需要生成很多临时文件的话。</p>
<p>这个做法的实现成本最低，在Linux中，直接mount一个tmpfs就可以了。而且对所编译的工程没有任何要求，也不用改动编译环境。</p>
<p>mount -t tmpfs tmpfs ~/build -o size=1G</p>
<p>用2.6.32.2的Linux Kernel来测试一下编译速度：</p>
<ul>
<li><p>用物理磁盘：40分16秒</p>
</li>
<li><p>用tmpfs：39分56秒</p>
</li>
</ul>
<p>呃……没什么变化。看来编译慢很大程度上瓶颈并不在IO上面。但对于一个实际项目来说，</p>
<p>编译过程中可能还会有打包等IO密集的操作，所以只要可能，用tmpfs是有</p>
<p>益无害的。</p>
<blockquote>
<p>当然对于大项目来说，你需要有足够的内存才能负担得起这个tmpfs的开销。</p>
</blockquote>
<h1 id="make-j"><a href="#make-j" class="headerlink" title="make -j"></a>make -j</h1><blockquote>
<p>既然IO不是瓶颈，那CPU就应该是一个影响编译速度的重要因素了。</p>
</blockquote>
<p>用make -j带一个参数，可以把项目在进行并行编译，比如在一台双核的机器上，完全可以用make -<br>j4，让make最多允许4个编译命令同时执行，这样可以更有效的利用CPU资源。</p>
<p>还是用Kernel来测试：</p>
<ul>
<li><p>用make： 40分16秒</p>
</li>
<li><p>用make -j4：23分16秒</p>
</li>
<li><p>用make -j8：22分59秒</p>
</li>
</ul>
<p>由此看来，在多核CPU上，适当的进行并行编译还是可以明显提高编译速度的。但并行的任务不宜太多，一般是以CPU的核心数目的两倍为宜。</p>
<p>不过这个方案不是完全没有cost的，如果项目的Makefile不规范，没有正确的设置好依赖关系，并行编译的结果就是编译不能正常进行。如果依赖关系设置过于保守<br>，则可能本身编译的可并行度就下降了，也不能取得最佳的效果。</p>
<h1 id="ccache"><a href="#ccache" class="headerlink" title="ccache"></a>ccache</h1><blockquote>
<p>ccache用于把编译的中间结果进行缓存，以便在再次编译的时候可以节省时间。这对于玩Kernel来说实在是再好不过了，因为经常需要修改一些Kernel的代码，然后<br>再重新编译，而这两次编译大部分东西可能都没有发生变化。对于平时开发项目来说，也是一样。为什么不是直接用make所支持的增量编译呢？还是因为现实中，因<br>为Makefile的不规范，很可能这种“聪明”的方案根本不能正常工作，只有每次make clean再make才行。</p>
</blockquote>
<p>安装完ccache后，可以在/usr/local/bin下建立gcc，g++，c++，cc的symbolic<br>link，链到/usr/bin/ccache上。总之确认系统在调用gcc等命令时会调用到ccache就可以了（通常情况下/usr/local/bin会在PATH中排在/usr/bin前面）。</p>
<p>继续测试：</p>
<ul>
<li><p>用ccache的第一次编译(make -j4)：23分38秒</p>
</li>
<li><p>用ccache的第二次编译(make -j4)：8分48秒</p>
</li>
<li><p>用ccache的第三次编译(修改若干配置，make -j4)：23分48秒</p>
</li>
</ul>
<p>看来修改配置（我改了CPU类型…）对ccache的影响是很大的，因为基本头文件发生变化后，就导致所有缓存数据都无效了，必须重头来做。但如果只是修改一些.<br>c文件的代码，ccache的效果还是相当明显的。而且使用ccache对项目没有特别的依赖，布署成本很低，这在日常工作中很实用。</p>
<p>可以用ccache -s来查看cache的使用和命中情况：</p>
<p>cache directory                   /home/lifanxi/.ccache</p>
<p>cache hit                           7165</p>
<p>cache miss                         14283</p>
<p>called for link                       71</p>
<p>not a C/C++ file                     120</p>
<p>no input file                       3045</p>
<p>files in cache                     28566</p>
<p>cache size                          81.7 Mbytes</p>
<p>max cache size                     976.6 Mbytes</p>
<p>可以看到，显然只有第二编次译时cache命中了，cache miss是第一次和第三次编译带来的。两次cache占用了81.7M的磁盘，还是完全可以接受的。</p>
<h1 id="distcc"><a href="#distcc" class="headerlink" title="distcc"></a>distcc</h1><blockquote>
<p>一台机器的能力有限，可以联合多台电脑一起来编译。这在公司的日常开发中也是可行的，因为可能每个开发人员都有自己的开发编译环境，它们的编译器版本一般<br>是一致的，公司的网络也通常具有较好的性能。这时就是distcc大显身手的时候了。</p>
</blockquote>
<p>使用distcc，并不像想象中那样要求每台电脑都具有完全一致的环境，它只要求源代码可以用make -j并行编译，并且参与分布式编译的电脑系统中具有相同的编译<br>器。因为它的原理只是把预处理好的源文件分发到多台计算机上，预处理、编译后的目标文件的链接和其它除编译以外的工作仍然是在发起编译的主控电脑上完成，<br>所以只要求发起编译的那台机器具备一套完整的编译环境就可以了。</p>
<p>distcc安装后，可以启动一下它的服务：</p>
<p>/usr/bin/distccd  –daemon –allow 10.64.0.0/16</p>
<p>默认的3632端口允许来自同一个网络的distcc连接。</p>
<p>然后设置一下DISTCC_HOSTS环境变量，设置可以参与编译的机器列表。</p>
<blockquote>
<p>通常localhost也参与编译，但如果可以参与编译的机器很多，则可以把localhost从这个列表</p>
<p>中去掉，这样本机就完全只是进行预处理、分发和链接了，编译都在别的机器上完成。</p>
</blockquote>
<p>因为机器很多时，localhost的处理负担很重，所以它就不再“兼职”编译了。</p>
<p>export DISTCC_HOSTS=&quot;localhost 10.64.25.1 10.64.25.2 10.64.25.3&quot;</p>
<p>然后与ccache类似把g++，gcc等常用的命令链接到/usr/bin/distcc上就可以了。</p>
<p>在make的时候，也必须用-j参数，一般是参数可以用所有参用编译的计算机CPU内核总数的两倍做为并行的任务数。</p>
<p>同样测试一下：</p>
<ul>
<li><p>一台双核计算机，make -j4：23分16秒</p>
</li>
<li><p>两台双核计算机，make -j4：16分40秒</p>
</li>
<li><p>两台双核计算机，make -j8：15分49秒</p>
</li>
</ul>
<p>跟最开始用一台双核时的23分钟相比，还是快了不少的。如果有更多的计算机加入，也可以得到更好的效果。</p>
<p>在编译过程中可以用distccmon-text来查看编译任务的分配情况。distcc也可以与ccache同时使用，通过设置一个环境变量就可以做到，非常方便。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><ul>
<li><p>tmpfs： 解决IO瓶颈，充分利用本机内存资源</p>
</li>
<li><p>make -j： 充分利用本机计算资源</p>
</li>
<li><p>distcc： 利用多台计算机资源</p>
</li>
<li><p>ccache： 减少重复编译相同代码的时间</p>
</li>
</ul>
<blockquote>
<p>这些工具的好处都在于布署的成本相对较低，综合利用这些工具，就可以轻轻松松的节省相当可观的时间。</p>
</blockquote>
<p>上面介绍的都是这些工具最基本的用法，更多的用法可以参考它们各自的man page。</p>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2016/09/13/XXTEA的python实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/13/XXTEA的python实现/" itemprop="url">XXTEA的python实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-13T02:04:00+00:00">
                2016-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Script/" itemprop="url" rel="index">
                    <span itemprop="name">Script</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <p>在数据的加解密领域，算法分为对称密钥与非对称密钥两种。</p>
<p>对称密钥与非对称密钥由于各自的特点，所应用的领域是不尽相同的。</p>
<p>对称密钥加密算法由于其速度快，一般用于整体数据的加密，而非对称密钥加密算法的安全性能佳，在数字签名领域得到广泛的应用。</p>
<p>微型加密算法（TEA）及其相关变种（XTEA，Block TEA，XXTEA） 都是分组加密算法，它们很容易被描述，实现也很简单（典型的几行代码）。</p>
<p>TEA是Tiny Encryption Algorithm的缩写，以加密解密速度快，实现简单著称。</p>
<p>TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的。</p>
<p>该算法使用 128 位的密钥为 64 位的信息块进行加密，它需要进行 64 轮迭代，尽管作者认为 32 轮已经足够了。</p>
<p>该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。</p>
<p>但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 0×9E3779B9）。</p>
<p>之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本——XTEA（有时也被称为“tean”）。</p>
<p>XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了。</p>
<p>在跟描述 XTEA 算法的同一份报告中，还介绍了另外一种被称为 Block TEA 算法的变种，它可以对 32 位大小任意倍数的变量块进行操作。</p>
<p>该算法将 XTEA 轮循函数依次应用于块中的每个字，并且将它附加于它的邻字。</p>
<p>该操作重复多少轮依赖于块的大小，但至少需要 6 轮。</p>
<p>该方法的优势在于它无需操作模式（CBC，OFB，CFB 等），密钥可直接用于信息。</p>
<p>对于长的信息它可能比 XTEA 更有效率。</p>
<p>在 1998 年，Markku-Juhani Saarinen 给出了一个可有效攻击 Block TEA 算法的代码，但之后很快 David J. Wheeler 和 Roger M. Needham 就给出了 Block TEA 算法的修订版，这个算法被称为 XXTEA。</p>
<p>XXTEA 使用跟 Block TEA 相似的结构，但在处理块中每个字时利用了相邻字。</p>
<p>它利用一个更复杂的 MX 函数代替了 XTEA 轮循函数，MX 使用 2 个输入量。</p>
<p>XXTEA 算法很安全，而且非常快速，非常适合应用于 Web 开发中。</p>
<img src="/2016/09/13/XXTEA的python实现/py_xxtea1.png">
<p>TEA算法是由剑桥大学计算机实验室的David Wheeler和Roger Needham于1994年发明，</p>
<p>TEA是Tiny Encryption Algorithm的缩写，以加密解密速度快，实现简单著称。</p>
<p>TEA算法每一次可以操作64bit(8byte)，采用128bit(16byte)作为key，算法采用迭代的形式，推荐的迭代轮数是64轮，最少32轮。</p>
<p>为解决TEA算法密钥表攻击的问题，TEA算法先后经历了几次改进，从XTEA到BLOCK TEA，直至最新的XXTEA。</p>
<p>XTEA也称做TEAN，它使用与TEA相同的简单运算，但四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。</p>
<p>Block TEA算法可以对32位的任意整数倍长度的变量块进行加解密的操作，该算法将XTEA轮循函数依次应用于块中的每个字，并且将它附加于被应用字的邻字。</p>
<p>XXTEA使用跟Block TEA相似的结构，但在处理块中每个字时利用了相邻字，且用拥有两个输入量的MX函数代替了XTEA轮循函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line">  </span><br><span class="line">_DELTA = <span class="number">0x9E3779B9</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_long2str</span><span class="params">(v, w)</span>:</span>  </span><br><span class="line">    n = (len(v) - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>  </span><br><span class="line">    <span class="keyword">if</span> w:  </span><br><span class="line">        m = v[<span class="number">-1</span>]  </span><br><span class="line">        <span class="keyword">if</span> (m &lt; n - <span class="number">3</span>) <span class="keyword">or</span> (m &gt; n): <span class="keyword">return</span> <span class="string">''</span>  </span><br><span class="line">        n = m  </span><br><span class="line">    s = struct.pack(<span class="string">'&lt;%iL'</span> % len(v), *v)  </span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>:n] <span class="keyword">if</span> w <span class="keyword">else</span> s  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_str2long</span><span class="params">(s, w)</span>:</span>  </span><br><span class="line">    n = len(s)  </span><br><span class="line">    m = (<span class="number">4</span> - (n &amp; <span class="number">3</span>) &amp; <span class="number">3</span>) + n  </span><br><span class="line">    s = s.ljust(m, <span class="string">"\0"</span>)  </span><br><span class="line">    v = list(struct.unpack(<span class="string">'&lt;%iL'</span> % (m &gt;&gt; <span class="number">2</span>), s))  </span><br><span class="line">    <span class="keyword">if</span> w: v.append(n)  </span><br><span class="line">    <span class="keyword">return</span> v  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(str, key)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">''</span>: <span class="keyword">return</span> str  </span><br><span class="line">    v = _str2long(str, <span class="keyword">True</span>)  </span><br><span class="line">    k = _str2long(key.ljust(<span class="number">16</span>, <span class="string">"\0"</span>), <span class="keyword">False</span>)  </span><br><span class="line">    n = len(v) - <span class="number">1</span>  </span><br><span class="line">    z = v[n]  </span><br><span class="line">    y = v[<span class="number">0</span>]  </span><br><span class="line">    sum = <span class="number">0</span>  </span><br><span class="line">    q = <span class="number">6</span> + <span class="number">52</span> // (n + <span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">while</span> q &gt; <span class="number">0</span>:  </span><br><span class="line">        sum = (sum + _DELTA) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">        e = sum &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>  </span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> xrange(n):  </span><br><span class="line">            y = v[p + <span class="number">1</span>]  </span><br><span class="line">            v[p] = (v[p] + ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (sum ^ y) + (k[p &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">            z = v[p]  </span><br><span class="line">        y = v[<span class="number">0</span>]  </span><br><span class="line">        v[n] = (v[n] + ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (sum ^ y) + (k[n &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">        z = v[n]  </span><br><span class="line">        q -= <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> _long2str(v, <span class="keyword">False</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(str, key)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">''</span>: <span class="keyword">return</span> str  </span><br><span class="line">    v = _str2long(str, <span class="keyword">False</span>)  </span><br><span class="line">    k = _str2long(key.ljust(<span class="number">16</span>, <span class="string">"\0"</span>), <span class="keyword">False</span>)  </span><br><span class="line">    n = len(v) - <span class="number">1</span>  </span><br><span class="line">    z = v[n]  </span><br><span class="line">    y = v[<span class="number">0</span>]  </span><br><span class="line">    q = <span class="number">6</span> + <span class="number">52</span> // (n + <span class="number">1</span>)  </span><br><span class="line">    sum = (q * _DELTA) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="keyword">while</span> (sum != <span class="number">0</span>):  </span><br><span class="line">        e = sum &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>  </span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> xrange(n, <span class="number">0</span>, <span class="number">-1</span>):  </span><br><span class="line">            z = v[p - <span class="number">1</span>]  </span><br><span class="line">            v[p] = (v[p] - ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (sum ^ y) + (k[p &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">            y = v[p]  </span><br><span class="line">        z = v[n]  </span><br><span class="line">        v[<span class="number">0</span>] = (v[<span class="number">0</span>] - ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (sum ^ y) + (k[<span class="number">0</span> &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">        y = v[<span class="number">0</span>]  </span><br><span class="line">        sum = (sum - _DELTA) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="keyword">return</span> _long2str(v, <span class="keyword">True</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">    <span class="keyword">print</span> decrypt(encrypt(<span class="string">'Hello XXTEA!'</span>, <span class="string">'16bytelongstring'</span>), <span class="string">'16bytelongstring'</span>)</span><br></pre></td></tr></table></figure>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/43/">43</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="no5ix">
          </a>
          <p class="site-author-name" itemprop="name">no5ix</p>
           
              <p class="site-description motion-element" itemprop="description">推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">215</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">关于</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
          
          <!-- 网易云音乐 -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- 网易云音乐 -->

        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://119.23.17.57" title="ksun的博客" target="_blank">ksun的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzU3MTUyNzg0NQ==&hid=1&sn=7a3ae61b7af714f75d68e7ae826a2d2c&scene=18#wechat_redirect" title="你有图么我有故事" target="_blank">你有图么我有故事</a>
                </li>
              
            </ul>
          </div>
        

        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">no5ix</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/dist/jquery.fancybox.js?v=3.2.10"></script>


  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">

    var is_load_xml_finished = 0;

    var searchFunc = function (path, search_id, content_id) {
      // 0x00. environment initialization
      'use strict';

      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      // var datas = [];

      /* loading css1 : Dot Css Loader*/
      var DotLoader = "<div class='loader'>Loading...</div>";

      /* loading css2 : Pure Css Loader - Square */
      var SquareLoader = 
        "<div class='loader'>" +
          "<div class='square' ></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square '></div>" +
          "<div class='square last'></div>" +
        "</div>";

      var ProgressBar = 
          "<div class='progress-bar'>" +
            "<div class='progress-bar-charge'></div>" +
          "</div>";

      var str = "";
      var keywords = [];
      var temp_keyword = "";

      // 是否为第一个字母被键入的标志位
      var first_char_flag = 0;

      // 因为在移动设备上, 点击搜索之后会 scroll 到页面顶部, 所以需要记录之前的页面x, y坐标值, 以便于搜索完点击 close 按钮之后 scroll 回原来的页面坐标值.
      var last_page_x = 0;
      var last_page_y = 0;

      var local_search_tips = 
            "<span class='local-search-empty'>" + "第一次搜索可能较慢, 先思考一个经典算法问题, 跳台阶:" + "</span>" +
            "<span class='local-search-empty'>" + "一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个6级的台阶总共有多少种跳法?n级呢?" + "</span>";

      function CloseLocalSearch()
      {
        first_char_flag = 0;

        $('#local-search-input').val('');
        $('#local-search-close').hide();

        // $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownOut', 200);

        $('#' + content_id).attr("headroom_special_attr","true"); 
        
        if (isMobile())
        {
          // $('body').scrollTop(last_page_y);  // scrollTop 有兼容性问题
          scrollTo(last_page_x, last_page_y);

          $('#' + content_id).hide();
        }
        else
        {
          $('#' + content_id).velocity('stop').velocity( 'transition.bounceUpOut', 200 );
        }

        // $('#' + content_id).velocity('stop').velocity( isMobile() ? 'transition.fadeOut' : 'transition.bounceUpOut', {
        //   // delay: isMobile() ? 50 : 0,
        //   duration: isMobile() ? 500 : 200,
        //   // begin: function() { 
        //   //   if (isMobile())
        //   //   {
        //   //     $('body').scrollTop(last_page_y);
        //   //   } 
        //   // }
        //   complete: function () {
        //     if (isMobile())
        //     {
        //       if (last_page_y < 20000)
        //       {
        //         $('body').velocity('scroll', { offset: last_page_y+"px", duration: last_page_y < 10000 ? 1000 : 2000 });
        //       }
        //       else
        //       {
        //         $('body').scrollTop(last_page_y);
        //       }
        //       // $('body').velocity('scroll');

        //       // $('html,body').animate({
        //       //   scrollTop: last_page_y
        //       // },400);
        //       // $('body').velocity('transition.slideDownIn', 1000);
        //       // $('body').velocity('scroll', { offset: last_page_y+"px", duration: document.body.scrollHeight < 20000 ? 1500 : 3000 });
        //     }
        //   }
        // });
      }

      function handleSearch()
      {
        if (keywords.length <= 0) {
          return;
        }
        $resultContent.innerHTML = "";
        $('#local-search-close').show();

        // 0x04. perform local searching
        if (is_load_xml_finished == 0)
        {
          $resultContent.innerHTML = 
            "<ul class='local-search-empty-ul'>" + 
            local_search_tips +
            ProgressBar;
        }
        else
        {
          // Retrieve the object from local storage
          var xml_resp = retrieve_search_xml()

          xml_resp.forEach(function (data) {
          // datas.forEach(function (data) {
            var isMatch = true;
            var content_index = [];
            if (!data.title || data.title.trim() === '') {
              data.title = "Untitled";
            }
            var is_encrypted = data.encrypted.trim() == '1'
            var is_sensitive = CONFIG.local_search.sensitive_word && data_content.indexOf(CONFIG.local_search.sensitive_word) >= 0
            var orig_data_title = data.title.trim();
            var data_title = orig_data_title.toLowerCase();
            var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
            var data_content = orig_data_content.toLowerCase();
            var data_url = decodeURIComponent(data.url);
            var index_title = -1;
            var index_content = -1;
            var first_occur = -1;
            // only match artiles with not empty contents
            if (data_content !== '') {
              keywords.forEach(function (keyword, i) {
                index_title = data_title.indexOf(keyword);
                index_content = (is_sensitive || is_encrypted) ? -1 : data_content.indexOf(keyword);

                if (index_title < 0 && index_content < 0) {
                  isMatch = false;
                } else {
                  if (index_content < 0) {
                    index_content = 0;
                  }
                  if (i == 0) {
                    first_occur = index_content;
                  }
                  // content_index.push({index_content:index_content, keyword_len:keyword_len});
                }
              });
            } else {
              isMatch = false;
            }
            // 0x05. show search results
            if (isMatch) {
              var content = orig_data_content;
              if (first_occur >= 0) {
                var match_content = "";
                if (!is_sensitive && !is_encrypted)
                {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  match_content = content.substr(start, end);
                }

                // highlight all keywords
                var regS = "";
                if (match_content != "")
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                else
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                str += "<li><a href='" + data_url + "' class='search-result-title' target='_blank'>" + orig_data_title + "</a>";
                str += "<p class=\"search-result\">" + match_content + "...</p>"
              }
              str += "</li>";
            }
          });

          str += "</ul>";
          if (str.indexOf('<li>') === -1) {
            return $resultContent.innerHTML = 
              "<ul class='local-search-empty-ul'><span class='local-search-empty'>找不到, 换个搜索关键字试一哈.<span></ul>";
          }
          $resultContent.innerHTML = str;
        }
      }

      $input.addEventListener('input', function () {
        // 0x03. parse query to keywords list
        str = '<ul class=\"search-result-list\">';
        temp_keyword = this.value.trim();
        if (temp_keyword.length <= 0) {
          CloseLocalSearch();
          return;
        }

        keywords = temp_keyword.toLowerCase().split(/[\s\-]+/);
        handleSearch();

        // 当用户键入第一个字母的时候的动画处理逻辑 : 
        // 当 first_char_flag 为 0 的时候, 
        // 要播放一个动画
        if (first_char_flag == 0)
        {
            // $('body').scrollTop(0);
          if (isMobile())
          {
            last_page_x = window.pageXOffset;
            last_page_y = window.pageYOffset;
            // $('body').scrollTop(0);
            scrollTo(0,0);

          }
          first_char_flag = 1;
          $('#' + content_id).removeAttr("headroom_special_attr");
          
          $('#' + content_id).velocity('stop').velocity('transition.slideDownIn', 300);

          $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 1000);
        }
      });


      var local_search_xml_data = localStorage.getItem('local_search_xml_data');
      if (!local_search_xml_data) {
        $.ajax({
          // 0x01. load xml file
          url: path,
          dataType: "xml",
          success: function (xmlResponse) {
            store_search_xml(xmlResponse);

            // setTimeout(function(){
            //   is_load_xml_finished = 1;

            //   handleSearch();
            //   $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
            // }, 2000);
            
            // is_load_xml_finished = 1;

            handleSearch();
            $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
          }
        });
      }

      $(document).on('click', '#local-search-close', function() {
        CloseLocalSearch();
      });

      $(document).keyup(function(event){
        switch(event.keyCode) {
          case 27:
            // alert("ESC");
            CloseLocalSearch();
        }
      });

      // $(document).on('blur', '#local-search-input', function(e) {
      //   // console.log(document.activeElement.getAttribute('class'));
        
      //   if (isMobile() == false)
      //   {
      //     CloseLocalSearch();
      //   }
      // });
    }

    function isMobile() {
      // console.log(document.body.clientWidth);
      return document.body.clientWidth < 768

      // var userAgent = window.navigator.userAgent;

      // var isiPad = userAgent.match(/iPad/i) !== null;
      // var mobileUA = [
      //   'iphone', 'android', 'phone', 'mobile',
      //   'wap', 'netfront', 'x11', 'java', 'opera mobi',
      //   'opera mini', 'ucweb', 'windows ce', 'symbian',
      //   'symbianos', 'series', 'webos', 'sony',
      //   'blackberry', 'dopod', 'nokia', 'samsung',
      //   'palmsource', 'xda', 'pieplus', 'meizu',
      //   'midp' ,'cldc' , 'motorola', 'foma',
      //   'docomo', 'up.browser', 'up.link', 'blazer',
      //   'helio', 'hosin', 'huawei', 'novarra',
      //   'coolpad', 'webos', 'techfaith', 'palmsource',
      //   'alcatel', 'amoi', 'ktouch', 'nexian',
      //   'ericsson', 'philips', 'sagem', 'wellcom',
      //   'bunjalloo', 'maui', 'smartphone', 'iemobile',
      //   'spice', 'bird', 'zte-', 'longcos',
      //   'pantech', 'gionee', 'portalmmm', 'jig browser',
      //   'hiptop', 'benq', 'haier', '^lct',
      //   '320x320', '240x320', '176x220'
      // ];
      // var pattern = new RegExp(mobileUA.join('|'), 'i');

      // return !isiPad && userAgent.match(pattern);
    }

    function store_search_xml(xmlResponse) {
        datas = $("entry", xmlResponse).map(function () {
          return {
            title: $("title", this).text(),
            content: $("content", this).text(),
            url: $("url", this).text(),
            encrypted: $("encrypted", this).text(),
          };
        }).get();
        // Put the object into storage
        localStorage.setItem('local_search_xml_data', JSON.stringify(datas));
        is_load_xml_finished = 1;

        console.log("store search.xml finished.");
    }

    function ajax_store_search_xml() {
      $.ajax({
        url: "/search.xml",
        dataType: "xml",
        success: function (xmlResponse) {
            store_search_xml(xmlResponse);
        }
      });
    }

    function retrieve_search_xml() {
        // Retrieve the object from local storage
        var retrievedObject = localStorage.getItem('local_search_xml_data');
        var xml_resp = JSON.parse(retrievedObject)
        return xml_resp
    }

    var getSearchFile = function(){
      var path = "/search.xml";
      var local_search_result_name = isMobile() ? "local-search-result-mobile" : "local-search-result-pc";
      searchFunc(path, 'local-search-input', local_search_result_name);
    }

    var local_search_xml_data = localStorage.getItem('local_search_xml_data');
    if (local_search_xml_data) {
      is_load_xml_finished = 1;
      console.log("load search.xml finished.");
    }
    var last_use_local_search_date = localStorage.getItem('last_use_local_search_date');
    var curDate = new Date();
    // 只有在 localStorage 没有 search.xml数据或者 距离上次使用local search已经超过一天了才去取search.xml
    // 节省流量
    if (last_use_local_search_date != curDate.getDate() || !local_search_xml_data) {
      // preload search.xml
      ajax_store_search_xml();
    }

    localStorage.setItem('last_use_local_search_date', curDate.getDate());
    

  </script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>


<!-- 页面点击小红心 -->





<script type="text/javascript" src="/js/src/headroom.js"></script> 

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
