<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
          // alert('此文章并不公开, 输入文章密码方可阅读');
          var password = prompt('此文章并不公开, 输入文章密码方可阅读');
          if (password !== ''){
            if (password != null) // 如果用户点击了确认而且密码错误的时候, 因为当password == null的时候说明用户点了取消
            {
              alert('Error!');
            }
            if (history.length > 1)
            {
              history.back();
            }
            else
            {
              window.location.href = "about:blank";
            }
          }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/dist/jquery.fancybox.css?v=3.2.10" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">
<meta property="og:type" content="website">
<meta property="og:title" content="烫">
<meta property="og:url" content="https://hulinhong.com/page/18/index.html">
<meta property="og:site_name" content="烫">
<meta property="og:description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="烫">
<meta name="twitter:description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":222,"transition":{"header":"slideDownIn","menu":"slideDownIn","logo":"slideDownIn","post_block_else":"slideDownIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"slideDownIn","footer":"slideDownIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>烫 - 烫烫烫烫烫</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">烫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">烫烫烫烫烫</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <form class="site-search-form">
    <span class="search-icon fa fa-search"></span>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">×</i>
  </form>


<script type="text/javascript" id="local.search.active">
var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/03/11/kbe_ue4_demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/11/kbe_ue4_demo/" itemprop="url">KBE的UE4的demo大体解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T11:41:58+00:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UE4/" itemprop="url" rel="index">
                    <span itemprop="name">UE4</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <p>写到一半发现论坛的热门帖子里官方写了个u3d的demo源码解析,  内容几乎重复, u3d跟ue4的demo框架流程几乎都是差不多的, 直接给出官方帖子的链接好了, 尴尬:<br><a href="http://bbs.kbengine.org/forum.php?mod=viewthread&amp;tid=166" target="_blank" rel="noopener">http://bbs.kbengine.org/forum.php?mod=viewthread&amp;tid=166</a></p>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/02/28/sending_large_blocks_of_data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/sending_large_blocks_of_data/" itemprop="url">构建游戏网络协议四之发送大块数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T15:13:35+00:00">
                2017-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="本篇自我总结"><a href="#本篇自我总结" class="headerlink" title="本篇自我总结"></a>本篇自我总结</h1><p>有了本系列上篇文章中的分包和重组系统为何还要这个发送大块数据系统?是否是多余的?是雷同的吗?<br>请看总结概要理清思路, 再细看文章.</p>
<h2 id="为什么需要做这个发送大块数据系统"><a href="#为什么需要做这个发送大块数据系统" class="headerlink" title="为什么需要做这个发送大块数据系统"></a>为什么需要做这个发送大块数据系统</h2><p>第一眼看上去，这种替代性的技术似乎非常类似于数据包的分包和重组，但是它的实现是完全不同的。这种实现上的差异的目的是为了解决数据包分包和重组的一个关键弱点 : 一个片段的丢失就会导致整个数据包都要被丢弃掉然后重新分包重发。</p>
<p>你可能需要这样做的一些常见的例子包括：客户端在首次加入的时候，服务器需要下发一个大的数据块给客户端(可能是世界的初始状态)、一开始用来做增量编码的基线或者是在一个多人在线网络游戏里面客户端在加载界面所等待的大块数据。</p>
<p>在这些情况下非常重要的是不仅要优雅地处理数据包的丢失，还要尽可能的利用可用的带宽并尽可能快的发送大块数据。</p>
<p>这个发送大块数据系统大致可以理解为是一个在原来分包和重组系统的基础上增加了分包确认功能, 也就是说增加了可靠性的部分.</p>
<h2 id="本篇基本术语"><a href="#本篇基本术语" class="headerlink" title="本篇基本术语"></a>本篇基本术语</h2><p>In this new system blocks of data are called chunks. Chunks are split up into slices. This name change keeps the chunk system terminology (chunks/slices) distinct from packet fragmentation and reassembly (packets/fragments).</p>
<ul>
<li>块 : 在这个新系统中，大块的数据被称为”块”(chunks)</li>
<li>片段 : 而块被分成的分包被称为”片段”(slices)</li>
</ul>
<h2 id="数据包的结构设计"><a href="#数据包的结构设计" class="headerlink" title="数据包的结构设计"></a>数据包的结构设计</h2><p>这个系统在网络上发送的数据包类型一共有两种类型：</p>
<ul>
<li><p>Slice packet片段数据包 : 这包括了一个块的片段，最多大小为1k。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SliceSize = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSlicesPerChunk = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxChunkSize = SliceSize  MaxSlicesPerChunk;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SlicePacket</span> :</span> <span class="keyword">public</span> protocol2::Packet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunkId;</span><br><span class="line">    <span class="keyword">int</span> sliceId;</span><br><span class="line">    <span class="keyword">int</span> numSlices;</span><br><span class="line">    <span class="keyword">int</span> sliceBytes;</span><br><span class="line">    <span class="keyword">uint8_t</span> data[SliceSize];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> stream&gt; <span class="function"><span class="keyword">bool</span> <span class="title">Serialize</span><span class="params">( Stream &amp; stream )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        serialize_bits( stream, chunkId, <span class="number">16</span> );</span><br><span class="line">        serialize_int( stream, sliceId, <span class="number">0</span>, MaxSlicesPerChunk - <span class="number">1</span> );</span><br><span class="line">        serialize_int( stream, numSlices, <span class="number">1</span>, MaxSlicesPerChunk );</span><br><span class="line">        <span class="keyword">if</span> ( sliceId == numSlices - <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            serialize_int( stream, sliceBytes, <span class="number">1</span>, SliceSize );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( Stream::IsReading )</span><br><span class="line">        &#123;</span><br><span class="line">            sliceBytes = SliceSize;</span><br><span class="line">        &#125;</span><br><span class="line">        serialize_bytes( stream, data, sliceBytes );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ack packet确认数据包 : 一个位域bitfield指示哪些片段已经收到, we just send the entire state of all acked slices in each ack packet. When the ack packet is received (including the slice that was just received).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AckPacket</span> :</span> <span class="keyword">public</span> protocol2::Packet </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">uint16_t</span> chunkId; </span><br><span class="line">    <span class="keyword">int</span> numSlices; </span><br><span class="line">    <span class="keyword">bool</span> acked[MaxSlicesPerChunk]; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Serialize</span><span class="params">( Stream &amp; stream )</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        serialize_bits( stream, chunkId, <span class="number">16</span> ); </span><br><span class="line">        serialize_int( stream, numSlices, <span class="number">1</span>, MaxSlicesPerChunk ); </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numSlices; ++i ) </span><br><span class="line">            serialize_bool( stream, acked[i] ); <span class="keyword">return</span> <span class="literal">true</span>; &#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="发送方的实现"><a href="#发送方的实现" class="headerlink" title="发送方的实现"></a>发送方的实现</h2><p>与之前文章介绍的数据包的分包和重组系统不同，块系统在同一时间只能由一个块正在传输。<br>发送方的策略是：</p>
<ul>
<li>持续的发送片段数据包，直到所有的片段数据包都被确认。</li>
<li>不再对已经确认过的片段数据包进行发送。</li>
</ul>
<p>对于发送方而言有一点比较微妙，实现一个片段数据包重新发送的最小延迟是一个很棒的主意，如果不这么做的话，就可能会出现这种一样情况，对于很小的块数据或者一个块的最后几个片段数据包，很容易不停的发送它们把整个网络都塞满。正是因为这一原因，我们使用了一个数组来记录每个片段数据包的上一次发送时间。重新发送延迟的一个选择是使用一个估计的网络往返时延，或者只有在超过上一次发送时间网络往返时延*1.25还没有收到确认数据包的情况才会重新发送。或者，你可以说“这根本就无所谓”，只要超过上一次发送时间100毫秒了就重新发送。我只是列举适合我自己的方案！</p>
<p>我们使用以下的数据结构来描述发送方：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChunkSender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> sending;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunkId;</span><br><span class="line">    <span class="keyword">int</span> chunkSize;</span><br><span class="line">    <span class="keyword">int</span> numSlices;</span><br><span class="line">    <span class="keyword">int</span> numAckedSlices;</span><br><span class="line">    <span class="keyword">int</span> currentSliceId;</span><br><span class="line">    <span class="keyword">bool</span> acked[MaxSlicesPerChunk];</span><br><span class="line">    <span class="keyword">uint8_t</span> chunkData[MaxChunkSize];</span><br><span class="line">    <span class="keyword">double</span> timeLastSent[MaxSlicesPerChunk];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="接收方的实现思路"><a href="#接收方的实现思路" class="headerlink" title="接收方的实现思路"></a>接收方的实现思路</h2><p>首先，接收方的设置会从块0开始。当一个片段数据包从网络上传递过来，并且能够匹配这个块id的话，“receiving”状态会从false翻转为true，第一个片段数据包的数据会插入” chunkData“变量的合适位置，片段数据包的数量会根据第一个片段数据包里面的数据进行正确的设置，已经接收到的片段数据包的数量会加一，也就是从0到1，针对每个片段数据包的接收标记里面对应这个片段数据包的项会变为true。</p>
<p>随着这个块数据的其他片段数据包的到来，会对每一个片段数据包进行检测，判断它们的id是否与当前块的id相同，如果不相同的话就会被丢弃。如果这个片段数据包已经收到过的话，那么这个包也会被丢弃。否则，这个片段数据包的数据会插入” chunkData“变量的合适位置、已经接收到的片段数据包的数量会加一、针对每个片段数据包的接收标记里面对应这个片段数据包的项会变为true。</p>
<p>这一过程会持续进行，直到接收到所有的片段数据包。一旦接收到所有的片段数据包（也就是已经接收到的片段数据包的数量等于片段数据包的数量的时候），接收方会把“receiving “状态改为false，而把”readyToRead“状态改为true。当”readyToRead”状态为true的时候，所有收到的片段数据包都会被丢弃。在这一点上，这个处理过程通常非常的短，会在收到片段数据包的同一帧进行处理，调用者会检查”我有一块数据要读取么？“并处理块数据。然后会重置数据块接收器的所有数据为默认值，除了块数据的id从0增加到1，这样我们就准备好接收下一个块了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChunkReceiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> receiving;</span><br><span class="line">    <span class="keyword">bool</span> readyToRead;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunkId;</span><br><span class="line">    <span class="keyword">int</span> chunkSize;</span><br><span class="line">    <span class="keyword">int</span> numSlices;</span><br><span class="line">    <span class="keyword">int</span> numReceivedSlices;</span><br><span class="line">    <span class="keyword">bool</span> received[MaxSlicesPerChunk];</span><br><span class="line">    <span class="keyword">uint8_t</span> chunkData[MaxChunkSize];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="防DDos"><a href="#防DDos" class="headerlink" title="防DDos"></a>防DDos</h2><p>如果你对每个收到的片段数据包都会回复一个确认数据包的话，那么发送方能够构造一个很小的片段数据包发送给你，而你会回复一个比发送给你的片段数据包还大的确认数据包，这样你的服务器就变成了一个可以被人利用来进行DDos放大攻击的工具。</p>
<p>永远不要设计一个包含对接收到的数据包进行一对一的映射响应的协议。让我们举个简单例子来说明一下这个问题。如果有人给你发送1000个片段数据包，永远不要给他回复1000个确认数据包。相反只发一个确认数据包，而且最多每50毫秒或者100毫秒才发送一个确认数据包。如果你是这样设计的话，那么DDos攻击完全不可能的。</p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/sending_large_blocks_of_data/" target="_blank" rel="noopener">原文出处</a></p>
<p>原文标题 : <strong>Sending Large Blocks of Data</strong> (<em>How to send blocks quickly and reliably over UDP</em>)</p>
<hr>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I’m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <strong><a href="https://gafferongames.com/categories/building-a-game-network-protocol/" target="_blank" rel="noopener">Building a Game Network Protocol</a></strong>.</p><br><p>In the <a href="https://gafferongames.com/post/packet_fragmentation_and_reassembly/" target="_blank" rel="noopener">previous article</a> we implemented packet fragmentation and reassembly so we can send packets larger than MTU.</p><br><p>This approach works great when the data block you&rsquo;re sending is time critical and can be dropped, but in other cases you need to send large blocks of quickly and reliably over packet loss, and you need the data to get through.</p><br><p>In this situation, a different technique gives much better results.</p><br><h2 id="background">Background</h2><br><p>It&rsquo;s common for servers to send large block of data to the client on connect, for example, the initial state of the game world for late join.</p><br><p>Let&rsquo;s assume this data is 256k in size and the client needs to receive it before they can join the game. The client is stuck behind a load screen waiting for the data, so obviously we want it to be transmitted as quickly as possible.</p><br><p>If we send the data with the technique from the previous article, we get <em>packet loss amplification</em> because a single dropped fragment results in the whole packet being lost. The effect of this is actually quite severe. Our example block split into 256 fragments and sent over 1% packet loss now has a whopping 92.4% chance of being dropped!</p><br><p>Since we just need the data to get across, we have no choice but to keep sending it until it gets through. On average, we have to send the block 10 times before it&rsquo;s received. You may laugh but this actually happened on a AAA game I worked on!</p><br><p>To fix this, I implemented a new system for sending large blocks, one that handles packet loss by resends fragments until they are acked. Then I took the problematic large blocks and piped them through this system, fixing a bunch of players stalling out on connect, while continuing to send time critical data (snapshots) via packet fragmentation and reassembly.</p><br><h2 id="chunks-and-slices">Chunks and Slices</h2><br><p>In this new system blocks of data are called <em>chunks</em>. Chunks are split up into <em>slices</em>. This name change keeps the chunk system terminology (chunks/slices) distinct from packet fragmentation and reassembly (packets/fragments).</p><br><p>The basic idea is that slices are sent over the network repeatedly until they all get through. Since we are implementing this over UDP, simple in concept becomes a little more complicated in implementation because have to build in our own basic reliability system so the sender knows which slices have been received.</p><br><p>This reliability gets quite tricky if we have a bunch of different chunks in flight, so we&rsquo;re going to make a simplifying assumption up front: we&rsquo;re only going to send one chunk over the network at a time. This doesn&rsquo;t mean the sender can&rsquo;t have a local send queue for chunks, just that in terms of network traffic there&rsquo;s only ever one chunk <em>in flight</em> at any time.</p><br><p>This makes intuitive sense because the whole point of the chunk system is to send chunks reliably and in-order. If you are for some reason sending chunk 0 and chunk 1 at the same time, what&rsquo;s the point? You can&rsquo;t process chunk 1 until chunk 0 comes through, because otherwise it wouldn&rsquo;t be reliable-ordered.</p><br><p>That said, if you dig a bit deeper you&rsquo;ll see that sending one chunk at a time does introduce a small trade-off, and that is that it adds a delay of RTT between chunk n being received and the send starting for chunk n+1 from the receiver&rsquo;s point of view.</p><br><p>This trade-off is totally acceptable for the occasional sending of large chunks like data sent once on client connect, but it&rsquo;s definitely <em>not</em> acceptable for data sent 10 or 20 times per-second like snapshots. So remember, this system is useful for large, infrequently sent blocks of data, not for time critical data.</p><br><h2 id="packet-structure">Packet Structure</h2><br><p>There are two sides to the chunk system, the <strong>sender</strong> and the <strong>receiver</strong>.</p><br><p>The sender is the side that queues up the chunk and sends slices over the network. The receiver is what reads those slice packets and reassembles the chunk on the other side. The receiver is also responsible for communicating back to the sender which slices have been received via acks.</p><br><p>The netcode I work on is usually client/server, and in this case I usually want to be able to send blocks of data from the server to the client <em>and</em> from the client to the server. In that case, there are two senders and two receivers, a sender on the client corresponding to a receiver on the server and vice-versa.</p><br><p>Think of the sender and receiver as end points for this chunk transmission protocol that define the direction of flow. If you want to send chunks in a different direction, or even extend the chunk sender to support peer-to-peer, just add sender and receiver end points for each direction you need to send chunks.</p><br><p>Traffic over the network for this system is sent via two packet types:</p><br><ul><br><li><strong>Slice packet</strong> - contains a slice of a chunk up to 1k in size.</li><br><li><strong>Ack packet</strong> - a bitfield indicating which slices have been received so far.</li><br></ul><br><p>The slice packet is sent from the sender to the receiver. It is the payload packet that gets the chunk data across the network and is designed so each packet fits neatly under a conservative MTU of 1200 bytes. Each slice is a maximum of 1k and there is a maximum of 256 slices per-chunk, therefore the largest data you can send over the network with this system is 256k.</p><br><pre><code>const int SliceSize = 1024;<br>const int MaxSlicesPerChunk = 256;<br>const int MaxChunkSize = SliceSize <em> MaxSlicesPerChunk;<br><br>struct SlicePacket : public protocol2::Packet<br>{<br>    uint16_t chunkId;<br>    int sliceId;<br>    int numSlices;<br>    int sliceBytes;<br>    uint8_t data[SliceSize];<br><br>    template &amp;lt;typename Stream&amp;gt; bool Serialize( Stream &amp;amp; stream )<br>    {<br>        serialize_bits( stream, chunkId, 16 );<br>        serialize_int( stream, sliceId, 0, MaxSlicesPerChunk - 1 );<br>        serialize_int( stream, numSlices, 1, MaxSlicesPerChunk );<br>        if ( sliceId == numSlices - 1 )<br>        {<br>            serialize_int( stream, sliceBytes, 1, SliceSize );<br>        }<br>        else if ( Stream::IsReading )<br>        {<br>            sliceBytes = SliceSize;<br>        }<br>        serialize_bytes( stream, data, sliceBytes );<br>        return true;<br>    }<br>};<br></em></code></pre><br><p>There are two points I&rsquo;d like to make about the slice packet. The first is that even though there is only ever one chunk in flight over the network, it&rsquo;s still necessary to include the chunk id (0,1,2,3, etc&hellip;) because packets sent over UDP can be received out of order.</p><br><p>Second point. Due to the way chunks are sliced up we know that all slices except the last one must be SliceSize (1024 bytes). We take advantage of this to save a small bit of bandwidth sending the slice size only in the last slice, but there is a trade-off: the receiver doesn&rsquo;t know the exact size of a chunk until it receives the last slice.</p><br><p>The other packet sent by this system is the ack packet. This packet is sent in the opposite direction, from the receiver back to the sender. This is the reliability part of the chunk network protocol. Its purpose is to lets the sender know which slices have been received.</p><br><pre><code>struct AckPacket : public protocol2::Packet<br>{<br>    uint16_t chunkId;<br>    int numSlices;<br>    bool acked[MaxSlicesPerChunk];<br><br>    bool Serialize( Stream &amp;amp; stream )<br>    {<br>        serialize_bits( stream, chunkId, 16 );<br>        serialize_int( stream, numSlices, 1, MaxSlicesPerChunk );<br>        for ( int i = 0; i &amp;lt; numSlices; ++i )<br>        {<br>            serialize_bool( stream, acked[i] ); return true; } };<br>        }<br>    }<br>};<br></code></pre><br><p>Acks are short for &lsquo;acknowledgments&rsquo;. So an ack for slice 100 means the receiver is <em>acknowledging</em> that it has received slice 100. This is critical information for the sender because not only does it let the sender determine when all slices have been received so it knows when to stop, it also allows the sender to use bandwidth more efficiently by only sending slices that haven&rsquo;t been acked.</p><br><p>Looking a bit deeper into the ack packet, at first glance it seems a bit <em>redundant</em>. Why are we sending acks for all slices in every packet? Well, ack packets are sent over UDP so there is no guarantee that all ack packets are going to get through. You certainly don&rsquo;t want a desync between the sender and the receiver regarding which slices are acked.</p><br><p>So we need some reliability for acks, but we don&rsquo;t want to implement an <em>ack system for acks</em> because that would be a huge pain in the ass. Since the worst case ack bitfield is just 256 bits or 32 bytes, we just send the entire state of all acked slices in each ack packet. When the ack packet is received, we consider a slice to be acked the instant an ack packet comes in with that slice marked as acked and locally that slice is not seen as acked yet.</p><br><p>This last step, biasing in the direction of non-acked to ack, like a fuse getting blown, means we can handle out of order delivery of ack packets.</p><br><h2 id="sender-implementation">Sender Implementation</h2><br><p>Let&rsquo;s get started with the implementation of the sender.</p><br><p>The strategy for the sender is:</p><br><ul><br><li>Keep sending slices until all slices are acked</li><br><li>Don&rsquo;t resend slices that have already been acked</li><br></ul><br><p>We use the following data structure for the sender:</p><br><pre><code>class ChunkSender<br>{<br>    bool sending;<br>    uint16_t chunkId;<br>    int chunkSize;<br>    int numSlices;<br>    int numAckedSlices;<br>    int currentSliceId;<br>    bool acked[MaxSlicesPerChunk];<br>    uint8_t chunkData[MaxChunkSize];<br>    double timeLastSent[MaxSlicesPerChunk];<br>};<br></code></pre><br><p>As mentioned before, only one chunk is sent at a time, so there is a &lsquo;sending&rsquo; state which is true if we are currently sending a chunk, false if we are in an idle state ready for the user to send a chunk. In this implementation, you can&rsquo;t send another chunk while the current chunk is still being sent over the network. If you don&rsquo;t like this, stick a queue in front of the sender.</p><br><p>Next, we have the id of the chunk we are currently sending, or, if we are not sending a chunk, the id of the next chunk to be sent, followed by the size of the chunk and the number of slices it has been split into. We also track, per-slice, whether that slice has been acked, which lets us count the number of slices that have been acked so far while ignoring redundant acks. A chunk is considered fully received from the sender&rsquo;s point of view when numAckedSlices == numSlices.</p><br><p>We also keep track of the current slice id for the algorithm that determines which slices to send, which works like this. At the start of a chunk send, start at slice id 0 and work from left to right and wrap back around to 0 again when you go past the last slice. Eventually, you stop iterating across because you&rsquo;ve run out of bandwidth to send slices. At this point, remember our current slice index via current slice id so you can pick up from where you left off next time. This last part is important because it distributes sends across all slices, not just the first few.</p><br><p>Now let&rsquo;s discuss bandwidth limiting. Obviously you don&rsquo;t just blast slices out continuously as you&rsquo;d flood the connection in no time, so how do we limit the sender bandwidth? My implementation works something like this: as you walk across slices and consider each slice you want to send, estimate roughly how many bytes the slice packet will take eg: roughly slice bytes + some overhead for your protocol and UDP/IP header. Then compare the amount of bytes required vs. the available bytes you have to send in your bandwidth budget. If you don&rsquo;t have enough bytes accumulated, stop. Otherwise, subtract the bytes required to send the slice and repeat the process for the next slice.</p><br><p>Where does the available bytes in the send budget come from? Each frame before you update the chunk sender, take your target bandwidth (eg. 256kbps), convert it to bytes per-second, and add it multiplied by delta time (dt) to an accumulator.</p><br><p>A conservative send rate of 256kbps means you can send 32000 bytes per-second, so add 32000  dt to the accumulator. A middle ground of 512kbit/sec is 64000 bytes per-second. A more aggressive 1mbit is 125000 bytes per-second. This way each update you <em>accumulate</em> a number of bytes you are allowed to send, and when you&rsquo;ve sent all the slices you can given that budget, any bytes left over stick around for the next time you try to send a slice.</p><br><p>One subtle point with the chunk sender and is that it&rsquo;s a good idea to implement some minimum resend delay per-slice, otherwise you get situations where for small chunks, or the last few slices of a chunk that the same few slices get spammed over the network.</p><br><p>For this reason we maintain an array of last send time per-slice. One option for this resend delay is to maintain an estimate of RTT and to only resend a slice if it hasn&rsquo;t been acked within RTT * 1.25 of its last send time. Or, you could just resend the slice it if it hasn&rsquo;t been sent in the last 100ms. Works for me!</p><br><h2 id="kicking-it-up-a-notch">Kicking it up a notch</h2><br><p>Do the math you&rsquo;ll notice it still takes a long time for a 256k chunk to get across:</p><br><ul><br><li>1mbps = 2 seconds</li><br><li>512kbps = 4 seconds</li><br><li>256kbps = <strong>8 seconds :(</strong></li><br></ul><br><p>Which kinda sucks. The whole point here is quickly and reliably. Emphasis on <em>quickly</em>. Wouldn&rsquo;t it be nice to be able to get the chunk across faster? The typical use case of the chunk system supports this. For example, a large block of data sent down to the client immediately on connect or a block of data that has to get through before the client exits a load screen and starts to play. You want this to be over as quickly as possible and in both cases the user really doesn&rsquo;t have anything better to do with their bandwidth, so why not use as much of it as possible?</p><br><p>One thing I&rsquo;ve tried in the past with excellent results is an initial burst. Assuming your chunk size isn&rsquo;t so large, and your chunk sends are infrequent, I can see no reason why you can&rsquo;t just fire across the entire chunk, all slices of it, in separate packets in one glorious burst of bandwidth, wait 100ms, and then resume the regular bandwidth limited slice sending strategy.</p><br><p>Why does this work? In the case where the user has a good internet connection (some multiple of 10mbps or greater&hellip;), the slices get through very quickly indeed. In the situation where the connection is not so great, the burst gets buffered up and <em>most</em> slices will be delivered as quickly as possible limited only by the amount bandwidth available. After this point switching to the regular strategy at a lower rate picks up any slices that didn&rsquo;t get through the first time.</p><br><p>This seems a bit risky so let me explain. In the case where the user can&rsquo;t quite support this bandwidth what you&rsquo;re relying on here is that routers on the Internet <em>strongly prefer</em> to buffer packets rather than discard them at almost any cost. It&rsquo;s a TCP thing. Normally, I hate this because it induces latency in packet delivery and messes up your game packets which you want delivered as quickly as possible, but in this case it&rsquo;s good behavior because the player really has nothing else to do but wait for your chunk to get through.</p><br><p>Just don&rsquo;t go too overboard with the spam or the congestion will persist after your chunk send completes and it will affect your game for the first few seconds. Also, make sure you increase the size of your OS socket buffers on both ends so they are larger than your maximum chunk size (I recommend at least double), otherwise you&rsquo;ll be dropping slices packets before they even hit the wire.</p><br><p>Finally, I want to be a responsible network citizen here so although I recommend sending all slices once in an initial burst, it&rsquo;s important for me to mention that I think this really is only appropriate, and only really <em>borderline appropriate</em> behavior for small chunks in the few 100s of k range in 2016, and only when your game isn&rsquo;t sending anything else that is time-critical.</p><br><p>Please don&rsquo;t use this burst strategy if your chunk is really large, eg: megabytes of data, because that&rsquo;s way too big to be relying on the kindness of strangers, AKA. the buffers in the routers between you and your packet&rsquo;s destination. For this it&rsquo;s necessary to implement something much smarter. Something adaptive that tries to send data as quickly as it can, but backs off when it detects too much latency and/or packet loss as a result of flooding the connection. Such a system is outside of the scope of this article.</p><br><h2 id="receiver-implementation">Receiver Implementation</h2><br><p>Now that we have the sender all sorted out let&rsquo;s move on to the reciever. </p><br><p>As mentioned previously, unlike the packet fragmentation and reassembly system from the previous article, the chunk system only ever has one chunk in flight.</p><br><p>This makes the reciever side of the chunk system much simpler:</p><br><pre><code>class ChunkReceiver<br>{<br>    bool receiving;<br>    bool readyToRead;<br>    uint16_t chunkId;<br>    int chunkSize;<br>    int numSlices;<br>    int numReceivedSlices;<br>    bool received[MaxSlicesPerChunk];<br>    uint8_t chunkData[MaxChunkSize];<br>};<br></code></pre><br><p>We have a state whether we are currently &lsquo;receiving&rsquo; a chunk over the network, plus a &rsquo;readyToRead&rsquo; state which indicates that a chunk has received all slices and is ready to be popped off by the user. This is effectively a minimal receive queue of length 1. If you don&rsquo;t like this, of course you are free to add a queue.</p><br><p>In this data structure we also keep track of chunk size (although it is not known with complete accuracy until the last slice arrives), num slices and num received slices, as well as a received flag per-slice. This per-slice received flag lets us discard packets containing slices we have already received, and count the number of slices received so far (since we may receive the slice multiple times, we only increase this count the first time we receive a particular slice). It&rsquo;s also used when generating ack packets. The chunk receive is completed from the receiver&rsquo;s point of view when numReceivedSlices == numSlices.</p><br><p>So what does it look like end-to-end receiving a chunk?</p><br><p>First, the receiver sets up set to start at chunk 0. When the a slice packet comes in over the network matching the chunk id 0, &lsquo;receiving&rsquo; flips from false to true, data for that first slice is inserted into &lsquo;chunkData&rsquo; at the correct position, numSlices is set to the value in that packet, numReceivedSlices is incremented from 0 -&gt; 1, and the received flag in the array entry corresponding to that slice is set to true.</p><br><p>As the remaining slice packets for the chunk come in, each of them are checked that they match the current chunk id and numSlices that are being received and are ignored if they don&rsquo;t match. Packets are also ignored if they contain a slice that has already been received. Otherwise, the slice data is copied into the correct place in the chunkData array, numReceivedSlices is incremented and received flag for that slice is set to true.</p><br><p>This process continues until all slices of the chunk are received, at which point the receiver sets receiving to &lsquo;false&rsquo; and &lsquo;readyToRead&rsquo; to true. While &lsquo;readyToRead&rsquo; is true, incoming slice packets are discarded. At this point, the chunk receive packet processing is performed, typically on the same frame. The caller checks &lsquo;do I have a chunk to read?&rsquo; and processes the chunk data. All chunk receive data is cleared back to defaults, except chunk id which is incremented from 0 -&gt; 1, and we are ready to receive the next chunk.</p><br><h2 id="conclusion">Conclusion</h2><br><p>The chunk system is simple in concept, but the implementation is certainly not. I encourage you to take a close look at the <a href="http://www.patreon.com/gafferongames" target="_blank" rel="noopener">source code</a> for this article for further details.</p>


<h1 id="译文">译文</h1>


<p><a href="http://gad.qq.com/program/translateview/7165598" target="_blank" rel="noopener">译文出处</a></p>
<div class="WordSection1"><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">翻译：张华栋<span> (wcby)     </span>审校：王磊<span>(</span>未来的未来<span>)</span></span> </span></p><p class="MsoNormal" align="left"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span><span style="font-family:微软雅黑;"><br></span></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">大家好，我是格伦·菲德勒。欢迎大家阅读系列教程《构建游戏网络协议》的第四篇文章。</span></span><span style="color: rgb(34, 34, 34); font-size: 12pt; font-family: 微软雅黑;">在之前的文章中，我们讨论了如何在游戏协议这一层实现对数据包的分包和重组。</span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在在这篇文章里面，我们将继续通过探索在<span>UDP</span>协议上发送大块数据的替代方案来继续我们构建一个专业级别的游戏网络协议的征程。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">第一眼看上去，这种替代性的技术似乎非常类似于数据包的分包和重组，但是它的实现是完全不同的。这种实现上的差异的目的是为了解决数据包分包和重组的一个关键弱点<span>-</span>一个片段的丢失就会导致整个数据包都要被丢弃掉。这种行为是非常不好的，因为它会随着分包数量的增加而放大数据包丢失的概率。当你遇到大块数据包的时候，这种放大是如此的明显，加入<span>256 k</span>大小的分包丢失率是<span>1%</span>的话，那么原始数据包就有<span>92.4%</span>的概率被丢弃。平均来说，你需要发送原始数据包<span>10</span>次，它才能顺利的到达网络的另外一端！</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果你需要在一个可能会有数据包丢失的网络上比如说互联网，快速和可靠地发送大量的数据，很明显，这样的方法是完全不可接受的。你可能需要这样做的一些常见的例子包括：客户端在首次加入的时候，服务器需要下发一个大的数据块给客户端<span>(</span>可能是世界的初始状态<span>)</span>、一开始用来做增量编码的基线或者是在一个多人在线网络游戏里面客户端在加载界面所等待的大块数据。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在这些情况下非常重要的是不仅要优雅地处理数据包的丢失，还要尽可能的利用可用的带宽并尽可能快的发送大块数据。</span></span><span style="color: rgb(34, 34, 34); font-size: 12pt; font-family: 微软雅黑;">这正是我要在这篇文章里面告诉你该如何做的内容。</span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="块和片段"><span style="color: rgb(34, 34, 34);"><span style="font-size:x-large;">块和片段</span></span></h2> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">让我们开始使用基本术语。在这个新系统中，大块的数据被称为<span>”</span>块<span>“</span>，而它们被分成的分包被称为<span>”</span>片段<span>”</span>。 这个名字上的改变使的块系统的术语<span>(</span>块和片段<span>)</span>不同于数据包分包和重组的术语<span>(</span>数据包和分包<span>)</span>。这是我认为很重要的一个事情，因为这些系统是在解决不同的问题，没有理由你不能在相同的网络协议中同时这两个系统。事实上，我经常把这两个结合起来，在时间比较关键的增量数据包里面使用数据包的分包和重组，当客户端加入游戏的时候，使用块系统来下发整个游戏世界的初始状态下<span>(</span>非常大的数据包<span>)</span>。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">块系统的基本思想，真是一点都不复杂，是把块分成很多片段，然后通过网络多次发送片段，直到他们都顺利的到达网络的另外一端。当然，因为我们正在<span>UDP</span>协议上实现这个功能，同时还有可能数据包会丢失、数据包乱序到达以及数据包重复到达的情况，简单的概念在实现中也会变得非常复杂，因为我们必须在<span>UDP</span>协议上建立我们自己的具有基本可靠性的系统，这样发送方才能知道这个片段已经被网络的另外一端成功收到。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果我们有一组不同的块正在传输过程中<span>(</span>就像我们在数据包的分包和重组中所做的那样<span>)</span>，那么可靠性的问题就会变得非常棘手，所以我们要做一个简化的假设。我们一次只会通过网络发送一个块的数据。这并不意味着发送者不能在本地有一个块的发送队列，这只是意味着在实际的网络传输中只有一个块的数据会正在传递。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这么做之所以有意义，是因为有了这一点假设以后就能保证块系统能够可靠有序的发送块。如果你因为某些原因在同一时间发送块<span>0</span>和块<span>1</span>，这会发生什么？你不能在块<span>0</span>到来之前处理块<span>1</span>，否则这个传输过程就不是有序可靠了。也就是说，如果你挖得深一些的话，你会发现一次只能发送一个块确实引入了一个小的权衡，它给正在接收的块Ｎ增加了一个网络往返延迟，以及从接收方的角度看块Ｎ＋１的发送开始时间也被延迟了一个网络往返延迟。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这个代价是完全可以接受的，因为发送大块数据是一个非常偶然的事情（举些简单的例子来说，当客户端连接上来的时候会发送大块数据，当新的关卡需要进行加载的时候才会发送大块数据。。。），但是如果<span>1</span>秒钟内<span>10</span>次或者<span>20</span>次发送块数据的话这就是绝对不能被接受的了。所以我希望你能看到这个系统是专为什么目的设计的以及不是为什么目的设计的。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="数据包的结构"><span style="font-size: 18pt; color: rgb(34, 34, 34);">数据包的结构</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在块系统中有两方会参与，分别是发送方和接收方。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">发送方是负责将块压入队列并通过网络发送片段。接收方是负责在网络的另外一端读取这些片段并进行重组。接收方还负责通过发送<span>“</span>确认<span>”</span>数据包给发送方来与发送方交流表明这个片段已经收到。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我工作过的网络模式通常是客户端与服务端之间的通信，在这种情况下，我通常希望能够从服务器往客户端发送大块数据，以及从客户端到服务器发送大块数据。所以在这种情况下，有两个发送方和两个接收方，一个发送方在客户端对应着在服务器那边有一个接收方，反过来也是如此。可以把发送方和接收方认为是块传输协议的终点，这样也就定义了网络流的方向。如果你想在不同的方向发送块，甚至是扩展块的发送方来支持点对点的发送，只需要在你需要发送块的每个方向添加一个发送方和一个接收方作为终点。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这个系统在网络上发送的数据包类型一共有两种类型：</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">1）片段数据包<span>-</span>这包括了一个块的片段，最多大小为<span>1k</span>。</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">2）确认数据包<span>-</span>一个位域指示哪些片段已经收到。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">片段数据包是从发送方发送到接收器的。这是通过网络对块数据进行传递的有效载荷数据包，在设计的时候每个片段数据包的大小都贴近一个保守的最大传输单元的大小，也就是<span> 1200</span>字节。每个片段数据包最大是<span>1 k</span>，每个块最多有<span>256</span>个片段数据包，所以通过这个系统可以通过网络发送的最大的数据是<span>256k</span>（如果你愿意的话，你可以增加这个片段的最大数目）。我建议保持片段的大小为<span>1k</span>，这主要是基于最大传输单元方面的考虑。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(43, 43, 43); background: rgb(248, 248, 248);"> </span></span></p><div><div id="highlighter_653417" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">SliceSize = 1024;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">MaxSlicesPerChunk = 256;</code></div><div class="line number3 index2 alt2"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">MaxChunkSize = SliceSize <em> MaxSlicesPerChunk;</em></code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">SlicePacket : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">protocol2::Packet</code></div><div class="line number6 index5 alt1"><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t chunkId;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">sliceId;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numSlices;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">sliceBytes;</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint8_t data[SliceSize];</code></div><div class="line number12 index11 alt1"><code class="cpp spaces"> </code> </div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">template</code> <code class="cpp plain">&lt;</code><code class="cpp keyword bold">typename</code> <code class="cpp plain">stream</code><code class="cpp string"></code><code class="cpp plain">&gt; </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, chunkId, 16 );</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_int( stream, sliceId, 0, MaxSlicesPerChunk - 1 );</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">        </code><code class="cpp plain">serialize_int( stream, numSlices, 1, MaxSlicesPerChunk );</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( sliceId == numSlices - 1 )</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">        </code><code class="cpp plain">{</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">            </code><code class="cpp plain">serialize_int( stream, sliceBytes, 1, SliceSize );</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">        </code><code class="cpp plain">}</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">else</code> <code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">        </code><code class="cpp plain">{</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">            </code><code class="cpp plain">sliceBytes = SliceSize;</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">        </code><code class="cpp plain">}</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bytes( stream, data, sliceBytes );</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number29 index28 alt2"><code class="cpp plain">};</code><code class="cpp keyword bold"></code><code class="cpp plain"></code></div></div></td></tr></table></div></div><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在这里我想对片段数据包进行两点说明。第一点是即使只有一个块在网络上进行传输，仍然是有必要在数据包里面包含一个块的<span>id(</span>比如说，<span>0</span>、<span>1</span>、<span>2</span>、<span>3</span>、等等等<span>)</span>，这是<span>,</span>因为通过<span>UDP</span>协议发送的数据包可以是乱序到达的。通过这种方式的话，如果一个片段数据包到达的时候对应着一个已经接受过的块，举个简单的例子来说明，你正在接受块<span>2</span>的数据，但是块<span>1</span>的一个片段数据包现在到达了，你可以直接拒绝这个数据包，而不是接受它的数据包并把它的数据插入到块<span>2</span>从而把块<span>2</span>的数据给弄混了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">第二点。由于我们知道块分成片段的方法会把所有的片段除了最后一个以外都弄成必须<span>SliceSize</span>的大小<span>(</span>也就是<span>1024</span>字节<span>)</span>。我们利用这一点来节省一点带宽，我们只在最后一个片段里面发送片段的大小，但这是一种权衡<span>:</span>接收方不知道块的确切大小到底是多少字节，直到它接收到最后一个片段才能知道。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">可以让这个系统继续往后发送新的数据包的机制是确认数据包。这个数据包是沿着另外一个方向进行发送的，也就是从接收方发回给发送方，这也是块网络协议中负责可靠性的部分。它存在的目的是让发送方知道这个片段已经被发送方收到。</span></span></p><div><div id="highlighter_476828" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">AckPacket : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">protocol2::Packet </code></div><div class="line number2 index1 alt1"><code class="cpp plain">{ </code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t chunkId; </code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numSlices; </code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">acked[MaxSlicesPerChunk]; </code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{ </code></div><div class="line number9 index8 alt2"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, chunkId, 16 ); </code></div><div class="line number10 index9 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_int( stream, numSlices, 1, MaxSlicesPerChunk ); </code></div><div class="line number11 index10 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; numSlices; ++i ) </code></div><div class="line number12 index11 alt1"><code class="cpp spaces">            </code><code class="cpp plain">serialize_bool( stream, acked[i] ); </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">; } };</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number14 index13 alt1"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">ack</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">是<span>“</span>确认<span>”</span>的缩写。所以一个对片段<span>100</span>的确认数据包意味着接收方确认它已经接收到了片段<span>100</span>。这对于发送方来说是一条关键信息，因为它不仅让发送方知道什么时候所有的片段都已经被成功接收，这样发送方就可以停止发送了，它还允许发送方只重发那些还没有被确认的片段，这样就能让发送方更有效率的利用带宽。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">让我们对确认数据包再深入一点思考，似乎在一开始看上去对于每个数据包的所有分片都发送确认包似乎有点多余。我们为什么要这么做<span>?</span>是的，这是因为确认数据包是通过<span>UDP</span>协议发送的，所以没有办法保证所有的确认数据包都会成功的到达网络的另外一端，你当然不会希望发送方和接收方之间对于目前确认到那个片段的信息都是不同步的。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">所以我们需要一些确认数据包传输的可靠性，但是我们不希望实现一个确认数据包的确认系统，因为这将会是一个非常痛苦和麻烦的过程。因为在最坏的情况下，确认数据包的大小是<span>256</span>位或<span>32</span>字节，最简单的方法是也是最好的。we just send the entire state of all acked slices in each ack packet. When the ack packet is received, we consider a slice to be acked the instant an ack packet comes in with that slice marked as acked and locally that slice is not seen as acked yet.</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="基本的发送方实现"><span style="font-size: 18pt; color: rgb(34, 34, 34);">基本的发送方实现</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在我们已经了解了这个系统背后的基本概念，让我们从发送方的实现开始实现整个系统。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">发送方的策略是：</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">1）持续的发送片段数据包，直到所有的片段数据包都被确认。</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">2）</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">不再对已经确认过的片段数据包进行发送。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们使用以下的数据结构来描述发送方：</span></span></p><div><div id="highlighter_252465" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">class</code> <code class="cpp plain">ChunkSender</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">sending;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t chunkId;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">chunkSize;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numSlices;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numAckedSlices;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">currentSliceId;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">acked[MaxSlicesPerChunk];</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp plain">uint8_t chunkData[MaxChunkSize];</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">double</code> <code class="cpp plain">timeLastSent[MaxSlicesPerChunk];</code></div><div class="line number12 index11 alt1"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">正如之前提到的那样，一次只会发送一个块的数据，如果我们正在发送一个块的数据的时候，那么关于<span>“</span>发送<span>”</span>的状态是<span>true</span>，假如我们处于闲置状态、正在准备发送一个块的数据的时候，那么关于<span>“</span>发送<span>”</span>的状态是<span>false</span>。在这个实现中，如果当前有一个块的数据仍在通过网络进行发送的话，你不能发送另外一个块的数据。你必须等待当前块的数据发送完毕之后才可以发送另外一个块的数据。如果你不喜欢的话，在块的发送器的前端按照你的意愿可以放置一个发送队列。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">接下来，我们有我们正在发送的块数据的<span>id</span>，或者如果我们没有在发送块数据的话，那么我们有要发送的下一个块数据的<span>id</span>、以及这个块所分成的片段数据包的数量。我们也会跟踪每个片段数据包，来记录这个片段数据包是否已经被确认，这可以让我们避免重发那些已经收到的片段数据包，并且我们还会记录迄今为止已经确认收到的片段数据包的数量，这个数量会去掉冗余的确认，也就是每个片段数据包的确认只算一次。从发送方的观点来看，只有当确认的片段数据包的数量等于这个块所分成的片段数据包的数量的时候才会这个块数据已经被完全收到了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们还需要为这个算法记录当前发送的片段数据包的<span>id</span>，因为这将决定了哪些片段数据包将被发送。它的工作机制大致是这样：一个块数据开始发送的时候，是从<span>id</span>为<span>0</span>的片段数据包开始发送的，然后依次从左到右开始发送直到经过最后一个片段数据包<span>(</span>也就是<span>id</span>为分包数量的大小<span>-1)</span>的时候会回头从<span>id</span>为<span>0</span>的片段数据包继续发送。最终，你会停止这个迭代因为发送的片段数据包已经耗尽了带宽。在这一点上，我们通过记录当前发送的片段数据包的<span>id</span>就能记住我们当前遍历的片段数据包的索引，这样在下一次开始遍历的时候你就可以继续从这个位置开始发送片段数据包。最后一部分是非常重要的，这是因为它可以把发送一个块数据所有的片段数据包这个事情是分散开，而不是在一起就全部发出去。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在让我们讨论下带宽限制。显然你不能把所有的片段数据包一次全部发完，因为如果这么做的话，会把整个链接堵住，那么，我们该如何限制发送方所使用的带宽<span>?</span>我的实现机制大概是这样的：当你对全部的片段数据包进行遍历并且考虑你想要发送的每个片段数据包的时候，大概估计下这个片段数据包会需要占据多少字节，比如可以用这种估计算法：大概这个片段的字节数<span>+</span>一些协议的开销和<span>UDP / IP</span>的报头。然后用所需的字节数和你带宽预算里面可用来进行发送的字节数进行比较。如果带宽预算里面没有足够可用的字节数，那么就停止发送。否则的话，从带宽预算里面减去发送这个片段数据包所需的字节数，然后对于下个片段数据包重复整个过程。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">带宽预算里面可用的字节发送预算是从哪里计算得来的？在每一帧更新块的发送方之前，把你的目标带宽（比如说每秒<span>256KB</span>）转换成每秒可以发送的字节数，然后用它乘以更新时间来把记过放到一个累加器里面。每秒<span>256KB</span>是一个比较保守的发送速率，这意味你可以每秒发送<span>32000</span>个字节，所以把<span>32000  dt</span>这个值添加到累加器里面。每秒<span>512KB</span>是一个比较适中的估计，意味你可以每秒发送<span>64000</span>个字节。每秒<span>1MB</span>是一个比较激进的估计，意味你可以每秒发送<span>125000</span>个字节。通过这种方法，在每次更新的时候你就可以累加你被允许发送的字节数了，这样当你可以按照预算来发送最大数量的片段数据包，如果还有数据没有发完的话，会等到下一帧的时候再尝试发送。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">对于发送方而言有一点比较微妙，实现一个片段数据包重新发送的最小延迟是一个很棒的主意，如果不这么做的话，就可能会出现这种一样情况，对于很小的块数据或者一个块的最后几个片段数据包，很容易不停的发送它们把整个网络都塞满。正是因为这一原因，我们使用了一个数组来记录每个片段数据包的上一次发送时间。重新发送延迟的一个选择是使用一个估计的网络往返时延，或者只有在超过上一次发送时间网络往返时延<span>*1.25</span>还没有收到确认数据包的情况才会重新发送。或者，你可以说<span>“</span>这根本就无所谓<span>”</span>，只要超过上一次发送时间<span>100</span>毫秒了就重新发送。我只是列举适合我自己的方案！</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);"> </span> </span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="把发送方实现的更完美一点"><span style="font-size: 18pt; color: rgb(34, 34, 34);">把发送方实现的更完美一点</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果你仔细用数学计算一下的话，你会注意到对于一个<span>256K </span>的数据块而言，它要在网络上发送完毕仍然需要发送很长的时间：</span> </span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-family:微软雅黑;"><span style="font-size: 12pt;">如果网络速率是每秒<span>1M</span>的话，就需要<span>2</span>秒钟的时间。</span> </span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-family:微软雅黑;"><span style="font-size: 12pt;">如果网络速率是每秒<span>512KB</span>的话，就需要<span>4</span>秒钟的时间。</span> </span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-family:微软雅黑;"><span style="font-size: 12pt;">如果网络速率是每秒<span>256KB</span>的话，就需要<span>8</span>秒钟的时间。</span> </span></li></ul><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这可有点糟糕。我们实现系统的重点是快速和可靠性。再次强调下需要能够快速传递。如果块系统的传输不能做到快速的话，这是不是会不太好？块系统的一些典型用例会支持这一点。举个简单的例子来说明，当客户端第一次连接上服务器的时候，一大块数据需要立刻发送给客户端，或者在客户端退出加载界面开始游戏的时候需要能够大量数据快速下发给客户端。你想要尽快的传递完需要的数据，而且在这两种情况下，用户对于自己的带宽并没有什么太多其他的用途，那么为什么不使用尽可能多的带宽<span>?</span></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span><br></span></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在过去我曾经尝试过一个方法，就是在一开始的时候尽量传递，这取得了很好的效果。假设你的块大小并不是那么大，而且你的块发送频率并不那么频繁，我没找到什么理由为什么你不能在一开始就把所有的片段数据包都发送出去，填充满贷款，然后等待<span>100</span>毫秒，在恢复成正常的带宽受限的片段数据包发送策略。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">为什么这样会取得良好的效果？如果用户有一个良好的网络连接（可以每秒发送超过<span>10MB</span>的数据甚至更多。。。），事实上，片段数据包在网络上的传输非常的快速。如果是连接的情况并不是那么好的情况下，大部分的片段数据包会得到缓冲，大部分的片段数据包受限于带宽但是会尽可能快的发送出去。处理完这些数据包之后，就会切换到常规的策略，从那些第一次没有发送出去的片段数据包选择合适的进行发送。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这似乎有点冒险，所以让我来解释一下。如果出现大量数据需要传输但是已经超过带宽限制的情况，互联网上的路由器会倾向于缓冲这些数据包，而不是不惜代价的抛弃它们。这就是<span>TCP</span>协议会做的事情。通常情况下，我讨厌这个机制因为它会诱发延迟而且会弄乱那些你想要尽快交付的游戏数据包，但在这种情况下它是一个非常好的行为，这是因为玩家真的没有其他事情可以做，智能等待你的块数据赶紧传输完毕。只是在你的块数据传输完毕以后，会有一些垃圾数据或者交通拥堵，它会影响你的游戏开始的几秒钟。另外，请确保你增加了网络两端的加操作系统的套接字缓冲区的大小，这样它们才可以比你最大的块数据的大小要大<span>(</span>我建议至少增加一倍<span>)</span>，否则在超过网络带宽的限制之前你就会出现丢弃段数据包的情况。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">最后，我想成为一个负责任的网络公民，虽然在这里我推荐在最开始连接的时候一次发送所有的片段数据包，所以对我来说介绍下我认为这真的是适当的是非常非常重要的，在<span>2016</span>年的网络环境下，发送几百个<span>KB</span>量级的数据包是没什么大不了的行为，而且只会发生在没有其他关键数据同时发送的情况下。让我们举个简单的例子来说明，如果用户正在玩你的游戏，那么当你发送大块数据的时候，使用保守的策略。如果不这么做的话，就会冒影响用户游戏体验的风险，这是因为你的发送行为可能会诱导额外的网络延迟或者出现数据包丢失的情况。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">同样，如果你的块数据非常大的情况下，比如说是十几<span>MB</span>的情况，那么请不要使用这种野蛮发送的策略，这是因为这种方法太过于依赖陌生人的仁慈，也就是在你和你的数据包目的地之间的路由器缓冲区。如果要持续发送非常大的数据块保持一个高吞吐量有必要实施一些更聪明的方法。这是某种自适应的方法，它会试图尽快发送数据，但是一旦检测到因为连接上有太多的数据在传输导致太多的延迟或者数据包的丢失，就能切换回一个低速的方式。这样一个系统超出了本文的范围。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="接收方的实现"><span style="font-size: 18pt; color: rgb(34, 34, 34);">接收方的实现</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在我们已经解决了发送方实现的所有细节和小问题，那么让我们开始实现接收方。正如之前提到的那样，与之前文章介绍的数据包的分包和重组系统不同，块系统在同一时间只能由一个块正在传输。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这使得块系统的接收方可以实现的更加简单，你可以看下面的实现<span>:</span></span> </span></p><div><div id="highlighter_415734" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">class</code> <code class="cpp plain">ChunkReceiver</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">receiving;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">readyToRead;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t chunkId;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">chunkSize;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numSlices;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numReceivedSlices;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">received[MaxSlicesPerChunk];</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp plain">uint8_t chunkData[MaxChunkSize];</code></div><div class="line number11 index10 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="text-indent: 21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);"> </span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们有一个状态来记录我们是否正在网络上“接收”一个块数据，加上“<span>readyToRead’</span>”状态来表明是否已经有一个块的所有片段数据包都已经收到、已经准备好被用户弹出进行读取处理了。接收队列的最小长度是<span>1</span>，这是非常有效的。如果你不喜欢这个的话，你当然可以立即从块数据接收器里面将这个数据弹出并把它插入实际的接收队列。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在这个数据结构中我们还记录了块数据的大小（尽管不是完全准确，直到收到最后一个片段数据包才能准确的计算块数据的大小）、片段数据包的数量、已经接收到的片段数据包的数量还有针对每个片段数据包的一个接收标记。针对每个片段数据包的接收标记可以让我们丢弃那些我们已经收到的片段数据包，并计算到目前为止我们已经收到的片段数据包的数量（因为我们可能会多次收到同一个片段数据包，但是我们只会在第一次收到这个片段数据包的才会增加计数器的值）。它也被用在生成确认数据包上。当已经接收到的片段数据包的数量等于片段数据包的数量的时候，从接收方的角度看这个块数据的接收才算完成。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">首先，接收方的设置会从块<span>0</span>开始。当一个片段数据包从网络上传递过来，并且能够匹配这个块<span>id</span>的话，“<span>receiving”</span>状态会从<span>false</span>翻转为<span>true</span>，第一个片段数据包的数据会插入”<span> chunkData</span>“变量的合适位置，片段数据包的数量会根据第一个片段数据包里面的数据进行正确的设置，已经接收到的片段数据包的数量会加一，也就是从<span>0</span>到<span>1</span>，针对每个片段数据包的接收标记里面对应这个片段数据包的项会变为<span>true</span>。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">随着这个块数据的其他片段数据包的到来，会对每一个片段数据包进行检测，判断它们的<span>id</span>是否与当前块的<span>id</span>相同，如果不相同的话就会被丢弃。如果这个片段数据包已经收到过的话，那么这个包也会被丢弃。否则，这个片段数据包的数据会插入”<span> chunkData</span>“变量的合适位置、已经接收到的片段数据包的数量会加一、针对每个片段数据包的接收标记里面对应这个片段数据包的项会变为<span>true</span>。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这一过程会持续进行，直到接收到所有的片段数据包。一旦接收到所有的片段数据包（也就是已经接收到的片段数据包的数量等于片段数据包的数量的时候），接收方会把“<span>receiving </span>“状态改为<span>false</span>，而把”<span>readyToRead</span>“状态改为<span>true</span>。当<span>”readyToRead”</span>状态为<span>true</span>的时候，所有收到的片段数据包都会被丢弃。在这一点上，这个处理过程通常非常的短，会在收到片段数据包的同一帧进行处理，调用者会检查<span>”</span>我有一块数据要读取么？<span>“</span>并处理块数据。然后会重置数据块接收器的所有数据为默认值，除了块数据的<span>id</span>从<span>0</span>增加到<span>1</span>，这样我们就准备好接收下一个块了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="浸泡测试的重要性和确认数据包"><span style="font-size: 18pt; color: rgb(34, 34, 34);">浸泡测试的重要性和确认数据包</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">第一眼看上去，确认数据包这个系统似乎很简单：</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">1）记录已经接收到的片段数据包。</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">2）当一个片段数据包收到以后，回复一个包含所有确认收到的片段数据包信息的确认数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这看上去实现起来似乎相当的简单，但是像大多数发生在<span>UDP</span>协议的事情一样，当涉及到数据包丢失的时候，就有一些微妙的点让它的处理有点棘手。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">一个对于确认数据包比较天真的实现可能是这样子的。每次收到片段数据包，就回复一个包含所有确认收到的片段数据包信息的确认数据包（也会包括刚收到的片段数据包的信息）。这看上去非常符合逻辑，但是这使得块协议给恶意发送者一个漏洞使得它们可以块协议作为一个DDos的工具。如何作为一个DDos的工具<span>?</span>如果你对每个收到的片段数据包都会回复一个确认数据包的话，那么发送方能够构造一个很小的片段数据包发送给你，而你会回复一个比发送给你的片段数据包还大的确认数据包，这样你的服务器就变成了一个可以被人利用来进行DDos放大攻击的工具。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在也许是因为我对DDos这个事情有一点偏执（我确实是有一点），但是一般来说你可以防止对DDos的放大，永远不要设计一个包含对接收到的数据包进行一对一的映射响应的协议。让我们举个简单例子来说明一下这个问题。如果有人给你发送<span>1000</span>个片段数据包，永远不要给他回复<span>1000</span>个确认数据包。相反只发一个确认数据包，而且最多每<span>50</span>毫秒或者<span>100</span>毫秒才发送一个确认数据包。如果你是这样设计的话，那么滥用你的<span>UDP</span>协议对DDos进行放大就是完全不可能的。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">还有其他的方法让这个确认系统容易出错，而这些都往往表现为<span>”</span>发送挂起<span>“</span>。换句话说，接收方已经知道这个块已经发送完毕了，但是由于程序员的错误，发送方错过了一个确认数据包<span>(</span>可能是针对最后一个片段数据包的确认数据包<span>)</span>并且卡入到一个状态，会不停的反复重发这个片段数据包而没有得到一个确认数据包的响应。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在过去<span>10</span>年里，我可能至少<span>5</span>次从头开始实现这个块系统，每次我都找到新的和令人兴奋的方式来让发送方挂起。我开发和测试块系统的策略是首先进行编码确认它能够跑起来，然后设置一个测试工具在有大量的数据包丢失、数据包乱序和重复的情况下随机发送随机大小的块。这往往会清除任何挂起。我曾经实现过的块系统都至少有一个挂起存在，通常会有<span>2</span>到<span>3</span>个挂起。所以如果你是打算从头开始实现这个块系统的话，请不要轻敌。请设置一个浸泡测试。你会感谢我在这里的提醒的。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我通常遇到的第一次挂起是由于对同一个片段数据包的多次收到不会回复一个确认数据包。它有点像这样：<span>” </span>哦，这个片段数据包已经收到过了么？已经收到过了就丢弃它<span>”</span>，然后忘记在确认数据包里面设置标记。这对于发送方来说是一个困扰，因为这样的话就不会有一个确认数据包，那么如果出现这种情况的话，又恰好遇到第一次收到这个片段数据包的时候发送的确认数据包出现丢包的情况，发送方根本就不知道这个他在反复发送的片段数据包其实已经被收到了。如果你就是这么不巧，遇上了第一次收到这个片段数据包的时候发送的确认数据包出现丢包的情况，那么就遇上了挂起的情况。如果你想在你的代码里面重现这个情况的话，可以在收到最后一个片段数据包的时候不发送确认数据包，那么出现的情况就是这种挂起了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">下一个挂起会发生在接收方在发送方知道之前就已经知道块发送完毕并切换它的状态变量“<span>readyToRead”</span>来丢弃后续传入的片段数据包。在这种状态下，即使接收方认为块已经完全接收完毕，但是发送方还不知道这一点，所以有必要设置确认数据包对应的标志位，即使块已经完全接收完毕，这样发送方才能一直接收到提示块已经全部发送完毕的确认数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">通常遇到的最后一个挂起情况是在读取完块数据以后的状态切换里面，那个时候状态变量“<span>readyToRead”</span>已经切回<span>false</span>而块的<span>id</span>也加一了。让我们举个简单例子来说明一下这个问题，块<span>0</span>已经完成接收，用户已经完成对块<span>0</span>的读取并且块<span>id</span>已经递增到<span>1</span>了，所以我们已经准备好接收块<span>1</span>的片段数据包了（我们会丢弃任何与我们当前正在接收块<span>ID</span>不同的片段数据包）。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">再一次出现这种情况，就是这里的发送方因为确认数据包的丢失导致信息有一点滞后，可能是因为没有收到第一个确认数据包。在这种情况下，有必要关注片段数据包，如果我们正处于这么一个状态：我们尚未收到第<span>n</span>个片段数据包，但是前面<span>n – 1</span>个片段数据包都已经收到了，我们必须设置一个特殊的标记位然后我们会发送一个包含所有前面<span>n – 1</span>个片段数据包都已经收到信息的确认数据包，否则发送方不会意识到块数据已经收到并且发送方已经准备挂起了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">正如你所看到的那样，确认数据包的实现是有一点微妙的，这是一个有点奇怪的过程因为当片段数据包在网络的一端收到的时候，需要设置一个标记位来发送确认数据包直到发送方知道都有哪些发送的片段数据包被成功接收为止。如果你打破了片段数据包<span>-&gt;</span>确认数据包这个链接的话，那么整个系统就将挂起。我鼓励你仔细看看这篇文章的源代码搞清楚进一步的细节。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="总结"><span style="font-size: 18pt; color: rgb(34, 34, 34);">总结</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">块系统在概念上是很简单的，但是它的具体实现肯定不是微不足道的。在我看来，实现发送者设计这一块是一个很好的学习经验，当你从头开始实现这样的系统的时候一定有很多东西需要学习。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我希望你喜欢这个系统的设计，并试着自己动手从头开始实现它。这是一个很好的学习经历。此外，我鼓励你在<span>patreon</span>上支持我，作为回报，你会得到本文的示例源代码<span>(</span>以及本系列的其他文章的示例源代码<span>)</span>，还包括我在<span>GDC 2015</span>上关于网络物理的演讲的源代码。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果你觉得这篇文章有价值的话，请在<span>patreon</span>上支持我的写作，这样我会写的更快。你可以在<span>BSD 3.0</span>许可下访问到这篇文章里面的代码。非常感谢你的支持！</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">【版权声明】</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权。</span> </span></p><p class="MsoNormal"><span style="font-family:微软雅黑;"><span> </span> </span></p><p class="MsoNormal"><span><span style="font-family:微软雅黑;"> </span></span> </p></div>                    <br>                

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/02/26/packet_fragmentation_and_reassembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/26/packet_fragmentation_and_reassembly/" itemprop="url">构建游戏网络协议三之数据包的分包和重组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-26T03:13:35+00:00">
                2017-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="本篇自我总结"><a href="#本篇自我总结" class="headerlink" title="本篇自我总结"></a>本篇自我总结</h1><p>本篇主要讲了数据包的分包和重组问题, 到底数据包多大才好呢?是不是越大越好呢?包太大了怎么办呢?<br>请看总结, 不明之处再看文中具体讲解.</p>
<h2 id="为什么需要做这个分包和重组系统"><a href="#为什么需要做这个分包和重组系统" class="headerlink" title="为什么需要做这个分包和重组系统"></a>为什么需要做这个分包和重组系统</h2><p>每台计算机(路由器)会沿着路由强制要求数据包的大小会有一个最大的上限，这个上限就是所谓的最大传输单元MTU。如果任意一个路由器收到一个数据包的大小超过这个最大传输单元的大小，它有这么两个选择，a)在IP层对这个数据包进行分包，并将分包后的数据包继续传递，b)丢弃这个数据包然后告诉你数据包被丢弃了，你自己负责摆平这个问题。</p>
<p><strong>实例</strong> : 这儿有一个我会经常遇到的情况。人们在编写多人在线游戏的时候，数据包的平均大小都会非常的小，让我们假设下，这些数据包的平均大小大概只有几百字节，但时不时会在他们的游戏中同时发生大量的事情并且发出去的数据包会出现丢失的情况，这个时候数据包会比通常的情况下要大。突然之间，游戏的数据包的大小就会超过最大传输单元的大小，这样就只有很少一部分玩家能够收到这个数据包，然后整个通信就崩溃了。</p>
<h2 id="本篇基本术语"><a href="#本篇基本术语" class="headerlink" title="本篇基本术语"></a>本篇基本术语</h2><ul>
<li>数据包packets</li>
<li>分包fragments</li>
</ul>
<h2 id="分包的数据结构"><a href="#分包的数据结构" class="headerlink" title="分包的数据结构"></a>分包的数据结构</h2><p>我们将允许一个数据包最多可以分成256个数据包，并且每个分包后的数据包的大小不会超过1024个字节。这样的话，我们就可以通过这样一个系统来发送大小最大为256k的数据包</p>
<pre><del>[protocol id] (32 bits)</del>   // not actually sent, but used to calc crc32
[crc32] (32 bits)  
[sequence] (16 bits)  // 数据包序号
[packet type = 0] (2 bits)
<strong>[fragment id] (8 bits) // 分包ID
[num fragments] (8 bits)
[pad zero bits to nearest byte index] // 用于字节对齐的bits
&lt;fragment data&gt;</strong>
</pre>

<h2 id="发送分包后的数据包"><a href="#发送分包后的数据包" class="headerlink" title="发送分包后的数据包"></a>发送分包后的数据包</h2><p>发送分包以后的数据包是一件非常容易的事情。如果数据包的大小小于保守估计的最大传输单元的大小。那么就按正常的方法进行发送。否则的话，就计算这个数据包到底该分成多少个1024字节的数据包分包，然后构建这些分包并按照之前发送正常数据包的方法进行发送。</p>
<p>发送出去以后也不记录发送的数据包的内容，这种发送以后不记录发送的数据包的内容的方法有一个后果，就是数据包的任意一个分包如果丢失的话，那么整个数据包就都要丢弃。随着分包数量的增加，整个数据包被丢弃的概率也随之增加.由此可见，当你需要发送要给256K的数据包的时候要发送256个分包，如果有一个分包丢失的话，你就要重新把这个256k的数据包再分一次包然后再发送出去。</p>
<h2 id="什么时候用这个分包和重组系统呢"><a href="#什么时候用这个分包和重组系统呢" class="headerlink" title="什么时候用这个分包和重组系统呢"></a>什么时候用这个分包和重组系统呢</h2><p>因为发送出去以后也不记录发送的数据包, 随着分包数量的增加，整个数据包被丢弃的概率也随之增加, 而一个片段的丢失就会导致整个数据包都要被丢弃掉.所以我建议你要小心分包以后的数量。</p>
<p><strong>这个分包和重组系统最好是只对2-4个分包的情况进行使用，而且最好是针对那种对时间不怎么敏感的数据使用或者是就算分包lost了也无所谓的情况。</strong>绝对不要只是为了省事就把一大堆依赖顺序的事件打到一个大数据包里面然后依赖数据包的分包和重组机制进行发送。这会让事情变得更加麻烦。</p>
<p>数据包分包和重组系统的关键弱点是一个片段的丢失就会导致整个数据包都要被丢弃掉, 想要解决这个弱点得使用大块数据发送策略, 见下一篇文章 <a href="/2017/02/28/sending_large_blocks_of_data/" title="构建游戏网络协议四之发送大块数据">构建游戏网络协议四之发送大块数据</a>.</p>
<h2 id="接收分包后的数据包"><a href="#接收分包后的数据包" class="headerlink" title="接收分包后的数据包"></a>接收分包后的数据包</h2><p>之所以对分包后的数据包进行接收很困难的原因是我们不仅需要给缓冲区建立一个数据结构还要把这些分包重组成原始的数据包，我们也要特别小心如果有人试图让我们的程序产生崩溃而给我们发送恶意的数据包。</p>
<p>要非常小心检查一切可能的情况。除此之外，还有一个非常简单的事情要注意：让分包保存在一个数据结构里面，当一个数据包的所有分包都到达以后（通过计数来判断是否全部到达），将这些分包重组成一个大的数据包，并把这个重组后的大数据包返回给接收方。</p>
<p>什么样的数据结构在这里是有意义的?这里并没有什么特别的数据结构!我使用的是一种我喜欢称之为序列缓冲区的东西。我想和你分享的最核心的技巧是如何让这个数据结构变得高效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int MaxEntries = 256;</span><br><span class="line"> </span><br><span class="line">struct SequenceBuffer</span><br><span class="line">&#123;</span><br><span class="line">    bool exists[MaxEntries];</span><br><span class="line">    uint16_t sequence[MaxEntries];</span><br><span class="line">    Entry entries[MaxEntries];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/packet_fragmentation_and_reassembly/" target="_blank" rel="noopener">原文出处</a></p>
<p>原文标题 : <strong>Packet Fragmentation and Reassembly</strong> (<em>How to send and receive packets larger than MTU</em>)</p>
<hr>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I’m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <strong><a href="https://gafferongames.com/categories/building-a-game-network-protocol/" target="_blank" rel="noopener">Building a Game Network Protocol</a></strong>.</p><br><p>In the <a href="https://gafferongames.com/post/serialization_strategies/" target="_blank" rel="noopener">previous article</a> we discussed how to unify packet read and write into a single serialize function and added a bunch of safety features to packet read.</p><br><p>Now we are ready to start putting interesting things in our packets and sending them over the network, but immediately we run into an interesting question: <em>how big should our packets be?</em></p><br><p>To answer this question properly we need a bit of background about how packets are actually sent over the Internet.</p><br><h2 id="background">Background</h2><br><p>Perhaps the most important thing to understand about the internet is that there&rsquo;s no direct connection between the source and destination IP address. What actually happens is that packets hop from one computer to another to reach their destination.</p><br><p>Each computer along this route enforces a maximum packet size called the maximum transmission unit, or MTU. According to the IP standard, if any computer recieves a packet larger than its MTU, it has the option of a) fragmenting that packet, or b) dropping the packet.</p><br><p>So here&rsquo;s how this usually goes down. People write a multiplayer game where the average packet size is quite small, lets say a few hundred bytes, but every now and then when a lot of stuff is happening in their game and a burst of packet loss occurs, packets get a lot larger than usual, going above MTU for the route, and suddenly all packets start getting dropped!</p><br><p>Just last year (2015) I was talking with Alex Austin at Indiecade about networking in his game <a href="http://subrosagame.com" target="_blank" rel="noopener">Sub Rosa</a>. He had this strange networking bug he couldn&rsquo;t reproduce. For some reason, players would randomly get disconnected from the game, but only when a bunch of stuff was going on. It was extremely rare and he was unable to reproduce it. Alex told me looking at the logs it seemed like <em>packets just stopped getting through</em>.</p><br><p>This sounded <em>exactly</em> like an MTU issue to me, and sure enough, when Alex limited his maximum packet size to a reasonable value the bug went away.</p><br><h2 id="mtu-in-the-real-world">MTU in the real world</h2><br><p>So what&rsquo;s a reasonable maximum packet size?</p><br><p>On the Internet today (2016, IPv4) the real-world MTU is 1500 bytes.</p><br><p>Give or take a few bytes for UDP/IP packet header and you&rsquo;ll find that the typical number before packets start to get dropped or fragmented is somewhere around 1472.</p><br><p>You can try this out for yourself by running this command on MacOS X:</p><br><pre>ping -g 56 -G 1500 -h 10 -D 8.8.4.4</pre><br><p>On my machine it conks out around just below 1500 bytes as expected:</p><br><pre>1404 bytes from 8.8.4.4: icmp_seq=134 ttl=56 time=11.945 ms<br>1414 bytes from 8.8.4.4: icmp_seq=135 ttl=56 time=11.964 ms<br>1424 bytes from 8.8.4.4: icmp_seq=136 ttl=56 time=13.492 ms<br>1434 bytes from 8.8.4.4: icmp_seq=137 ttl=56 time=13.652 ms<br>1444 bytes from 8.8.4.4: icmp_seq=138 ttl=56 time=133.241 ms<br>1454 bytes from 8.8.4.4: icmp_seq=139 ttl=56 time=17.463 ms<br>1464 bytes from 8.8.4.4: icmp_seq=140 ttl=56 time=12.307 ms<br>1474 bytes from 8.8.4.4: icmp_seq=141 ttl=56 time=11.987 ms<br>ping: sendto: Message too long<br>ping: sendto: Message too long<br>Request timeout for icmp_seq 142</pre><br><p>Why 1500? That&rsquo;s the default MTU for MacOS X. It&rsquo;s also the default MTU on Windows. So now we have an upper bound for your packet size assuming you actually care about packets getting through to Windows and Mac boxes without IP level fragmentation or a chance of being dropped: <strong>1472 bytes</strong>.</p><br><p>So what&rsquo;s the lower bound? Unfortunately for the routers in between your computer and the destination the IPv4 standard says <strong>576</strong>. Does this mean we have to limit our packets to 400 bytes or less? In practice, not really.</p><br><p>MacOS X lets me set MTU values in range 1280 to 1500 so considering packet header overhead, my first guess for a conservative lower bound on the IPv4 Internet today would be <strong>1200 bytes</strong>. Moving forward, in IPv6 this is also a good value, as any packet of 1280 bytes or less is guaranteed to get passed on without IP level fragmentation.</p><br><p>This lines up with numbers that I&rsquo;ve seen throughout my career. In my experience games rarely try anything complicated like attempting to discover path MTU, they just assume a reasonably conservative MTU and roll with that, something like 1000 to 1200 bytes of payload data. If a packet larger than this needs to be sent, it&rsquo;s split up into fragments by the game protocol and re-assembled on the other side.</p><br><p>And that&rsquo;s <em>exactly</em> what I&rsquo;m going to show you how to do in this article.</p><br><h2 id="fragment-packet-structure">Fragment Packet Structure</h2><br><p>Let&rsquo;s get started with implementation.</p><br><p>The first thing we need to decide is how we&rsquo;re going to represent fragment packets over the network so they are distinct from non-fragmented packets.</p><br><p>Ideally, we would like fragmented and non-fragmented packets to be compatible with the existing packet structure we&rsquo;ve already built, with as little overhead as possible in the common case when we are sending packets smaller than MTU.</p><br><p>Here&rsquo;s the packet structure from the previous article:</p><br><pre><del>[protocol id] (64 bits)</del> // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[packet type] (2 bits for 3 distinct packet types)<br>(variable length packet data according to packet type)<br>[end of packet serialize check] (32 bits)<br></pre><br><p>In our protocol we have three packet types: A, B and C.</p><br><p>Let&rsquo;s make one of these packet types generate really large packets:</p><br><pre>static const int MaxItems = 4096 * 4;<br><br>struct TestPacketB : public Packet<br>{<br>    int numItems;<br>    int items[MaxItems];<br><br>    TestPacketB() : Packet( TEST_PACKET_B )<br>    {<br>        numItems = random_int( 0, MaxItems );<br>        for ( int i = 0; i &lt; numItems; ++i )<br>            items[i] = random_int( -100, +100 );<br>    }<br><br>    template &lt;typename Stream&gt; bool Serialize( Stream &amp; stream )<br>    {<br>        serialize_int( stream, numItems, 0, MaxItems );<br>        for ( int i = 0; i &lt; numItems; ++i )<br>        {<br>            serialize_int( stream, items[i], -100, +100 );<br>        }<br>        return true;<br>    }<br>};<br></pre><br><p>This may seem somewhat contrived but these situations really do occur. For example, if you have a strategy where you send all un-acked events from server to client and you hit a burst of packet loss, you can easily end up with packets larger than MTU, even though your average packet size is quite small.</p><br><p>Another common case is delta encoded snapshots in a first person shooter. Here packet size is proportional to the amount of state changed between the baseline and current snapshots for each client. If there are a lot of differences between the snapshots the delta packet is large and there&rsquo;s nothing you can do about it except break it up into fragments and re-assemble them on the other side.</p><br><p>Getting back to packet structure. It&rsquo;s fairly common to add a sequence number at the header of each packet. This is just a packet number that increases with each packet sent. I like to use 16 bits for sequence numbers even though they wrap around in about 15 minutes @ 60 packets-per-second, because it&rsquo;s extremely unlikely that a packet will be delivered 15 minutes late.</p><br><p>Sequence numbers are useful for a bunch of things like acks, reliability and detecting and discarding out of order packets. In our case, we&rsquo;re going to use the sequence number to identify which packet a fragment belongs to:</p><br><pre><del>[protocol id] (64 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br><strong>[sequence] (16 bits)</strong><br>[packet type] (2 bits)<br>(variable length packet data according to packet type)<br>[end of packet serialize check] (32 bits)<br></pre><br><p>Here&rsquo;s the interesting part. Sure we could just add a bit <strong>is_fragment</strong> to the header, but then in the common case of non-fragmented packets you&rsquo;re wasting one bit that is always set to zero.</p><br><p>What I do instead is add a special fragment packet type:</p><br><pre>enum TestPacketTypes<br>{<br>    PACKET_FRAGMENT = 0,     // RESERVED<br>    TEST_PACKET_A,<br>    TEST_PACKET_B,<br>    TEST_PACKET_C,<br>    TEST_PACKET_NUM_TYPES<br>};<br></pre><br><p>And it just happens to be <em>free</em> because four packet types fit into 2 bits. Now when a packet is read, if the packet type is zero we know it&rsquo;s a fragment packet, otherwise we run through the ordinary, non-fragmented read packet codepath.</p><br><p>Lets design what this fragment packet looks like. We&rsquo;ll allow a maximum of 256 fragments per-packet and have a fragment size of 1024 bytes. This gives a maximum packet size of 256k that we can send through this system, which should be enough for anybody, but please don&rsquo;t quote me on this.</p><br><p>With a small fixed size header, UDP header and IP header a fragment packet be well under the conservative MTU value of 1200. Plus, with 256 max fragments per-packet we can represent a fragment id in the range [0,255] and the total number of fragments per-packet [1,256] with 8 bits.</p><br><pre><del>[protocol id] (32 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[sequence] (16 bits)<br>[packet type = 0] (2 bits)<br><strong>[fragment id] (8 bits)<br>[num fragments] (8 bits)<br>[pad zero bits to nearest byte index]<br>&lt;fragment data&gt;</strong><br></pre><br><p>Notice that we pad bits up to the next byte before writing out the fragment data. Why do this? Two reasons: 1) it&rsquo;s faster to copy fragment data into the packet via memcpy than bitpacking each byte, and 2) we can now save a small amount of bandwidth by inferring the fragment size by subtracting the start of the fragment data from the total size of the packet.</p><br><h2 id="sending-packet-fragments">Sending Packet Fragments</h2><br><p>Sending packet fragments is <em>easy</em>. For any packet larger than conservative MTU, simply calculate how many 1024 byte fragments it needs to be split into, and send those fragment packets over the network. Fire and forget!</p><br><p>One consequence of this is that if <em>any</em> fragment of that packet is lost then the entire packet is lost. It follows that if you have packet loss then sending a 256k packet as 256 fragments is not a very good idea, because the probability of dropping a packet increases significantly as the number of fragments increases. Not quite linearly, but in an interesting way that you can read more about <a href="https://www.fourmilab.ch/rpkp/experiments/statistics.html" target="_blank" rel="noopener">here</a>.</p><br><p>In short, to calculate the probability of losing a packet, you must calculate the probability of all fragments being delivered successfully and subtract that from one, giving you the probability that at least one fragment was dropped.</p><br><pre>1 - probability_of_fragment_being_delivered ^ num_fragments<br></pre><br><p>For example, if we send a non-fragmented packet over the network with 1% packet loss, there is naturally a <sup>1</sup>&frasl;<sub>100</sub> chance the packet will be dropped.</p><br><p>As the number of fragments increase, packet loss is amplified:<br><ul><br><li>Two fragments: 1 - (<sup>99</sup>&frasl;<sub>100</sub>) ^ 2 = <strong>2%</strong></li><br><li>Ten fragments: 1 - (<sup>99</sup>&frasl;<sub>100</sub>) ^ 10 = <strong>9.5%</strong></li><br><li>100 fragments: 1 - (<sup>99</sup>&frasl;<sub>100</sub>) ^ 100 = <strong>63.4%</strong></li><br><li>256 fragments: 1 - (<sup>99</sup>&frasl;<sub>100</sub>) ^ 256 = <strong>92.4%</strong></li><br></ul></p><br><p>So I recommend you take it easy with the number of fragments. It&rsquo;s best to use this strategy only for packets in the 2-4 fragment range, and only for time critical data that doesn&rsquo;t matter too much if it gets dropped. It&rsquo;s <em>definitely not</em> a good idea to fire down a bunch of reliable-ordered events in a huge packet and rely on packet fragmentation and reassembly to save your ass.</p><br><p>Another typical use case for large packets is when a client initially joins a game. Here you usually want to send a large block of data down reliably to that client, for example, representing the initial state of the world for late join. Whatever you do, don&rsquo;t send that block of data down using the fragmentation and re-assembly technique in this article.</p><br><p>Instead, check out the technique in <a href="https://gafferongames.com/post/sending-large-blocks-of-data.html" target="_blank" rel="noopener">next article</a> which handles packet loss by resending fragments until they are all received.</p><br><h2 id="receiving-packet-fragments">Receiving Packet Fragments</h2><br><p>It&rsquo;s time to implement the code that receives and processed packet fragments. This is a bit tricky because we have to be particularly careful of somebody trying to attack us with malicious packets.</p><br><p>Here&rsquo;s a list of all the ways I can think of to attack the protocol:</p><br><ul><br><li><p>Try to send out of bound fragments ids trying to get you to crash memory. eg: send fragments [0,255] in a packet that has just two fragments.</p></li><br><li><p>Send packet n with some maximum fragment count of say 2, and then send more fragment packets belonging to the same packet n but with maximum fragments of 256 hoping that you didn&rsquo;t realize I widened the maximum number of fragments in the packet after the first one you received, and you trash memory.</p></li><br><li><p>Send really large fragment packets with fragment data larger than 1k hoping to get you to trash memory as you try to copy that fragment data into the data structure, or blow memory budget trying to allocate fragments</p></li><br><li><p>Continually send fragments of maximum size (<sup>256</sup>&frasl;<sub>256</sub> fragments) in hope that it I could make you allocate a bunch of memory and crash you out. Lets say you have a sliding window of 256 packets, 256 fragments per-packet max, and each fragment is 1k. That&rsquo;s 64 mb per-client.</p></li><br><li><p>Can I fragment the heap with a bunch of funny sized fragment packets sent over and over? Perhaps the server shares a common allocator across clients and I can make allocations fail for other clients in the game because the heap becomes fragmented.</p></li><br></ul><br><p>Aside from these concerns, implementation is reasonably straightforward: store received fragments somewhere and when all fragments arrive for a packet, reassemble them into the original packet and return that to the user.</p><br><h2 id="data-structure-on-receiver-side">Data Structure on Receiver Side</h2><br><p>The first thing we need is some way to store fragments before they are reassembled. My favorite data structure is something I call a <em>sequence buffer</em>:</p><br><pre>const int MaxEntries = 256;<br><br>struct SequenceBuffer<br>{<br>    uint32_t sequence[MaxEntries];<br>    Entry entries[MaxEntries];<br>};<br></pre><br><p>Indexing into the arrays is performed with modulo arithmetic, giving us a fast O(1) lookup of entries by sequence number:</p><br><pre>const int index = sequence % MaxEntries;<br></pre><br><p>A sentinel value of 0xFFFFFFFF is used to represent empty entries. This value cannot possibly occur with 16 bit sequence numbers, thus providing us with a fast test to see if an entry exists for a given sequence number, without an additional branch to test if that entry exists.</p><br><p>This data structure is used as follows. When the first fragment of a new packet comes in, the sequence number is mapped to an entry in the sequence buffer. If an entry doesn&rsquo;t exist, it&rsquo;s added and the fragment data is stored in there, along with information about the fragment, eg. how many fragments there are, how many fragments have been received so far, and so on.</p><br><p>Each time a new fragment arrives, it looks up the entry by the packet sequence number. When an entry already exists, the fragment data is stored and number of fragments received is incremented. Eventually, once the number of fragments received matches the number of fragments in the packet, the packet is reassembled and delivered to the user.</p><br><p>Since it&rsquo;s possible for old entries to stick around (potentially with allocated blocks), great care must be taken to clean up any stale entries when inserting new entries in the sequence buffer. These stale entries correspond to packets that didn&rsquo;t receive all fragments.</p><br><p>And that&rsquo;s basically it at a high level. For further details on this approach please refer to the example source code for this article. </p><br><p><a href="https://www.patreon.com/gafferongames" target="_blank" rel="noopener">Click here to get the example source code for this article series</a>.</p><br><h2 id="test-driven-development">Test Driven Development</h2><br><p>One thing I&rsquo;d like to close this article out on.</p><br><p>Writing a custom UDP network protocol is <em>hard</em>. It&rsquo;s so hard that even though I&rsquo;ve done this from scratch at least 10 times, each time I still manage to fuck it up in a new and exciting ways. You&rsquo;d think eventually I&rsquo;d learn, but this stuff is complicated. You can&rsquo;t just write low-level netcode and expect it to just work.</p><br><p>You have to test it!</p><br><p>My strategy when testing low-level netcode is as follows:</p><br><ul><br><li><p>Code defensively. Assert everywhere. These asserts will fire and they&rsquo;ll be important clues you need when something goes wrong.</p></li><br><li><p>Add functional tests and make sure stuff is working as you are writing it. Put your code through its paces at a basic level as you write it and make sure it&rsquo;s working as you build it up. Think hard about the essential cases that need to be property handled and add tests that cover them.</p></li><br><li><p>But just adding a bunch of functional tests is not enough. There are of course cases you didn&rsquo;t think of! Now you have to get really mean. I call this soak testing and I&rsquo;ve never, not even once, have coded a network protocol that hasn&rsquo;t subsequently had problems found in it by soak testing.</p></li><br><li><p>When soak testing just loop forever and just do a mix of random stuff that puts your system through its paces, eg. random length packets in this case with a huge amount of packet loss, out of order and duplicates through a packet simulator. Your soak test passes when it runs overnight and doesn&rsquo;t hang or assert.</p></li><br><li><p>If you find anything wrong with soak testing. You may need to go back and add detailed logs to the soak test to work out how you got to the failure case. Once you know what&rsquo;s going on, stop. Don&rsquo;t fix it immediately and just run the soak test again.</p></li><br><li><p>Instead, add a unit test that reproduces that problem you are trying to fix, verify your test reproduces the problem, and that it problem goes away with your fix. Only after this, go back to the soak test and make sure they run overnight. This way the unit tests document the correct behavior of your system and can quickly be run in future to make sure you don&rsquo;t break this thing moving forward when you make other changes.</p></li><br><li><p>Add a bunch of logs. High level errors, info asserts showing an overview of what is going on, but also low-level warnings and debug logs that show what went wrong after the fact. You&rsquo;re going to need these logs to diagnose issues that don&rsquo;t occur on your machine. Make sure the log level can be adjusted dynamically.</p></li><br><li><p>Implement network simulators and make sure code handles the worst possible network conditions imaginable. 99% packet loss, 10 seconds of latency and +/- several seconds of jitter. Again, you&rsquo;ll be surprised how much this uncovers. Testing is the time where you want to uncover and fix issues with bad network conditions, not the night before your open beta.</p></li><br><li><p>Implement fuzz tests where appropriate to make sure your protocol doesn&rsquo;t crash when processing random packets. Leave fuzz tests running overnight to feel confident that your code is reasonably secure against malicious packets and doesn&rsquo;t crash.</p></li><br><li><p>Surprisingly, I&rsquo;ve consistently found issues that only show up when I loop the set of unit tests over and over, perhaps these issues are caused by different random numbers in tests, especially with the network simulator being driven by random numbers. This is a great way to take a rare test that fails once every few days and make it fail every time. So before you congratulate yourself on your tests passing 100%, add a mode where your unit tests can be looped easily, to uncover such errors.</p></li><br><li><p>Test simultaneously on multiple platforms. I&rsquo;ve never written a low-level library that worked first time on MacOS, Windows and Linux. There are always interesting compiler specific issues and crashes. Test on multiple platforms as you develop, otherwise it&rsquo;s pretty painful fixing all these at the end.</p></li><br><li><p>This about how people can attack the protocol. Implement code to defend against these attacks. Add functional tests that mimic these attacks and make sure that your code handles them correctly.</p></li><br></ul><br><p>This is my process and it seems to work pretty well. If you are writing a low-level network protocol, the rest of your game depends on this code working correctly. You need to be absolutely sure it works before you build on it, otherwise it&rsquo;s basically a stack of cards.</p><br><p>In my experience, game neworking is hard enough without having suspicions that that your low-level network protocol has bugs that only show up under extreme network conditions. That&rsquo;s exactly where you need to be able to trust your code works correctly. <strong>So test it!</strong></p>



<h1 id="译文">译文</h1>


<p><a href="http://gad.qq.com/program/translateview/7164496" target="_blank" rel="noopener">译文出处</a></p>
<div class="WordSection1"><b><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34); font-size: 12pt;">译者：崔嘉艺</span><span style="color: rgb(34, 34, 34); font-size: 12pt;">(milan21) </span><span style="color: rgb(34, 34, 34); font-size: 12pt;">审校：崔国军（星际迷航）</span></span></b><div><span style="color: rgb(34, 34, 34); font-size: 12pt;"><span style="font-family:微软雅黑;"><br></span></span></div><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">大家好，我是格伦·菲德勒。欢迎大家阅读系列教程《构建游戏网络协议》的第三篇文章。</span><span style="color: rgb(34, 34, 34); font-size: 12pt;">在之前的文章中，我们讨论了如何将数据包的读取和写入用一个单独的序列化函数来实现。</span></span></p><p class="MsoNormal" align="left"><span style="color: rgb(34, 34, 34); font-size: 12pt;"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在我们要开始把一些有趣的事情放到这些数据包中，<span>,</span>但正如你即将开始编码的令人惊叹的多人在线动作、第一人称射击、大型多人在线角色扮演游戏、多人在线战术竞技游戏会发生的那样，当你以每秒<span>120</span>次的频率发送<span>8k</span>大小的数据包，游戏网络中会传来一个声音呼喊着你<span>:</span></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">“</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">不要发送超过<span>1200</span>字节大小的数据包<span>!”</span></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">但是都已经<span>2016</span>年了，你真的要注意最大传输单元这个东西么<span>?</span></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">不幸的是，答案是是的！</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><h2 id="最大传输单元MTU"><span style="font-family:微软雅黑;">最大传输单元MTU</span></h2><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">你可能已经听说过最大传输单元了。在网络程序员中流传着大量有关最大传输单元问题的故事。那么这到底是怎么回事呢？究竟什么是最大传输单元<span>?</span>为什么你要在乎最大传输单元这个事情？</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">当你通过互联网来发送数据包的时候到底背后发生了什么？这些数据包要从一台计算机<span>(</span>路由器<span>)</span>跳到另一个计算机<span>(</span>路由器<span>)</span>上，如此往复多次才能到达自己的目的地。这是一个分组交换网络具体如何运作的方式。在大部分时间里，它的工作方式不像是在源和目的地之间存在一条直接的连接。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">但意外的是：每台计算机<span>(</span>路由器<span>)</span>会沿着路由强制要求数据包的大小会有一个最大的上限，这个上限就是所谓的最大传输单元。如果任意一个路由器收到一个数据包的大小超过这个最大传输单元的大小，它有这么两个选择，<span>a)</span>在<span>IP</span>层对这个数据包进行分包，并将分包后的数据包继续传递，<span>b)</span>丢弃这个数据包然后告诉你数据包被丢弃了，你自己负责摆平这个问题。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这儿有一个我会经常遇到的情况。人们在编写多人在线游戏的时候，数据包的平均大小都会非常的小，让我们假设下，这些数据包的平均大小大概只有几百字节，但时不时会在他们的游戏中同时发生大量的事情并且发出去的数据包会出现丢失的情况，这个时候数据包会比通常的情况下要大。突然之间，游戏的数据包的大小就会超过最大传输单元的大小，这样就只有很少一部分玩家能够收到这个数据包，然后整个通信就崩溃了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span><br></span>就在去年<span>(2015</span>年<span>)</span>，我与亚历克斯<span>·</span>奥斯汀在<span>Indiecade</span>谈论他的游戏<span>” </span></span><span><a rel="noopener" href="http://subrosagame.com/" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;">Sub Rosa</span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);"> “</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">中的网络部分。他遇到了一些奇怪的无法重现的网络<span>bug</span>。出于某种原因，一些客户端（在所有玩家里面总是有那么一个或者两个）会随机的从游戏中断开连接并且其他人都能够正常游戏。查看日志的话，亚历克斯又觉得一切都是正常的，只是看上去好像数据包突然停止进行传递了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><span><br></span>对我来说，这听上去就像是一个最大传输单元所引起的问题，并且我非常确信。当亚历克斯把他最大的数据包大小限制在一个合理的值之内，这个<span>bug</span>就再也没有出现了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><h2 id="真实世界中的最大传输单元MTU"><span style="font-family:微软雅黑;">真实世界中的最大传输单元MTU</span></h2><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以什么是“一个合理的数据包的大小”？</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">在今天的互联网上<span>(2016</span>年，还是基于<span>IPv4)</span>，典型的最大传输单元的大小是<span>1500</span>字节。在<span>UDP/IP</span>数据包的包头添加或者去掉几个字节，你会发现在数据包开始出现被丢弃或者被分包情况的一个典型的边界值是<span>1472</span>。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">你可以自己在<span>MacOS X</span>尝试运行下下面这个命令：</span></span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">ping-g 56 -G 1500 -h 10 -D 8.8.4.4</span></span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">在我的机器上，这个结果在略微低于<span>1500</span>字节的大小上下浮动，符合预期：</span></span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1404bytes from 8.8.4.4: icmp_seq=134 ttl=56 time=11.945 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1414bytes from 8.8.4.4: icmp_seq=135 ttl=56 time=11.964 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1424bytes from 8.8.4.4: icmp_seq=136 ttl=56 time=13.492 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1434bytes from 8.8.4.4: icmp_seq=137 ttl=56 time=13.652 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1444bytes from 8.8.4.4: icmp_seq=138 ttl=56 time=133.241 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1454bytes from 8.8.4.4: icmp_seq=139 ttl=56 time=17.463 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1464bytes from 8.8.4.4: icmp_seq=140 ttl=56 time=12.307 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1474bytes from 8.8.4.4: icmp_seq=141 ttl=56 time=11.987 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">ping:sendto: Message too long</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">ping:sendto: Message too long</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">Requesttimeout for icmp_seq 142</span></span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">为什么是<span>1500</span>字节？这是<span>MacOS X</span>上默认的最大传输单元的大小。这也是<span>Windows</span>平台上默认的最大传输单元的大小。所以现在我们对数据包的大小有了一个上限（也就是不能超过这个默认的最大传输单元的大小），假如你真的关心数据包通过<span>Windows</span>平台或者<span>Mac</span>平台进行传播而不希望数据包在<span>IP</span>层进行分包或者有被丢弃的可能的话，那么就要保证数据包的大小不能超过这个上限：<span>1472</span>个字节。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">那么这个最大传输单元的大小的下限是多少呢？<span>MacOS X</span>允许设置的最大传输单元的大小的值是在<span>1280</span>到<span>1500</span>，所以我对现在互联网上通过<span>IPv4</span>进行传播的数据包的最大传输单元的大小的下限有一个比较保守的估计，就是<span>1200</span>字节。如果是在通过<span>IPv4</span>进行传播的情况下这个比较保守的大传输单元的大小的下限也会是一个很好的估计值，任意数据包只要大小小于<span>1280</span>字节都能保证在没有<span>IP</span>层分包的情况下顺利的传播。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这个估计与我在职业生涯中感受到的情况是比较一致的。以我的经验来看，很少有游戏会试图做这些复杂的事情，诸如尝试发现路径上的最大传输单元的大小之类的，它们一般都是假定一个合理又保守的最大传输单元的大小然后一直遵循这个值。如果出现一个要发送的数据包比这个保守的最大传输单元的大小要大的情况，游戏协议会将这个数据包分成几个包然后在网络的另外一侧进行重组。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">而这正是我要在这篇文章里面要向你传授的内容。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="分包后的数据包的结构"><span style="color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;font-size:x-large;">分包后的数据包的结构</span></span></h2><p></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们从决定该对网络上传输的数据分包后采用什么的结构进行表示来开始构建我们的数据包分包和重组机制。在理想状态下，我们希望分包以后的数据包和未分包的数据包兼容我们现在已经建立好的数据包结构，这样当我们发送小于最大传输单元的大小的数据包的时候，网络协议没有任何多余的负载。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">下面是在前一篇文章结束的时候得到的数据包的结构：</span></span></p><br><br><pre><del>[protocol id] (64 bits)</del> // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[packet type] (2 bits for 3 distinct packet types)<br>(variable length packet data according to packet type)<br>[end of packet serialize check] (32 bits)<br></pre><br><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">在我们这个例子之中，我们一共有三个数据包的类型，分别是Ａ、Ｂ和Ｃ。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们用这三个数据包类型中的一个制造一个比最大传输单元的大小还要大一些的数据包：</span></span></p><div><div id="highlighter_44479" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;">1</span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;">2</span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;">3</span></div><div class="line number4 index3 alt1"><span style="font-family:微软雅黑;">4</span></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;">5</span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;">6</span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;">7</span></div><div class="line number8 index7 alt1"><span style="font-family:微软雅黑;">8</span></div><div class="line number9 index8 alt2"><span style="font-family:微软雅黑;">9</span></div><div class="line number10 index9 alt1"><span style="font-family:微软雅黑;">10</span></div><div class="line number11 index10 alt2"><span style="font-family:微软雅黑;">11</span></div><div class="line number12 index11 alt1"><span style="font-family:微软雅黑;">12</span></div><div class="line number13 index12 alt2"><span style="font-family:微软雅黑;">13</span></div><div class="line number14 index13 alt1"><span style="font-family:微软雅黑;">14</span></div><div class="line number15 index14 alt2"><span style="font-family:微软雅黑;">15</span></div><div class="line number16 index15 alt1"><span style="font-family:微软雅黑;">16</span></div><div class="line number17 index16 alt2"><span style="font-family:微软雅黑;">17</span></div><div class="line number18 index17 alt1"><span style="font-family:微软雅黑;">18</span></div><div class="line number19 index18 alt2"><span style="font-family:微软雅黑;">19</span></div><div class="line number20 index19 alt1"><span style="font-family:微软雅黑;">20</span></div><div class="line number21 index20 alt2"><span style="font-family:微软雅黑;">21</span></div><div class="line number22 index21 alt1"><span style="font-family:微软雅黑;">22</span></div><div class="line number23 index22 alt2"><span style="font-family:微软雅黑;">23</span></div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">static</code> <code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">MaxItems = 4096 * 4;</code></span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;"> </span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">struct</code> <code class="cpp plain">TestPacketB : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">protocol2::Packet</code></span></div><div class="line number4 index3 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">{</span></code></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numItems;</code></span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">items[MaxItems];</code></span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;"> </span></div><div class="line number8 index7 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TestPacketB() : Packet( TEST_PACKET_B )</code></span></div><div class="line number9 index8 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">{</code></span></div><div class="line number10 index9 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp plain">numItems = random_int( 0, MaxItems );</code></span></div><div class="line number11 index10 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; numItems; ++i )</code></span></div><div class="line number12 index11 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">            </code><code class="cpp plain">items[i] = random_int( -100, +100 );</code></span></div><div class="line number13 index12 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">}</code></span></div><div class="line number14 index13 alt1"><span style="font-family:微软雅黑;"> </span></div><div class="line number15 index14 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp keyword bold">template</code> <code class="cpp plain">&lt;</code><code class="cpp keyword bold">typename</code> <code class="cpp plain">stream</code><code class="cpp string"></code><code class="cpp plain">&gt; </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></span></div><div class="line number16 index15 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">{</code></span></div><div class="line number17 index16 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp plain">serialize_int( stream, numItems, 0, MaxItems );</code></span></div><div class="line number18 index17 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; numItems; ++i )</code></span></div><div class="line number19 index18 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">            </code><code class="cpp plain">serialize_int( stream, items[i], -100, +100 );</code></span></div><div class="line number20 index19 alt1"><span style="font-family:微软雅黑;"> </span></div><div class="line number21 index20 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></span></div><div class="line number22 index21 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">}</code></span></div><div class="line number23 index22 alt2"><span style="font-family:微软雅黑;"><code class="cpp plain">};</code><code class="cpp keyword bold"></code><code class="cpp plain"></code></span></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><br></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这可能看起来不怎么自然，但在现实世界中这些情况真的会发生。举个简单的例子来说，如果你有一个策略，这个策略是从服务器往客户端发送所有的未确认的事件，你会得到一组可信赖也有序的事件，但是也会遇到大量数据包的丢失的情况，你会轻易的遇到数据包比最大传输单元的大小还要大的情况，即使你的数据包的平均大小非常小。（译注：这是由于丢包重传导致的不停重发，而重发的数据包在<span>UDP</span>或者<span>TCP</span>上会进行合并。所以即使数据包的平均大小远小于最大传输单元的大小，但是由于大量这样的数据包的合并，还是很容易出现超过最大传输单元的大小的情况）。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">在大多数的情况下，通过实现这么一个策略：在一个数据包里面只包含很少一组事件或者状态更新来避免数据包的大小超过最大传输单元的大小，采用这种策略以后可以有效的规避上面的那种情况。这种规划在很多情况下都工作的很棒。。。但是有一种情况下这种策略也是存在问题的，这种情况就是增量编码。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">由一个增量编码器创建的数据包的大小是与当前状态与之前状态之间所发生的状态变化的数量成正比的。如果这两个状态之间有大量的不同的话，那么增量也将很大并且你对这种情况其实是没有什么办法的。如果出现一个增量恰好比最大传输单元的大小要大的情况，当然这是一个坏运气下才会出现的情况，但是你仍然要发送这个超过最大传输单元的大小的数据包！所以你可以看到，在增量编码的情况下，你真的不能限制数据包的最大大小一定小于最大传输单元的大小，在这种情况下，数据包的分包和重组策略就有了用武之地。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们回到数据包的结构上面来。在每个数据包的包头的地方添加一个序号是一种非常常见的做法。这并没有什么复杂的。这只是一个数据包的序号，会在每个数据包进行发送的时候依次加一。举个例子来说，就是<span>0</span>、<span>1</span>、<span>2</span>、<span>3</span>这么简单。我喜欢用<span>16</span>比特来表示这个序号，即使在每秒发送<span>60</span>个数据包的情况下，只要<span>15</span>分钟序号就会被用完一遍，需要再次从头开始重用，但是这么做也没有什么关系，主要是因为你在网络上收到一个<span>15</span>分钟之前发送出去的数据包是一个非常罕见的事情，所以你很少会有机会困惑这到底是一个新的数据包还是一个旧的数据包（因为<span>IP</span>层在包头的地方有个跳转计数，超出一定跳转次数的数据包会被丢弃掉，所以基本不用担心这种情况）。如果你确实关心这个问题的话，请使用<span>32</span>比特的序号进行代替。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">无论你选择用多少比特来表示这个序号，它们对于很多事情都是有用的，比如说可依赖性、检测和丢弃乱序的数据包等等。除此之外，我们需要一个数据包序号的原因是在对数据包进行分包的时候，我们需要某个方法来确定这个数据包的分包到底是属于哪个数据包的。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以，让我们在我们的数据包的结构里面加上序号这个东西：</span></span></p><br><br><pre><del>[protocol id] (64 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br><strong>[sequence] (16 bits)</strong><br>[packet type] (2 bits)<br>(variable length packet data according to packet type)<br>[end of packet serialize check] (32 bits)<br></pre><br><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这是最有趣的部分。我们可以在数据包的头部只添加一个比特的标识<span> is_fragment</span>，但是对于通常情况下根本不需要分包的数据包来说，你就浪费了一个比特，因为它总是要被置为<span>0</span>。这不是很好。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">相反，我的选择是在数据包的结构里面添加了一个特殊的<span>”</span>分包后的数据包<span>“</span>的类型：</span></span></p><div><div id="highlighter_815496" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;">1</span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;">2</span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;">3</span></div><div class="line number4 index3 alt1"><span style="font-family:微软雅黑;">4</span></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;">5</span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;">6</span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;">7</span></div><div class="line number8 index7 alt1"><span style="font-family:微软雅黑;">8</span></div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">enum</code> <code class="cpp plain">TestPacketTypes</code></span></div><div class="line number2 index1 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">{</span></code></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">PACKET_FRAGMENT = 0,     </code><code class="cpp comments">// RESERVED</code></span></div><div class="line number4 index3 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TEST_PACKET_A,</code></span></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TEST_PACKET_B,</code></span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TEST_PACKET_C,</code></span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TEST_PACKET_NUM_TYPES</code></span></div><div class="line number8 index7 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">};</span></code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="color: rgb(34, 34, 34); font-size: 12pt;"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这恰好不需要占据任何的空间，是因为四个数据包类型正好可以用两个比特来表示，而这两个比特的空间已经用于表示数据包类型了，我们只是在原来的枚举上新加了一个类型。这么处理以后，每次当我们读取一个数据包的时候，如果这个数据包的类型是<span>0</span>的话，我们就知道这个数据包是一个特殊的分包以后的数据包，它的内存布局可以通过数据包的类型得知，否则的话，我们就走回原来的通用的对非分包的数据包进行读取和处理的方法。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们设计下这个分包后的数据包看起来应该是什么样子的。我们将允许一个数据包最多可以分成<span>256</span>个数据包，并且每个分包后的数据包的大小不会超过<span>1024</span>个字节。这样的话，我们就可以通过这样一个系统来发送大小最大为<span>256k</span>的数据包，这对于任意系统任意情况来说都应该是足够的，但是这只是我个人的一个看法，如果有特殊的情况，还请结合实际情况进行具体分析。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">有了这么一个不大的固定大小的数据包包头结构，再加上<span>UDP</span>的包头结构以及<span>IP</span>的包头结构，一个分包以后的数据包会小于之前我们保守估计的最大传输单元的大小：<span>1200</span>字节。除此之外，因为一个数据包最多可以分包成<span>256</span>个数据包，我们可以用【<span>0</span>，<span>255</span>】这个范围来表示分包的<span>id</span>和序号，这样每个分包里面还需要有<span>8</span>比特来表示这个序号。</span></span></p><br><br><pre><del>[protocol id] (32 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[sequence] (16 bits)<br>[packet type = 0] (2 bits)<br><strong>[fragment id] (8 bits)<br>[num fragments] (8 bits)<br>[pad zero bits to nearest byte index]<br>&lt;fragment data&gt;</strong><br></pre><br><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">请注意，我们把这几个比特对齐到了下一个字节，然后才把对齐以后的数据写入到数据包里面。我们为什么要这么做？这么做其实是有两个原因的<span>: 1) </span>这么处理以后可以通过<span>memcpy</span>函数更快的把分包的数据拷贝到数据包里面而不需要使用位打包器来对每个字节进行处理。<span>2) </span>我们通过不发送分包数据的大小节省了一小部分带宽。我们可以通过从数据包的整体大小减去分包数据起始位置的字节序号来推断出这个分包的大小。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="发送分包以后的数据包"><span style="color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;font-size:x-large;">发送分包以后的数据包</span></span></h2><p></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">发送分包以后的数据包是一件非常容易的事情。如果数据包的大小小于保守估计的最大传输单元的大小。那么就按正常的方法进行发送。否则的话，就计算这个数据包到底该分成多少个<span>1024</span>字节的数据包分包，然后构建这些分包并按照之前发送正常数据包的方法进行发送。发送出去以后也不记录发送的数据包的内容，这没什么困难的！</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这种发送以后不记录发送的数据包的内容的方法有一个后果，就是数据包的任意一个分包如果丢失的话，那么整个数据包就都要丢弃。由此可见，当你需要发送要给<span>256K</span>的数据包的时候要发送<span>256</span>个分包，如果有一个分包丢失的话，你就要重新把这个<span>256k</span>的数据包再分一次包然后再发送出去。这绝对不是一个好主意。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这显然是一个很糟糕的办法，因为随着分包数目的增多，发生丢失的概率肯定是显著的增大。这种增长关系不是线性的，而是一种相当复杂的关系，如果你对这个计算感兴趣的话，你可以读下<a rel="noopener" href="http://www.fourmilab.ch/rpkp/experiments/statistics.html" target="_blank">这篇文章</a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">简而言之，如果你要计算一个数据包会被丢弃的概率，你必须要计算所有分包被成功发送到目的地的概率，然后从<span>1</span>中减去这个概率，得到的结果就是至少有一个分包丢失的概率。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">下面这个公式可以用来计算因为分包丢失导致整个数据包被丢弃的概率：</span></span></p><p class="MsoNormal" align="left" style="margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 10pt; color: rgb(40, 40, 40);"><span style="font-family:微软雅黑;">＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼</span></span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1- ( probability of fragment being delivered ) ^ num_fragments</span></span></p></div><p class="MsoNormal" align="left" style="margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 10pt; color: rgb(40, 40, 40);"><span style="font-family:微软雅黑;">＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们举个简单的例子对上面这个公式进行说明，如果我们发送的一个不需要分包的数据包，如果它在网络上传说的时候丢失的概率是<span>1%</span>，那么只有百分之一的概率会出现这个数据包被丢弃的情况，或者我们不要嫌麻烦，把这些数据代入到上面这个公式里面<span>: 1 – (99/100) ^ 1 = 1/100 = 1%</span>。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">随着分包数量的增加，整个数据包被丢弃的概率也随之增加：</span></span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">两个分包的情况：<span> 1 – (99/100) ^ 2 = <b><span style="border:none windowtext 1.0pt;     padding:0cm">2%</span></b></span><b><span style="border:none windowtext 1.0pt;     padding:0cm">。</span></b></span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">十个分包的情况：<span> 1 – (99/100) ^ 10 = <b><span style="border:none windowtext 1.0pt;     padding:0cm">9.5%</span></b></span><b><span style="border:none windowtext 1.0pt;     padding:0cm">。</span></b></span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">一百个分包的情况：<span> 1 – (99/100) ^ 100 = <b><span style="border:none windowtext 1.0pt;     padding:0cm">63.4%</span></b></span><b><span style="border:none windowtext 1.0pt;     padding:0cm">。</span></b></span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">二百五十六个分包的情况：<span> 1 – (99/100) ^ 256 = <b><span style="border:none windowtext 1.0pt;     padding:0cm">92.4%</span></b></span><b><span style="border:none windowtext 1.0pt;     padding:0cm">。</span></b></span></span></li></ul><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以我建议你要小心分包以后的数量。这个策略最好是只对<span>2-4</span>个分包的情况进行使用，而且最好是针对那种对时间不怎么敏感的数据使用或者是就算分包lost了也无所谓的情况。绝对不要只是为了省事就把一大堆依赖顺序的事件打到一个大数据包里面然后依赖数据包的分包和重组机制进行发送。这会让事情变得更加麻烦。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">大数据包的另外一种典型的用途是当客户端新连入一个游戏服务器的时候。游戏服务器通常会把大块的数据以一种可靠的方式下发给客户端。对于后期才加入的客户端而言，这些大块的数据也许代表了世界的初始状态。无论这些数据包含了怎么样的信息，请不要使用本篇文章的分包技巧来给客户端下发大块的数据。相反，请查阅这个系列教程的下篇文章，在那篇文章里面将讲解如何在有数据包可能发生丢失的情况下，快速可靠的发送大块的数据直到这些大块的数据完全被确认接收。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="对分包后的数据包的接收"><span style="color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;font-size:x-large;">对分包后的数据包的接收</span></span></h2><p></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">尽管发送分包以后的数据包是一件相同简单的事情，但是对分包后的数据包进行接收就相对需要技巧了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">之所以对分包后的数据包进行接收很困难的原因是我们不仅需要给缓冲区建立一个数据结构还要把这些分包重组成原始的数据包，我们也要特别小心如果有人试图让我们的程序产生崩溃而给我们发送恶意的数据包。</span></span></p><br><br><pre><del>[protocol id] (32 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[sequence] (16 bits)<br>[packet type = 0] (2 bits)<br><strong>[fragment id] (8 bits)<br>[num fragments] (8 bits)<br>[pad zero bits to nearest byte index]<br>&lt;fragment data&gt;</strong><br></pre><br><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">下面列出的是我能想到的如何攻击你的协议以便让你的服务器崩溃的所有方法：</span></span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">尝试发送分包<span>ID</span>在一个限制范围内的分包，看看能不能让你的程序崩溃。举个例子来说，也许这个数据包只有两个分包，但是我会发送多个分包<span>ID</span>在【０，２５５】之内的分包。</span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">发送一个数据包，让我们假设这个书包的最大分包数量是<span>2</span>，然后发送多个属于这个数据包的分包，但是在分包的数据包报头里面把最大分包的数量改为<span>256</span>，来希望你在接收完第一个分包以后，不会发现分包的最大数量信息被改变了，这样就有可能造成你的内存崩溃。</span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">发送非常大的分包，让分包里面的数据超过<span>1k</span>，测试下你在试图把分包数据拷贝到数据结构的时候是否有良好的判断，如果没有良好的判断的话，这也许会让你的内存崩溃，或者占用大量的内容让你在分配新的分包的时候没有空间。 </span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">持续的给你的程序发送最大分包数目的分包（也就是如果最大分包数目是<span>256</span>的话，就持续不断的发送分包<span>ID</span>是<span>256</span>的数据包），希望你会分配大量的内容来容纳这些分包然后让你的内存崩溃。让我们假设你的程序中有一个滑动窗口，这个滑动窗口有<span>256</span>个数据包，每个数据包最多可以有<span>256</span>个分包，每个分包预留的空间是<span>1k</span>。那么也就是会给每个客户端预留<span>67,108,864</span>字节或者<span>64mb</span>的空间。我可以通过这种方法让服务器崩溃么？我能用一堆大小有趣的分包来耗尽的你地址空间的<span>heap</span>空间么？因为服务器的程序是你来设计实现的，所以只有你才知道这个问题的确切答案。它取决于你的内存预算以及如何分配内存来存储分包。如果你考虑过了觉得这会是一个问题，那么就限制下缓冲区中分包的数目或考虑减少每个数据包的分包的最大数目。考虑给每个分包静态分配数据结果或者使用一个内存池来减少内存碎片。</span></span></li></ul><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以你可以看到，在接收端代码是非常脆弱的，要非常小心检查一切可能的情况。除此之外，还有一个非常简单的事情要注意：让分包保存在一个数据结构里面，当一个数据包的所有分包都到达以后（通过计数来判断是否全部到达），将这些分包重组成一个大的数据包，并把这个重组后的大数据包返回给接收方。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">什么样的数据结构在这里是有意义的<span>?</span>这里并没有什么特别的数据结构<span>!</span>我使用的是一种我喜欢称之为序列缓冲区的东西。我想和你分享的最核心的技巧是如何让这个数据结构变得高效：</span></span></p><div><div id="highlighter_81070" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;">1</span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;">2</span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;">3</span></div><div class="line number4 index3 alt1"><span style="font-family:微软雅黑;">4</span></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;">5</span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;">6</span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;">7</span></div><div class="line number8 index7 alt1"><span style="font-family:微软雅黑;">8</span></div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">MaxEntries = 256;</code></span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;"> </span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">struct</code> <code class="cpp plain">SequenceBuffer</code></span></div><div class="line number4 index3 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">{</span></code></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">exists[MaxEntries];</code></span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t sequence[MaxEntries];</code></span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">Entry entries[MaxEntries];</code></span></div><div class="line number8 index7 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">};</span></code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-family:微软雅黑;"><br></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这里面有几件事情值得注意。首先，使用类似数组的结构可以允许对给定条目是否存在于一个序列缓冲区的存在性进行快速测试并且将测试结果进行缓存，即使每个数据包的条目结构是非常大的（而且这种结构对于数据包的分包和重组来说是非常棒的）。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">那么我们该如何使用这个数据结构？当你接收到一个分包以后的数据包以后，这个数据包会携带一个序号指定它是属于哪个数据包的分包。这个序号会随着发送而不停的增大<span>(</span>所有序号全部用完导致发生环绕除外<span>)</span>， 所以最关键的技巧是你要对序号进行散列让散列后的序号进入一个数组中某个给定的位置，具体处理过程如下所示：</span></span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">int index = sequence % MaxEntries;</span></span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">现在你可以用<span>O(1)</span>的时间复杂度进行一个快速测试，来通过序号看下一个给定的条目是否存在，并且判断下这个条目是否和你想要读取或者写入的数据包序号相匹配。也就是说，你既需要测试存在性又需要测试序号是否是预期的序号，这是因为所有的序号都是有效的数字<span>(</span>比如说是<span>0)</span>，还有就是因为根据一个特定的数据包序号查找到的条目可能是存在的，但是它属于过去的一个序号（比如说，这是某个其他的序号，但是恰巧通过取模的计算得到相同的序号）。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以当一个新的数据包的第一个分包到达的时候，你需要把数据包的序号散列成一个索引，如果发现这个索引对应的内容还不存在的话，你需要设置<span>exists[index] = 1</span>，并设置<span>sequence[index]</span>来匹配你正在处理的数据包，并把这个分包储存在序号缓冲区对应的条目里面。这样当下一次有分包实际到达的时候，你会得到相同的序号，然后得到一个相当的索引，在查找的时候会发现对应这个索引的内容已经存在了，并且这个条目的序号正好能和刚刚接收到的数据包的序号匹配，所以你就可以把这个分包累加到这个条目上，这个过程会一直重复直到这个数据包的所有分包都被接收到为止。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">如果从比较抽象的层次来解释这个事情的话，基本原理大概就是这样的。这种方法的一个更完整的解释请参阅本文的示例源代码。在地址<span><a href="https://www.patreon.com/gafferongames" target="_blank" rel="noopener">https://www.patreon.com/gafferongames</a></span>可以获取本系列文章示例的源代码。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="网络协议的测试驱动开发"><span style="color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;font-size:x-large;">网络协议的测试驱动开发</span></span></h2><p></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">还有一件事情我想在文章的末尾进行补充说明。我感觉如果我不向我的读者提及这个方法的话，就是对他们的一个伤害。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">编写一个定制的网络协议是非常困难的。这个过程是如此的苦难以至于我从头开始至少编写了<span>10</span>次网络协议，但是每次我都觉得我在用一种全新的有趣的方法在做这个事情。也许你会认为是我在挑战自己，用一些新奇的方法来实现这个过程，但其实是这个过程太复杂了，完全没有办法按照预期的那样写完代码就期待它们能够正确的工作。你需要对写出来的代码进行测试！</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">当编写底层网络协议层的代码的时候，我的策略是<span>:</span></span></span></p><p style=" margin: 6pt 0cm 6pt 21pt ; ; ; ; "><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">1、</span><span style="color: rgb(34, 34, 34);">防御性编程。在一切可能的地方进行断言。当某些地方出现错误的时候这些断言会起作用，并且将成为查找问题的重要线索。</span></span></p><p style=" margin: 6pt 0cm 6pt 21pt ; ; ; ; "><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">2、</span><span style="color: rgb(34, 34, 34);">添加函数的功能测试，确保它们是如你的预期那样工作的。把你的代码放到一个可以运行和测试的环境下，这样可以不时地对它们进行测试以便可以确保它一直会像你起初创建它们时候那样良好的工作。仔细考虑有哪些情况需要正确的处理并给这些情况添加测试。</span></span></p><p style=" margin: 6pt 0cm 6pt 21pt ; ; ; ; "><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">3、</span><span style="color: rgb(34, 34, 34);">虽然函数测试非常有必要，但是只是添加一些函数测试是远远不够的。无论如何都有遇到你没有预料到的情况<span>! </span>现在你必须把它们放到一个真实的环境下看看到底会发生什么。我把这个称之为浸泡测试，并且在我之前编写网络协议的过程中还从来没有过在浸泡测试的过程中没有发现问题的情况。浸泡测试只是在不停的循环，并会随机的做一些事情让你的系统在它的空间中处理一些情况，让我们举些简单的例子对它进行一些简单的说明，比如说构造出随机长度的数据包，而且这些数据包有一个非常高的丢失率，通过数据包模拟器发出的大量乱序并且重复的数据包等等。如果你的程序能够在一晚上的时间里面不挂起或者遇到断言，那么就算你的程序通过了浸泡测试。</span></span></p><p style=" margin: 6pt 0cm 6pt 21pt ; ; ; ; "><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">4、</span><span style="color: rgb(34, 34, 34);">如果你的程序在浸泡测试的过程中发现了某些问题。你可能需要在代码里面添加一些详细的日志以便下次在浸泡测试的时候如果遇到了同样的问题你可以找到出现问题的原因。一旦你知道发生了什么，就可以停止了。不要立即的修复这个问题并且再次运行浸泡测试。这种做法非常的愚蠢。相反，利用单元测试来不停的重现你需要修复的问题，确保单元测试能够重现问题，而且这个问题因为你的修复已经彻底修好了。只有在这样的处理流程之后，才能回到浸泡测试并确保程序在浸泡测试能正常运转一整夜。通过这种方式，单元测试能够记录你的系统的正确的行为并且在以后需要的时候可以快速的运行起来，确保当你做其他改变的时候不会导致一些原来修过的问题重复的出现。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这就是我的数据包分包和重组的处理流程了，它似乎工作的不错。如果你在进行一些底层的网络协议的设计，你的游戏的其他的部分将依赖于底层的网络协议的设计。在你继续构建其他的功能之前，你需要绝对的确认底层的网络协议是否能够正常的工作，否则就像一堆胡乱堆积的卡片，很容易就散架了。多人在线游戏的网络部分是非常困难的，如果不小心设计的话，很容易就会出现底层网络协议可能无法正常的工作或者存在缺陷。所以请确保你是知道你的底层网络协议是如何工作的！</span></span></p><b><span style="font-size: 12pt; line-height: 156%; font-weight: normal;"><span style="font-family:微软雅黑;">即将到来的文章的预告</span></span></b><div><span style="font-size: 12pt; line-height: 156%; font-weight: normal;"><span style="font-family:微软雅黑;"><br></span></span></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">下一篇文章是<span>: </span>《发送大块的数据》</span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">请继续阅读本系列的下一篇文章，在哪篇文章里面我将向你展示如何通过数据包快速可信赖的发送大块的数据，如果其中一块数据丢失了也不需要丢弃整个数据包！</span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">如果你觉得这篇文章有价值的话，请在<span>patreon</span>上支持我的写作，这样我会写的更快。你可以在<span>BSD 3.0</span>许可下访问到这篇文章里面的代码。非常感谢你的支持！</span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">【版权声明】</span></span></p><p class="MsoNormal"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;"> </span></span></p></div>                    <br>                

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/02/25/serialization_strategies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/25/serialization_strategies/" itemprop="url">构建游戏网络协议二之序列化策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-25T17:13:35+00:00">
                2017-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          <h1 id="自我总结本篇概要"><a href="#自我总结本篇概要" class="headerlink" title="自我总结本篇概要"></a>自我总结本篇概要</h1><ul>
<li>读取数据的时候要特别小心， 因为可能会有攻击者发送过来的恶意的数据包以及错误的包， 在写入数据的时候你可能会轻松很多，因为如果有任何事情出错了，那几乎肯定是你自己导致的错误</li>
<li><p><strong>统一的数据包序列化功能</strong> ：诀窍在于让流类型的序列化函数模板化。在我的系统中有两个流类型：ReadStream类和WriteStream类。每个类都有相同的一套方法，但实际上它们没有任何关系。一个类负责从比特流读取值到变量中，另外一个类负责把变量的值写到流中。<br>在模板里类似这样写, 通过 <code>Stream::IsWriting</code> 和 <code>Stream::IsReading</code> 模板会自动区分,然后帮你生产你想要的代码, 简洁漂亮</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteStream</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123; IsWriting = <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; IsReading = <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123; IsWriting = <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; IsReading = <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Stream&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">serialize</span><span class="params">( Stream &amp; stream, <span class="keyword">float</span> &amp; value )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> FloatInt</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">float</span> float_value;</span><br><span class="line">       <span class="keyword">uint32_t</span> int_value;</span><br><span class="line">   &#125;;</span><br><span class="line">  </span><br><span class="line">   FloatInt tmp;</span><br><span class="line">   <span class="keyword">if</span> ( Stream::IsWriting )</span><br><span class="line">       tmp.float_value = value;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">bool</span> result = stream.SerializeBits( tmp.int_value, <span class="number">32</span> );</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> ( Stream::IsReading )</span><br><span class="line">       value = tmp.float_value;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>边界检查和终止读取</strong> ： 把允许的大小范围也传给序列化函数而不仅仅是所需的比特数量。</p>
</li>
<li><p><strong>序列化浮点数和向量</strong> ： 计算机根本不知道内存中的这个32位的值到底是一个整数还是一个浮点数还是一个字符串的部分。它知道的就是这仅仅是一个32位的值。代码如下(可以通过一个联合体来访问看上去是整数的浮点数).<br>有些时候，你并不想把一个完整精度的浮点数进行传递。那么该如何压缩这个浮点值？第一步是将它的值限制在某个确定的范围内然后用一个整数表示方式来将它量化。<br>举个例子来说，如果你知道一个浮点类型的值是在区间[-10,+10]，对于这个值来说可以接受的精确度是0.01，那么你可以把这个浮点数乘以100.0让它的值在区间[-1000,+1000]并在网络上将其作为一个整数进行序列化。而在接收的那一端，仅仅需要将它除以100.0来得到最初的浮点值. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> FloatInt</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">float</span> float_value;</span><br><span class="line">   <span class="keyword">uint32_t</span> int_value;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">FloatInt tmp;</span><br><span class="line">tmp.float_value= <span class="number">10.0f</span>;</span><br><span class="line"><span class="built_in">printf</span>(“<span class="keyword">float</span> value as an integer: %x\n”, tmp.int_value );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>序列化字符串和数组</strong> : 为什么要费那么大精力把一个字节数组按比特打包到你的比特流里?为什么不在序列化写入之前进行按字节进行对齐？Why not align to byte so you can <strong>memcpy</strong> the array of bytes directly into the packet?<br>如何将比特流按字节对齐？只需要在流的当前位置做些计算就可以了，找出还差写入多少个比特就能让当前比特流的比特数量被8整除，然后按照这个数字插入填充比特（比如当前比特流的比特数量是323，那么323+5才能被8整除，所以需要插入5个填充比特）。对于填充比特来说，填充的比特值都是0，这样当你序列化读取的时候你可以进行检测，如果检测的结果是正确的，那么就确实是在读取填充的部分，并且填充的部分确实是0。一直读取到下一个完整字节的比特起始位置（可以被8整除的位置）。如果检测的结果是在应该填充的地方发现了非0的比特值，那么就中止序列化读取并丢弃这个数据包。</p>
</li>
<li><strong>序列化数组的子集</strong> : 当实现一个游戏网络协议的时候，或早或晚总会需要序列化一个对象数组然后在网络上传递。比如说服务器也许需要把所有的物体发送给客户端，或者有时候需要发送一组事件或者消息。如果你要发送所有的物体到客户端，这是相当简单直观的，但是如果你只是想发送一个数组的一个子集怎么办？<br>最先想到也是最容易的办法是遍历数组的所有物体然后序列化一个bool数组，这个bool数组标记的是对应的物体是否通过网络发送。如果bool值为1那么后面会跟着物体的数据，否则就会被忽略然后下一个物体的bool值取决于流的下一个值。<br>如果有大量的物体需要发送，举个例子来说，整个场景中有4000个物体，有一半的物体也就是2000个需要通过网络进行发送。每个物体需要一个序号，那么就需要2000个序号，每个序号需要12比特。。。。这就是说数据包里面24000比特或者说接近30000比特（几乎是30000，不是严格是，译注：原文如此）的数据被序号浪费掉了.<br>可以把序号的编码方式修改下来节省数据，序号不再是全局序号，而是相对上一个物体的相对序号。</li>
<li><strong>如何应对恶意数据包和错误包</strong> : 如果某些人发送一些包含随机信息的恶意数据包给你的服务器。你会不会在解析的时候把服务器弄崩溃掉？<br>有三种技术应对 : <ul>
<li>协议ID : 在你的数据包里面包含协议ID。一般典型的做法是，头4个字节你可以设定一些比较罕见而且独特的值，你可以通过这３２比特的数据判断出来根本就不是你的应用程序的包，然后就可以直接丢弃了。</li>
<li>CRC32 : 对你的数据包整体做一个CRC32的校验，并把这个校验码放到数据包的包头。可以不发送这个协议ID，但是发送方和接收方提前确认过这个协议ID是什么，并在计算数据包CRC32值的时候装作这个数据包带上了这个协议ID的前缀来参与计算。这样如果发送方使用的协议ID与接收方不一致的时候，CRC32的校验就会失败，这将为每个数据包节省4个字节.</li>
<li>序列化检测 : 是在包的中间，在一段复杂的序列化写入之前或者之后写上一个已知的32比特整数，并在另外一端序列化读取的时候用相同的值进行检测判断。如果序列化检查值是不正确的，那么就中止序列化读取并丢弃这个数据包。<br><strong>. . .</strong>
          <!--noindex-->
          
          <!--/noindex-->
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </li></ul></li></ul></div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/02/24/reading_and_writing_packets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/24/reading_and_writing_packets/" itemprop="url">构建游戏网络协议一之数据包的读取和写入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-24T13:13:35+00:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          <h1 id="自我总结"><a href="#自我总结" class="headerlink" title="自我总结"></a>自我总结</h1><p>这篇文章只是介绍, 之后的文章才是正题. 此篇文章大体介绍了 : </p>
<ul>
<li>文本格式传输的低效率问题， 为了可读性而产生了太多冗余无用数据</li>
<li>为什么不用目前已经有了的库比如Protocol Buffers：因为我们不需要版本信息，也不需要什么跨语言的支持。所以让我们直接忽略掉这些功能并用我们自己的不带属性的二进制流进行代替，在这个过程中我们可以获得更多的控制性和灵活性</li>
<li>要注意大小端的问题</li>
<li>实现一个位打包器， 工作在32位或者64位的级别， 而不是是工作在字节这个级别。因为现代机器对这个长度进行了专门的优化而不应该像1985年那样在字节的级别对缓冲区进行处理。</li>
<li>要注意防止恶意数据包的问题 ：<ul>
<li>我们需要实现一个方法来判断整数值是否超出预期范围，如果超出了就要中止网络包的读取和解析，因为会有一些不怀好意的人给我们发送恶意网络包希望我们的程序和内存崩溃掉。网络包的读取和解析的中止必须是自动化的，而且不能使用异常处理，因为异常处理太慢了会拖累我们的程序。</li>
<li>如果独立的读取和写入函数是手动编解码的，那么维护它们真的是一个噩梦。我们希望能够为包一次性的编写好序列化代码并且没有任何运行时的性能消耗（主要是额外的分支、虚化等等）。</li>
</ul>
</li>
<li>我们为了不想自己手动检查各种可能会被攻击的地方， 需要实现检查自动化， 在下一篇文章 <a href="/2017/02/25/serialization_strategies/" title="构建游戏网络协议二之序列化策略">构建游戏网络协议二之序列化策略</a> 里将会说。<br><strong>. . .</strong>
          <!--noindex-->
          
          <!--/noindex-->
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </li></ul></div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/43/">43</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="no5ix">
          </a>
          <p class="site-author-name" itemprop="name">no5ix</p>
           
              <p class="site-description motion-element" itemprop="description">推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">215</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">关于</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
          
          <!-- 网易云音乐 -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- 网易云音乐 -->

        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://119.23.17.57" title="ksun的博客" target="_blank">ksun的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzU3MTUyNzg0NQ==&hid=1&sn=7a3ae61b7af714f75d68e7ae826a2d2c&scene=18#wechat_redirect" title="你有图么我有故事" target="_blank">你有图么我有故事</a>
                </li>
              
            </ul>
          </div>
        

        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">no5ix</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/dist/jquery.fancybox.js?v=3.2.10"></script>


  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">

    var is_load_xml_finished = 0;

    var searchFunc = function (path, search_id, content_id) {
      // 0x00. environment initialization
      'use strict';

      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      // var datas = [];

      /* loading css1 : Dot Css Loader*/
      var DotLoader = "<div class='loader'>Loading...</div>";

      /* loading css2 : Pure Css Loader - Square */
      var SquareLoader = 
        "<div class='loader'>" +
          "<div class='square' ></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square '></div>" +
          "<div class='square last'></div>" +
        "</div>";

      var ProgressBar = 
          "<div class='progress-bar'>" +
            "<div class='progress-bar-charge'></div>" +
          "</div>";

      var str = "";
      var keywords = [];
      var temp_keyword = "";

      // 是否为第一个字母被键入的标志位
      var first_char_flag = 0;

      // 因为在移动设备上, 点击搜索之后会 scroll 到页面顶部, 所以需要记录之前的页面x, y坐标值, 以便于搜索完点击 close 按钮之后 scroll 回原来的页面坐标值.
      var last_page_x = 0;
      var last_page_y = 0;

      var local_search_tips = 
            "<span class='local-search-empty'>" + "第一次搜索可能较慢, 先思考一个经典算法问题, 跳台阶:" + "</span>" +
            "<span class='local-search-empty'>" + "一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个6级的台阶总共有多少种跳法?n级呢?" + "</span>";

      function CloseLocalSearch()
      {
        first_char_flag = 0;

        $('#local-search-input').val('');
        $('#local-search-close').hide();

        // $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownOut', 200);

        $('#' + content_id).attr("headroom_special_attr","true"); 
        
        if (isMobile())
        {
          // $('body').scrollTop(last_page_y);  // scrollTop 有兼容性问题
          scrollTo(last_page_x, last_page_y);

          $('#' + content_id).hide();
        }
        else
        {
          $('#' + content_id).velocity('stop').velocity( 'transition.bounceUpOut', 200 );
        }

        // $('#' + content_id).velocity('stop').velocity( isMobile() ? 'transition.fadeOut' : 'transition.bounceUpOut', {
        //   // delay: isMobile() ? 50 : 0,
        //   duration: isMobile() ? 500 : 200,
        //   // begin: function() { 
        //   //   if (isMobile())
        //   //   {
        //   //     $('body').scrollTop(last_page_y);
        //   //   } 
        //   // }
        //   complete: function () {
        //     if (isMobile())
        //     {
        //       if (last_page_y < 20000)
        //       {
        //         $('body').velocity('scroll', { offset: last_page_y+"px", duration: last_page_y < 10000 ? 1000 : 2000 });
        //       }
        //       else
        //       {
        //         $('body').scrollTop(last_page_y);
        //       }
        //       // $('body').velocity('scroll');

        //       // $('html,body').animate({
        //       //   scrollTop: last_page_y
        //       // },400);
        //       // $('body').velocity('transition.slideDownIn', 1000);
        //       // $('body').velocity('scroll', { offset: last_page_y+"px", duration: document.body.scrollHeight < 20000 ? 1500 : 3000 });
        //     }
        //   }
        // });
      }

      function handleSearch()
      {
        if (keywords.length <= 0) {
          return;
        }
        $resultContent.innerHTML = "";
        $('#local-search-close').show();

        // 0x04. perform local searching
        if (is_load_xml_finished == 0)
        {
          $resultContent.innerHTML = 
            "<ul class='local-search-empty-ul'>" + 
            local_search_tips +
            ProgressBar;
        }
        else
        {
          // Retrieve the object from local storage
          var xml_resp = retrieve_search_xml()

          xml_resp.forEach(function (data) {
          // datas.forEach(function (data) {
            var isMatch = true;
            var content_index = [];
            if (!data.title || data.title.trim() === '') {
              data.title = "Untitled";
            }
            var is_encrypted = data.encrypted.trim() == '1'
            var is_sensitive = CONFIG.local_search.sensitive_word && data_content.indexOf(CONFIG.local_search.sensitive_word) >= 0
            var orig_data_title = data.title.trim();
            var data_title = orig_data_title.toLowerCase();
            var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
            var data_content = orig_data_content.toLowerCase();
            var data_url = decodeURIComponent(data.url);
            var index_title = -1;
            var index_content = -1;
            var first_occur = -1;
            // only match artiles with not empty contents
            if (data_content !== '') {
              keywords.forEach(function (keyword, i) {
                index_title = data_title.indexOf(keyword);
                index_content = (is_sensitive || is_encrypted) ? -1 : data_content.indexOf(keyword);

                if (index_title < 0 && index_content < 0) {
                  isMatch = false;
                } else {
                  if (index_content < 0) {
                    index_content = 0;
                  }
                  if (i == 0) {
                    first_occur = index_content;
                  }
                  // content_index.push({index_content:index_content, keyword_len:keyword_len});
                }
              });
            } else {
              isMatch = false;
            }
            // 0x05. show search results
            if (isMatch) {
              var content = orig_data_content;
              if (first_occur >= 0) {
                var match_content = "";
                if (!is_sensitive && !is_encrypted)
                {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  match_content = content.substr(start, end);
                }

                // highlight all keywords
                var regS = "";
                if (match_content != "")
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                else
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                str += "<li><a href='" + data_url + "' class='search-result-title' target='_blank'>" + orig_data_title + "</a>";
                str += "<p class=\"search-result\">" + match_content + "...</p>"
              }
              str += "</li>";
            }
          });

          str += "</ul>";
          if (str.indexOf('<li>') === -1) {
            return $resultContent.innerHTML = 
              "<ul class='local-search-empty-ul'><span class='local-search-empty'>找不到, 换个搜索关键字试一哈.<span></ul>";
          }
          $resultContent.innerHTML = str;
        }
      }

      $input.addEventListener('input', function () {
        // 0x03. parse query to keywords list
        str = '<ul class=\"search-result-list\">';
        temp_keyword = this.value.trim();
        if (temp_keyword.length <= 0) {
          CloseLocalSearch();
          return;
        }

        keywords = temp_keyword.toLowerCase().split(/[\s\-]+/);
        handleSearch();

        // 当用户键入第一个字母的时候的动画处理逻辑 : 
        // 当 first_char_flag 为 0 的时候, 
        // 要播放一个动画
        if (first_char_flag == 0)
        {
            // $('body').scrollTop(0);
          if (isMobile())
          {
            last_page_x = window.pageXOffset;
            last_page_y = window.pageYOffset;
            // $('body').scrollTop(0);
            scrollTo(0,0);

          }
          first_char_flag = 1;
          $('#' + content_id).removeAttr("headroom_special_attr");
          
          $('#' + content_id).velocity('stop').velocity('transition.slideDownIn', 300);

          $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 1000);
        }
      });


      var local_search_xml_data = localStorage.getItem('local_search_xml_data');
      if (!local_search_xml_data) {
        $.ajax({
          // 0x01. load xml file
          url: path,
          dataType: "xml",
          success: function (xmlResponse) {
            store_search_xml(xmlResponse);

            // setTimeout(function(){
            //   is_load_xml_finished = 1;

            //   handleSearch();
            //   $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
            // }, 2000);
            
            // is_load_xml_finished = 1;

            handleSearch();
            $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
          }
        });
      }

      $(document).on('click', '#local-search-close', function() {
        CloseLocalSearch();
      });

      $(document).keyup(function(event){
        switch(event.keyCode) {
          case 27:
            // alert("ESC");
            CloseLocalSearch();
        }
      });

      // $(document).on('blur', '#local-search-input', function(e) {
      //   // console.log(document.activeElement.getAttribute('class'));
        
      //   if (isMobile() == false)
      //   {
      //     CloseLocalSearch();
      //   }
      // });
    }

    function isMobile() {
      // console.log(document.body.clientWidth);
      return document.body.clientWidth < 768

      // var userAgent = window.navigator.userAgent;

      // var isiPad = userAgent.match(/iPad/i) !== null;
      // var mobileUA = [
      //   'iphone', 'android', 'phone', 'mobile',
      //   'wap', 'netfront', 'x11', 'java', 'opera mobi',
      //   'opera mini', 'ucweb', 'windows ce', 'symbian',
      //   'symbianos', 'series', 'webos', 'sony',
      //   'blackberry', 'dopod', 'nokia', 'samsung',
      //   'palmsource', 'xda', 'pieplus', 'meizu',
      //   'midp' ,'cldc' , 'motorola', 'foma',
      //   'docomo', 'up.browser', 'up.link', 'blazer',
      //   'helio', 'hosin', 'huawei', 'novarra',
      //   'coolpad', 'webos', 'techfaith', 'palmsource',
      //   'alcatel', 'amoi', 'ktouch', 'nexian',
      //   'ericsson', 'philips', 'sagem', 'wellcom',
      //   'bunjalloo', 'maui', 'smartphone', 'iemobile',
      //   'spice', 'bird', 'zte-', 'longcos',
      //   'pantech', 'gionee', 'portalmmm', 'jig browser',
      //   'hiptop', 'benq', 'haier', '^lct',
      //   '320x320', '240x320', '176x220'
      // ];
      // var pattern = new RegExp(mobileUA.join('|'), 'i');

      // return !isiPad && userAgent.match(pattern);
    }

    function store_search_xml(xmlResponse) {
        datas = $("entry", xmlResponse).map(function () {
          return {
            title: $("title", this).text(),
            content: $("content", this).text(),
            url: $("url", this).text(),
            encrypted: $("encrypted", this).text(),
          };
        }).get();
        // Put the object into storage
        localStorage.setItem('local_search_xml_data', JSON.stringify(datas));
        is_load_xml_finished = 1;

        console.log("store search.xml finished.");
    }

    function ajax_store_search_xml() {
      $.ajax({
        url: "/search.xml",
        dataType: "xml",
        success: function (xmlResponse) {
            store_search_xml(xmlResponse);
        }
      });
    }

    function retrieve_search_xml() {
        // Retrieve the object from local storage
        var retrievedObject = localStorage.getItem('local_search_xml_data');
        var xml_resp = JSON.parse(retrievedObject)
        return xml_resp
    }

    var getSearchFile = function(){
      var path = "/search.xml";
      var local_search_result_name = isMobile() ? "local-search-result-mobile" : "local-search-result-pc";
      searchFunc(path, 'local-search-input', local_search_result_name);
    }

    var local_search_xml_data = localStorage.getItem('local_search_xml_data');
    if (local_search_xml_data) {
      is_load_xml_finished = 1;
      console.log("load search.xml finished.");
    }
    var last_use_local_search_date = localStorage.getItem('last_use_local_search_date');
    var curDate = new Date();
    // 只有在 localStorage 没有 search.xml数据或者 距离上次使用local search已经超过一天了才去取search.xml
    // 节省流量
    if (last_use_local_search_date != curDate.getDate() || !local_search_xml_data) {
      // preload search.xml
      ajax_store_search_xml();
    }

    localStorage.setItem('last_use_local_search_date', curDate.getDate());
    

  </script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>


<!-- 页面点击小红心 -->





<script type="text/javascript" src="/js/src/headroom.js"></script> 

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
