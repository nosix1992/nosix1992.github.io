<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
          // alert('此文章并不公开, 输入文章密码方可阅读');
          var password = prompt('此文章并不公开, 输入文章密码方可阅读');
          if (password !== ''){
            if (password != null) // 如果用户点击了确认而且密码错误的时候, 因为当password == null的时候说明用户点了取消
            {
              alert('Error!');
            }
            if (history.length > 1)
            {
              history.back();
            }
            else
            {
              window.location.href = "about:blank";
            }
          }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/dist/jquery.fancybox.css?v=3.2.10" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="GafferOnGames,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="自我总结本篇概要 读取数据的时候要特别小心， 因为可能会有攻击者发送过来的恶意的数据包以及错误的包， 在写入数据的时候你可能会轻松很多，因为如果有任何事情出错了，那几乎肯定是你自己导致的错误 统一的数据包序列化功能 ：诀窍在于让流类型的序列化函数模板化。在我的系统中有两个流类型：ReadStream类和WriteStream类。每个类都有相同的一套方法，但实际上它们没有任何关系。一个类负责从比特流">
<meta name="keywords" content="GafferOnGames">
<meta property="og:type" content="article">
<meta property="og:title" content="构建游戏网络协议二之序列化策略">
<meta property="og:url" content="https://hulinhong.com/2017/02/25/serialization_strategies/index.html">
<meta property="og:site_name" content="烫">
<meta property="og:description" content="自我总结本篇概要 读取数据的时候要特别小心， 因为可能会有攻击者发送过来的恶意的数据包以及错误的包， 在写入数据的时候你可能会轻松很多，因为如果有任何事情出错了，那几乎肯定是你自己导致的错误 统一的数据包序列化功能 ：诀窍在于让流类型的序列化函数模板化。在我的系统中有两个流类型：ReadStream类和WriteStream类。每个类都有相同的一套方法，但实际上它们没有任何关系。一个类负责从比特流">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-03-17T07:39:49.302Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="构建游戏网络协议二之序列化策略">
<meta name="twitter:description" content="自我总结本篇概要 读取数据的时候要特别小心， 因为可能会有攻击者发送过来的恶意的数据包以及错误的包， 在写入数据的时候你可能会轻松很多，因为如果有任何事情出错了，那几乎肯定是你自己导致的错误 统一的数据包序列化功能 ：诀窍在于让流类型的序列化函数模板化。在我的系统中有两个流类型：ReadStream类和WriteStream类。每个类都有相同的一套方法，但实际上它们没有任何关系。一个类负责从比特流">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":222,"transition":{"header":"slideDownIn","menu":"slideDownIn","logo":"slideDownIn","post_block_else":"slideDownIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"slideDownIn","footer":"slideDownIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>构建游戏网络协议二之序列化策略 | 烫</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">烫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">烫烫烫烫烫</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <form class="site-search-form">
    <span class="search-icon fa fa-search"></span>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">×</i>
  </form>


<script type="text/javascript" id="local.search.active">
var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/02/25/serialization_strategies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">构建游戏网络协议二之序列化策略</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-25T17:13:35+00:00">
                2017-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            <div class="post-tags">
              
                <a href="/tags/GafferOnGames/" rel="tag"><i class="fa fa-tag"></i> GafferOnGames</a>
              
            </div>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/24/reading_and_writing_packets/" rel="next" title="构建游戏网络协议一之数据包的读取和写入">
                <i class="fa fa-chevron-left"></i> 
                <p class="post-nav-pre-next-title">
                  构建游戏网络协议一之数据包的读取和写入
                </p> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/26/packet_fragmentation_and_reassembly/" rel="prev" title="构建游戏网络协议三之数据包的分包和重组">
              <p class="post-nav-pre-next-title">
                  构建游戏网络协议三之数据包的分包和重组
              </p> 
              <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

      
      

      
        <h1 id="自我总结本篇概要"><a href="#自我总结本篇概要" class="headerlink" title="自我总结本篇概要"></a>自我总结本篇概要</h1><ul>
<li>读取数据的时候要特别小心， 因为可能会有攻击者发送过来的恶意的数据包以及错误的包， 在写入数据的时候你可能会轻松很多，因为如果有任何事情出错了，那几乎肯定是你自己导致的错误</li>
<li><p><strong>统一的数据包序列化功能</strong> ：诀窍在于让流类型的序列化函数模板化。在我的系统中有两个流类型：ReadStream类和WriteStream类。每个类都有相同的一套方法，但实际上它们没有任何关系。一个类负责从比特流读取值到变量中，另外一个类负责把变量的值写到流中。<br>在模板里类似这样写, 通过 <code>Stream::IsWriting</code> 和 <code>Stream::IsReading</code> 模板会自动区分,然后帮你生产你想要的代码, 简洁漂亮</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteStream</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123; IsWriting = <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; IsReading = <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123; IsWriting = <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; IsReading = <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Stream&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">serialize</span><span class="params">( Stream &amp; stream, <span class="keyword">float</span> &amp; value )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> FloatInt</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">float</span> float_value;</span><br><span class="line">       <span class="keyword">uint32_t</span> int_value;</span><br><span class="line">   &#125;;</span><br><span class="line">  </span><br><span class="line">   FloatInt tmp;</span><br><span class="line">   <span class="keyword">if</span> ( Stream::IsWriting )</span><br><span class="line">       tmp.float_value = value;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">bool</span> result = stream.SerializeBits( tmp.int_value, <span class="number">32</span> );</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> ( Stream::IsReading )</span><br><span class="line">       value = tmp.float_value;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>边界检查和终止读取</strong> ： 把允许的大小范围也传给序列化函数而不仅仅是所需的比特数量。</p>
</li>
<li><p><strong>序列化浮点数和向量</strong> ： 计算机根本不知道内存中的这个32位的值到底是一个整数还是一个浮点数还是一个字符串的部分。它知道的就是这仅仅是一个32位的值。代码如下(可以通过一个联合体来访问看上去是整数的浮点数).<br>有些时候，你并不想把一个完整精度的浮点数进行传递。那么该如何压缩这个浮点值？第一步是将它的值限制在某个确定的范围内然后用一个整数表示方式来将它量化。<br>举个例子来说，如果你知道一个浮点类型的值是在区间[-10,+10]，对于这个值来说可以接受的精确度是0.01，那么你可以把这个浮点数乘以100.0让它的值在区间[-1000,+1000]并在网络上将其作为一个整数进行序列化。而在接收的那一端，仅仅需要将它除以100.0来得到最初的浮点值. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> FloatInt</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">float</span> float_value;</span><br><span class="line">   <span class="keyword">uint32_t</span> int_value;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">FloatInt tmp;</span><br><span class="line">tmp.float_value= <span class="number">10.0f</span>;</span><br><span class="line"><span class="built_in">printf</span>(“<span class="keyword">float</span> value as an integer: %x\n”, tmp.int_value );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>序列化字符串和数组</strong> : 为什么要费那么大精力把一个字节数组按比特打包到你的比特流里?为什么不在序列化写入之前进行按字节进行对齐？Why not align to byte so you can <strong>memcpy</strong> the array of bytes directly into the packet?<br>如何将比特流按字节对齐？只需要在流的当前位置做些计算就可以了，找出还差写入多少个比特就能让当前比特流的比特数量被8整除，然后按照这个数字插入填充比特（比如当前比特流的比特数量是323，那么323+5才能被8整除，所以需要插入5个填充比特）。对于填充比特来说，填充的比特值都是0，这样当你序列化读取的时候你可以进行检测，如果检测的结果是正确的，那么就确实是在读取填充的部分，并且填充的部分确实是0。一直读取到下一个完整字节的比特起始位置（可以被8整除的位置）。如果检测的结果是在应该填充的地方发现了非0的比特值，那么就中止序列化读取并丢弃这个数据包。</p>
</li>
<li><strong>序列化数组的子集</strong> : 当实现一个游戏网络协议的时候，或早或晚总会需要序列化一个对象数组然后在网络上传递。比如说服务器也许需要把所有的物体发送给客户端，或者有时候需要发送一组事件或者消息。如果你要发送所有的物体到客户端，这是相当简单直观的，但是如果你只是想发送一个数组的一个子集怎么办？<br>最先想到也是最容易的办法是遍历数组的所有物体然后序列化一个bool数组，这个bool数组标记的是对应的物体是否通过网络发送。如果bool值为1那么后面会跟着物体的数据，否则就会被忽略然后下一个物体的bool值取决于流的下一个值。<br>如果有大量的物体需要发送，举个例子来说，整个场景中有4000个物体，有一半的物体也就是2000个需要通过网络进行发送。每个物体需要一个序号，那么就需要2000个序号，每个序号需要12比特。。。。这就是说数据包里面24000比特或者说接近30000比特（几乎是30000，不是严格是，译注：原文如此）的数据被序号浪费掉了.<br>可以把序号的编码方式修改下来节省数据，序号不再是全局序号，而是相对上一个物体的相对序号。</li>
<li><strong>如何应对恶意数据包和错误包</strong> : 如果某些人发送一些包含随机信息的恶意数据包给你的服务器。你会不会在解析的时候把服务器弄崩溃掉？<br>有三种技术应对 : <ul>
<li>协议ID : 在你的数据包里面包含协议ID。一般典型的做法是，头4个字节你可以设定一些比较罕见而且独特的值，你可以通过这３２比特的数据判断出来根本就不是你的应用程序的包，然后就可以直接丢弃了。</li>
<li>CRC32 : 对你的数据包整体做一个CRC32的校验，并把这个校验码放到数据包的包头。可以不发送这个协议ID，但是发送方和接收方提前确认过这个协议ID是什么，并在计算数据包CRC32值的时候装作这个数据包带上了这个协议ID的前缀来参与计算。这样如果发送方使用的协议ID与接收方不一致的时候，CRC32的校验就会失败，这将为每个数据包节省4个字节.</li>
<li>序列化检测 : 是在包的中间，在一段复杂的序列化写入之前或者之后写上一个已知的32比特整数，并在另外一端序列化读取的时候用相同的值进行检测判断。如果序列化检查值是不正确的，那么就中止序列化读取并丢弃这个数据包。<br><strong>. . .</strong><a id="more"></a></li>
</ul>
</li>
</ul>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/serialization_strategies/" target="_blank" rel="noopener">原文出处</a></p>
<p>原文标题 : <strong>Serialization Strategies</strong> (<em>Smart tricks that unify packet read and write</em>)</p>
<hr>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I’m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <strong><a href="https://gafferongames.com/categories/building-a-game-network-protocol/" target="_blank" rel="noopener">Building a Game Network Protocol</a></strong>.</p><br><p>In the <a href="https://gafferongames.com/post/reading_and_writing_packets/" target="_blank" rel="noopener">previous article</a>, we created a bitpacker but it required manual checking to make sure reading a packet from the network is safe. This is a real problem because the stakes are particularly high - a single missed check creates a vulnerability that an attacker can use to crash your server.</p><br><p>In this article, we&rsquo;re going to transform the bitpacker into a system where this checking is <em>automatic</em>. We&rsquo;re going to do this with minimal runtime overhead, and in such a way that we don&rsquo;t have to code separate read and write functions, performing both read and write with a single function.</p><br><p>This is called a <em>serialize function</em>.</p><br><h2 id="serializing-bits">Serializing Bits</h2><br><p>Let&rsquo;s start with the goal. Here&rsquo;s where we want to end up:</p><br><pre>struct PacketA<br>{<br>    int x,y,z;<br><br>    template &lt;typename Stream&gt; bool Serialize( Stream &amp; stream )<br>    {<br>        serialize_bits( stream, x, 32 );<br>        serialize_bits( stream, y, 32 );<br>        serialize_bits( stream, z, 32 );<br>        return true;<br>    }<br>};<br></pre><br><p>Above you can see a simple serialize function. We serialize three integer variables x,y,z with 32 bits each.</p><br><pre>struct PacketB<br>{<br>    int numElements;<br>    int elements[MaxElements];<br><br>    template &lt;typename Stream&gt; bool Serialize( Stream &amp; stream )<br>    {<br>        serialize_int( stream, numElements, 0, MaxElements );<br>        for ( int i = 0; i &lt; numElements; ++i )<br>        {<br>            serialize_bits( buffer, elements[i], 32 );<br>        }<br>        return true;<br>    }<br>};<br></pre><br><p>And now something more complicated. We serialize a variable length array, making sure that the array length is in the range [0,MaxElements].</p><br><p>Next, we serialize a rigid body with an simple optimization while it&rsquo;s at rest, serializing only one bit in place of linear and angular velocity:</p><br><pre>struct RigidBody<br>{<br>    vec3f position;<br>    quat4f orientation;<br>    vec3f linear_velocity;<br>    vec3f angular_velocity;<br><br>    template &lt;typename Stream&gt; bool Serialize( Stream &amp; stream )<br>    {<br>        serialize_vector( stream, position );<br>        serialize_quaternion( stream, orientation );<br>        bool at_rest = Stream::IsWriting ? ( velocity.length() == 0 ) : 1;<br>        serialize_bool( stream, at_rest );<br>        if ( !at_rest )<br>        {<br>            serialize_vector( stream, linear_velocity );<br>            serialize_vector( stream, angular_velocity );<br>        }<br>        else if ( Stream::IsReading )<br>        {<br>            linear_velocity = vec3f(0,0,0);<br>            angular<em>velocity = vec3f(0,0,0);<br>        }<br>        return true;<br>    }<br>};<br></em></pre><br><p>Notice how we&rsquo;re able to branch on Stream::IsWriting and Stream::IsReading to write code for each case. These branches are removed by the compiler when the specialized read and write serialize functions are generated.</p><br><p>As you can see, serialize functions are flexible and expressive. They&rsquo;re also <em>safe</em>, with each <strong>serialize<em></em></strong> call performing checks and aborting read if anything is wrong (eg. a value out of range, going past the end of the buffer). Most importantly, this checking is automatic, <em>so you can&rsquo;t forget to do it!</em></p><br><h2 id="implementation-in-c">Implementation in C++</h2><br><p>The trick to making this all work is to create two stream classes that share the same interface: <strong>ReadStream</strong> and <strong>WriteStream</strong>.</p><br><p>The write stream implementation <em>writes values</em> using the bitpacker:</p><br><pre>class WriteStream<br>{<br>public:<br><br>    enum { IsWriting = 1 };<br>    enum { IsReading = 0 };<br><br>    WriteStream( uint8_t  buffer, int bytes ) : m_writer( buffer, bytes ) {}<br><br>    bool SerializeInteger( int32_t value, int32_t min, int32_t max )<br>    {<br>        assert( min &lt; max );<br>        assert( value &gt;= min );<br>        assert( value &lt;= max );<br>        const int bits = bits_required( min, max );<br>        uint32_t unsigned_value = value - min;<br>        m_writer.WriteBits( unsigned_value, bits );<br>        return true;<br>    }<br><br>    // …<br><br>private:<br><br>    BitWriter m_writer;<br>};<br></pre><br><p>And the read stream implementation <em>reads values in</em>:</p><br><pre>class ReadStream<br>{<br>public:<br><br>    enum { IsWriting = 0 };<br>    enum { IsReading = 1 };<br><br>    ReadStream( const uint8_t <em> buffer, int bytes ) : m_reader( buffer, bytes ) {}<br><br>    bool SerializeInteger( int32_t &amp; value, int32_t min, int32_t max )<br>    {<br>        assert( min &lt; max );<br>        const int bits = bits_required( min, max );<br>        if ( m_reader.WouldReadPastEnd( bits ) )<br>        {<br>            return false;<br>        }<br>        uint32_t unsigned_value = m_reader.ReadBits( bits );<br>        value = (int32_t) unsigned_value + min;<br>        return true;<br>    }<br><br>    // …<br><br>private:<br><br>    BitReader m<em>reader;<br>};<br></em></em></pre><br><p>With the magic of C++ templates, we leave it up to the compiler to specialize the serialize function to the stream class passed in, producing optimized read and write functions.</p><br><p>To handle safety <strong>serialize</strong> calls are not actually functions at all. They&rsquo;re actually macros that return false on error, thus unwinding the stack in case of error, without the need for exceptions.</p><br><p>For example, this macro serializes an integer in a given range:</p><br><pre>#define serialize_int( stream, value, min, max )                    \<br>    do                                                              \<br>    {                                                               \<br>        assert( min &lt; max );                                        \<br>        int32_t int32_value;                                        \<br>        if ( Stream::IsWriting )                                    \<br>        {                                                           \<br>            assert( value &gt;= min );                                 \<br>            assert( value &lt;= max );                                 \<br>            int32_value = (int32_t) value;                          \<br>        }                                                           \<br>        if ( !stream.SerializeInteger( int32_value, min, max ) )    \<br>        {                                                           \<br>            return false;                                           \<br>        }                                                           \<br>        if ( Stream::IsReading )                                    \<br>        {                                                           \<br>            value = int32_value;                                    \<br>            if ( value &lt; min || value &gt; max )                       \<br>            {                                                       \<br>                return false;                                       \<br>            }                                                       \<br>        }                                                           \<br>     } while (0)<br></pre><br><p>If a value read in from the network is outside the expected range, or we read past the end of the buffer, the packet read is aborted.</p><br><h2 id="serializing-floating-point-values">Serializing Floating Point Values</h2><br><p>We&rsquo;re used to thinking about floating point numbers as being different to integers, but in memory they&rsquo;re just a 32 bit value like any other.</p><br><p>The C++ language lets us work with this fundamental property, allowing us to directly access the bits of a float value as if it were an integer:</p><br><pre>union FloatInt<br>{<br>    float float_value;<br>    uint32_t int_value;<br>};<br><br>FloatInt tmp;<br>tmp.float_value = 10.0f;<br>printf( “float value as an integer: %x\n”, tmp.int_value );<br></pre><br><p>You may prefer to do this with an aliased uint32_t<em> pointer, but this breaks with GCC -O2. Friends of mine point out that the only <em>truly standard way</em> to get the float as an integer is to cast a pointer to the float value to char</em> and reconstruct the integer from the bytes values accessed through the char pointer.</p><br><p>Meanwhile in the past 5 years I&rsquo;ve had no problems in the field with the union trick. Here&rsquo;s how I use it to serialize an uncompressed float value:</p><br><pre>template &lt;typename Stream&gt;<br>bool serialize_float_internal( Stream &amp; stream,<br>                               float &amp; value )<br>{<br>    union FloatInt<br>    {<br>        float float_value;<br>        uint32_t int_value;<br>    };<br>    FloatInt tmp;<br>    if ( Stream::IsWriting )<br>    {<br>        tmp.float_value = value;<br>    }<br>    bool result = stream.SerializeBits( tmp.int_value, 32 );<br>    if ( Stream::IsReading )<br>    {<br>        value = tmp.float_value;<br>    }<br>    return result;<br>}<br></pre><br><p>This is of course wrapped with a <strong>serialize_float</strong> macro for error checking:</p><br><pre>#define serialize_float( stream, value )                             \<br>  do                                                                 \<br>  {                                                                  \<br>      if ( !serialize_float_internal( stream, value ) )              \<br>      {                                                              \<br>          return false;                                              \<br>      }<br>  } while (0)<br></pre><br><p>We can now transmit full precision floating point values over the network.</p><br><p>But what about situations where you don&rsquo;t need full precision? What about a floating point value in the range [0,10] with an acceptable precision of 0.01? Is there a way to send this over the network using less bits?</p><br><p>Yes there is. The trick is to simply divide by 0.01 to get an integer in the range [0,1000] and send that value over the network. On the other side, convert back to a float by multiplying by 0.01.</p><br><p>Here&rsquo;s a general purpose implementation of this basic idea:</p><br><pre>template &lt;typename Stream&gt;<br>bool serialize_compressed_float_internal( Stream &amp; stream,<br>                                          float &amp; value,<br>                                          float min,<br>                                          float max,<br>                                          float res )<br>{<br>    const float delta = max - min;<br>    const float values = delta / res;<br>    const uint32_t maxIntegerValue = (uint32_t) ceil( values );<br>    const int bits = bits_required( 0, maxIntegerValue );<br>    uint32_t integerValue = 0;<br>    if ( Stream::IsWriting )<br>    {<br>        float normalizedValue =<br>            clamp( ( value - min ) / delta, 0.0f, 1.0f );<br>        integerValue = (uint32_t) floor( normalizedValue <em><br>                                         maxIntegerValue + 0.5f );<br>    }<br>    if ( !stream.SerializeBits( integerValue, bits ) )<br>    {<br>        return false;<br>    }<br>    if ( Stream::IsReading )<br>    {<br>        const float normalizedValue =<br>            integerValue / float( maxIntegerValue );<br>        value = normalizedValue </em> delta + min;<br>    }<br>    return true;<br>}<br></pre><br><p>Of course we need error checking, so we wrap this with a macro:</p><br><pre>#define serialize_compressed_float( stream, value, min, max )        \<br>  do                                                                 \<br>  {                                                                  \<br>    if ( !serialize_float_internal( stream, value, min, max ) )      \<br>    {                                                                \<br>        return false;                                                \<br>    }                                                                \<br>  } while (0)<br></pre><br><p>And now the basic interface is complete. We can serialize both compressed and uncompressed floating point values over the network.</p><br><h2 id="serializing-vectors-and-quaternions">Serializing Vectors and Quaternions</h2><br><p>Once you can serialize float values it&rsquo;s trivial to serialize vectors over the network. I use a modified version of the <a href="https://github.com/scoopr/vectorial" target="_blank" rel="noopener">vectorial library</a> in my projects and implement serialization for its vector type like this:</p><br><pre>template &lt;typename Stream&gt;<br>bool serialize_vector_internal( Stream &amp; stream,<br>                                vec3f &amp; vector )<br>{<br>    float values[3];<br>    if ( Stream::IsWriting )<br>    {<br>        vector.store( values );<br>    }<br>    serialize_float( stream, values[0] );<br>    serialize_float( stream, values[1] );<br>    serialize_float( stream, values[2] );<br>    if ( Stream::IsReading )<br>    {<br>        vector.load( values );<br>    }<br>    return true;<br>}<br><br>#define serialize_vector( stream, value )                       \<br> do                                                             \<br> {                                                              \<br>     if ( !serialize_vector_internal( stream, value ) )         \<br>     {                                                          \<br>         return false;                                          \<br>     }                                                          \<br> }                                                              \<br> while(0)<br></pre><br><p>If your vector is bounded in some range, then you can compress it:</p><br><pre>template &lt;typename Stream&gt;<br>bool serialize_compressed_vector_internal( Stream &amp; stream,<br>                                           vec3f &amp; vector,<br>                                           float min,<br>                                           float max,<br>                                           float res )<br>{<br>    float values[3];<br>    if ( Stream::IsWriting )<br>    {<br>        vector.store( values );<br>    }<br>    serialize_compressed_float( stream, values[0], min, max, res );<br>    serialize_compressed_float( stream, values[1], min, max, res );<br>    serialize_compressed_float( stream, values[2], min, max, res );<br>    if ( Stream::IsReading )<br>    {<br>        vector.load( values );<br>    }<br>    return true;<br>}<br></pre><br><p>Notice how we are able to build more complex serialization using the primitives we&rsquo;re already created. Using this approach you can easily extend the serialization to support anything you need.</p><br><h2 id="serializing-strings-and-arrays">Serializing Strings and Arrays</h2><br><p>What if you need to serialize a string over the network?</p><br><p>Is it a good idea to send a string over the network with null termination? Not really. You&rsquo;re just asking for trouble! Instead, serialize the string as an array of bytes with the string length in front. Therefore, in order to send a string over the network, we have to work out how to send an array of bytes.</p><br><p>First observation. Why waste effort bitpacking an array of bytes into your bit stream just so they are randomly shifted by [0,7] bits? Why not align to byte so you can memcpy the array of bytes directly into the packet?</p><br><p>To align a bitstream just work out your current bit index in the stream and how many bits of padding are needed until the current bit index divides evenly into 8, then insert that number of padding bits. </p><br><p>For bonus points, pad up with zero bits to add entropy so that on read you can verify that yes, you are reading a byte align and yes, it is indeed padded up with zero bits to the next whole byte bit index. If a non-zero bit is discovered in the padding, <em>abort serialize read and discard the packet</em>.</p><br><p>Here&rsquo;s my code to align a bit stream to byte:</p><br><pre>void BitWriter::WriteAlign()<br>{<br>    const int remainderBits = m_bitsWritten % 8;<br>    if ( remainderBits != 0 )<br>    {<br>        uint32_t zero = 0;<br>        WriteBits( zero, 8 - remainderBits );<br>        assert( ( m_bitsWritten % 8 ) == 0 );<br>    }<br>}<br><br>bool BitReader::ReadAlign()<br>{<br>    const int remainderBits = m_bitsRead % 8;<br>    if ( remainderBits != 0 )<br>    {<br>        uint32_t value = ReadBits( 8 - remainderBits );<br>        assert( m_bitsRead % 8 == 0 );<br>        if ( value != 0 )<br>            return false;<br>    }<br>    return true;<br>}<br><br>#define serialize_align( stream )           \<br>  do                                        \<br>  {                                         \<br>      if ( !stream.SerializeAlign() )       \<br>          return false;                     \<br>  } while (0)<br></pre><br><p>Now we can align to byte prior to writing an array of bytes, letting us use memcpy for the bulk of the array data. The only wrinkle is because the bitpacker works at the word level, it&rsquo;s necessary to have special handling for the head and tail portions. Because of this, the code is quite complex and is omitted for brevity. You can find it in the <a href="https://www.patreon.com/gafferongames" target="_blank" rel="noopener">sample code</a> for this article.</p><br><p>The end result of all this is a <strong>serialize_bytes</strong> primitive that we can use to serialize a string as a length followed by the string data, like so:</p><br><pre>template &lt;typename Stream&gt;<br>bool serialize_string_internal( Stream &amp; stream,<br>                                char <em> string,<br>                                int buffer_size )<br>{<br>    uint32_t length;<br>    if ( Stream::IsWriting )<br>    {<br>        length = strlen( string );<br>        assert( length &lt; buffer_size - 1 );<br>    }<br>    serialize_int( stream, length, 0, buffer_size - 1 );<br>    serialize_bytes( stream, (uint8_t</em>)string, length );<br>    if ( Stream::IsReading )<br>    {<br>        string[length] = ‘\0’;<br>    }<br>}<br><br>#define serialize_string( stream, string, buffer_size )              \<br>do                                                                   \<br>{                                                                    \<br>    if ( !serialize_string_internal( stream,                         \<br>                                     string,                         \<br>                                     buffer_size ) )                 \<br>    {                                                                \<br>        return false;                                                \<br>    }                                                                \<br>} while (0)<br></pre><br><p>This is an ideal string format because it lets us quickly reject malicious data, vs. having to scan through to the end of the packet searching for <strong>&lsquo;\0&rsquo;</strong> before giving up. This is important because otherwise protocol level attacks could be crafted to degrade your server&rsquo;s performance by making it do extra work.</p><br><h2 id="serializing-array-subsets">Serializing Array Subsets</h2><br><p>When implemeting a game network protocol, sooner or later you need to serialize an array of objects over the network. Perhaps the server needs to send object state down to the client, or there is an array of messages to be sent.</p><br><p>This is straightforward if you are sending <em>all</em> objects in the array - just iterate across the array and serialize each object in turn. But what if you want to send a subset of the array?</p><br><p>The simplest approach is to iterate across all objects in the array and serialize a bit per-object if that object is to be sent. If the value of the bit is 1 then the object data follows in the bit stream, otherwise it&rsquo;s ommitted:</p><br><pre>template &lt;typename Stream&gt;<br>bool serialize_scene_a( Stream &amp; stream, Scene &amp; scene )<br>{<br>    for ( int i = 0; i &lt; MaxObjects; ++i )<br>    {<br>        serialize_bool( stream, scene.objects[i].send );<br>        if ( !scene.objects[i].send )<br>        {<br>            if ( Stream::IsReading )<br>            {<br>                memset( &amp;scene.objects[i], 0, sizeof( Object ) );<br>            }<br>            continue;<br>        }<br>        serialize_object( stream, scene.objects[i] );<br>    }<br>    return true;<br>}<br></pre><br><p>This approach breaks down as the size of the array gets larger. For example, for an array size of size 4096, then 4096 / 8 = 512 bytes spent on skip bits. That&rsquo;s not good. Can we switch it around so we take overhead propertional to the number of objects sent instead of the total number of objects in the array?</p><br><p>We can but now, we&rsquo;ve done something interesting. We&rsquo;re walking one set of objects in the serialize write (all objects in the array) and are walking over a different set of objects in the serialize read (subset of objects sent).</p><br><p>At this point the unified serialize function concept starts to breaks down, and in my opinion, it&rsquo;s best to separate the read and write back into separate functions, because they have so little in common:</p><br><pre>bool write_scene_b( WriteStream &amp; stream, Scene &amp; scene )<br>{<br>    int num_objects_sent = 0;<br>    for ( int i = 0; i &lt; MaxObjects; ++i )<br>    {<br>        if ( scene.objects[i].send )<br>            num_objects_sent++;<br>    }<br>    write_int( stream, num_objects_sent, 0, MaxObjects );<br>    for ( int i = 0; i &lt; MaxObjects; ++i )<br>    {<br>        if ( !scene.objects[i].send )<br>        {<br>            continue;<br>        }<br>        write_int( stream, i, 0, MaxObjects - 1 );<br>        write_object( stream, scene.objects[i] );<br>    }<br>    return true;<br>}<br><br>bool read_scene_b( ReadStream &amp; stream, Scene &amp; scene )<br>{<br>    memset( &amp;scene, 0, sizeof( scene ) );<br>    int num_objects_sent;<br>    read_int( stream, num_objects_sent, 0, MaxObjects );<br>    for ( int i = 0; i &lt; num_objects_sent; ++i )<br>    {<br>        int index;<br>        read_int( stream, index, 0, MaxObjects - 1 );<br>        read_object( stream, scene.objects[index] );<br>    }<br>    return true;<br>}<br></pre><br><p>One more point. The code above walks over the set of objects <em>twice</em> on serialize write. Once to determine the number of changed objects and a second time to actually serialize the set of changed objects. Can we do it in one pass instead? Absolutely! You can use another trick, rather than serializing the # of objects in the array up front, use a <em>sentinel value</em> to indicate the end of the array:</p><br><pre>bool write_scene_c( WriteStream &amp; stream, Scene &amp; scene )<br>{<br>    for ( int i = 0; i &lt; MaxObjects; ++i )<br>    {<br>        if ( !scene.objects[i].send )<br>        {<br>            continue;<br>        }<br>        write_int( stream, i, 0, MaxObjects );<br>        write_object( stream, scene.objects[i] );<br>    }<br>    write_int( stream, MaxObjects, 0, MaxObjects );<br>    return true;<br>}<br><br>bool read_scene_c( ReadStream &amp; stream, Scene &amp; scene )<br>{<br>    memset( &amp;scene, 0, sizeof( scene ) );<br>    while ( true )<br>    {<br>        int index; read_int( stream, index, 0, MaxObjects );<br>        if ( index == MaxObjects )<br>        {<br>            break;<br>        }<br>        read_object( stream, scene.objects[index] );<br>    }<br>    return true;<br>}<br></pre><br><p>The above technique works great if the objects sent are a small percentage of total objects. But what if a large number of objects are sent, lets say half of the 4000 objects in the scene. That&rsquo;s 2000 object indices with each index costing 12 bits&hellip; that&rsquo;s 24000 bits or 3000 bytes (almost 3k!) in your packet wasted on indexing.</p><br><p>You can reduce this overhead by encoding each object index relative to the previous object index. Think about it, you&rsquo;re walking from left to right along an array, so object indices start at 0 and go up to MaxObjects - 1. Statistically speaking, you&rsquo;re quite likely to have objects that are close to each other and if the next index is +1 or even +10 or +30 from the previous one, on average, you&rsquo;ll need quite a few less bits to represent that difference than an absolute index.</p><br><p>Here&rsquo;s one way to encode the object index as an integer relative to the previous object index, while spending less bits on statistically more likely values:</p><br><pre>template &lt;typename Stream&gt;<br>bool serialize_object_index_internal( Stream &amp; stream,<br>                                      int &amp; previous,<br>                                      int &amp; current )<br>{<br>    uint32_t difference;<br>    if ( Stream::IsWriting )<br>    {<br>        assert( previous &lt; current );<br>        difference = current - previous;<br>        assert( difference &gt; 0 );<br>    }<br><br>    // +1 (1 bit)<br>    bool plusOne;<br>    if ( Stream::IsWriting )<br>    {<br>       plusOne = difference == 1;<br>    }<br>    serialize_bool( stream, plusOne );<br>    if ( plusOne )<br>    {<br>        if ( Stream::IsReading )<br>        {<br>            current = previous + 1;<br>        }<br>        previous = current;<br>        return true;<br>    }<br><br>    // [+2,5] -&gt; [0,3] (2 bits)<br>    bool twoBits;<br>    if ( Stream::IsWriting )<br>    {<br>        twoBits = difference &lt;= 5;<br>    }<br>    serialize_bool( stream, twoBits );<br>    if ( twoBits )<br>    {<br>        serialize_int( stream, difference, 2, 5 );<br>        if ( Stream::IsReading )<br>        {<br>            current = previous + difference;<br>        }<br>        previous = current;<br>        return true;<br>    }<br><br>    // [6,13] -&gt; [0,7] (3 bits)<br>    bool threeBits;<br>    if ( Stream::IsWriting )<br>    {<br>        threeBits = difference &lt;= 13;<br>    }<br>    serialize_bool( stream, threeBits );<br>    if ( threeBits )<br>    {<br>        serialize_int( stream, difference, 6, 13 );<br>        if ( Stream::IsReading )<br>        {<br>            current = previous + difference;<br>        }<br>        previous = current;<br>        return true;<br>    }<br><br>    // [14,29] -&gt; [0,15] (4 bits)<br>    bool fourBits;<br>    if ( Stream::IsWriting )<br>    {<br>        fourBits = difference &lt;= 29;<br>    }<br>    serialize_bool( stream, fourBits );<br>    if ( fourBits )<br>    {<br>        serialize_int( stream, difference, 14, 29 );<br>        if ( Stream::IsReading )<br>        {<br>            current = previous + difference;<br>        }<br>        previous = current;<br>        return true;<br>    }<br><br>    // [30,61] -&gt; [0,31] (5 bits)<br>    bool fiveBits;<br>    if ( Stream::IsWriting )<br>    {<br>        fiveBits = difference &lt;= 61;<br>    }<br>    serialize_bool( stream, fiveBits );<br>    if ( fiveBits )<br>    {<br>        serialize_int( stream, difference, 30, 61 );<br>        if ( Stream::IsReading )<br>        {<br>            current = previous + difference;<br>        }<br>        previous = current;<br>        return true;<br>    }<br><br>    // [62,125] -&gt; [0,63] (6 bits)<br>    bool sixBits;<br>    if ( Stream::IsWriting )<br>    {<br>        sixBits = difference &lt;= 125;<br>    }<br>    serialize_bool( stream, sixBits );<br>    if ( sixBits )<br>    {<br>        serialize_int( stream, difference, 62, 125 );<br>        if ( Stream::IsReading )<br>        {<br>            current = previous + difference;<br>        }<br>        previous = current;<br>        return true;<br>    }<br><br>    // [126,MaxObjects+1]<br>    serialize_int( stream, difference, 126, MaxObjects + 1 );<br>    if ( Stream::IsReading )<br>    {<br>        current = previous + difference;<br>    }<br>    previous = current;<br>    return true;<br>}<br><br>template &lt;typename Stream&gt;<br>bool serialize_scene_d( Stream &amp; stream, Scene &amp; scene )<br>{<br>    int previous_index = -1;<br><br>    if ( Stream::IsWriting )<br>    {<br>        for ( int i = 0; i &lt; MaxObjects; ++i )<br>        {<br>            if ( !scene.objects[i].send )<br>            {<br>                continue;<br>            }<br>            write_object_index( stream, previous_index, i );<br>            write_object( stream, scene.objects[i] );<br>        }<br>        write_object_index( stream, previous_index, MaxObjects );<br>    }<br>    else<br>    {<br>        while ( true )<br>        {<br>            int index;<br>            read_object_index( stream, previous_index, index );<br>            if ( index == MaxObjects )<br>            {<br>                break;<br>            }<br>            read_object( stream, scene.objects[index] );<br>        }<br>    }<br>    return true;<br>}<br></pre><br><p>But what about the worst case? Won&rsquo;t we spent more bits when indices are &gt;= +126 apart than on an absolute index? Yes we do, but how many of these worst case indices fit in an array of size 4096? Just 32. It&rsquo;s nothing to worry about.</p><br><h2 id="protocol-ids-crc32-and-serialization-checks">Protocol IDs, CRC32 and Serialization Checks</h2><br><p>We are nearly at the end of this article, and you can see by now that we are sending a completely unattributed binary stream. It&rsquo;s essential that read and write match perfectly, which is of course why the serialize functions are so great, it&rsquo;s hard to desync something when you unify read and write.</p><br><p>But accidents happen, and when they do this system can seem like a stack of cards. What if you somehow desync read and write? How can you debug this? What if somebody tries to connect to your latest server code with an old version of your client?</p><br><p>One technique to protect against this is to include a protocol id in your packet. For example, it could be a combination of a unique number for your game, plus the hash of your protocol version and a hash of your game data. Now if a packet comes in from an incompatible game version, it&rsquo;s automatically discarded because the protocol ids don&rsquo;t match:</p><br><pre>[protocol id] (64bits)<br>(packet data)<br></pre><br><p>The next level of protection is to pass a CRC32 over your packet and include that in the header. This lets you pick up corrupt packets (these do happen, remember that the IP checksum is just 16 bits&hellip;). Now your packet header looks like this:</p><br><pre>[protocol id] (64bits)<br>[crc32] (32bits)<br>(packet data)<br></pre><br><p>At this point you may be wincing. Wait. I have to take 8+4 = 12 bytes of overhead per-packet just to implement my own checksum and protocol id? Well actually, <em>you don&rsquo;t</em>. You can take a leaf out of how IPv4 does their checksum, and make the protocol id a <strong>magical prefix</strong>.</p><br><p>This means you don&rsquo;t actually send it, and rely on the fact that if the CRC32 is calculated as if the packet were prefixed by the protocol id, then the CRC32 will be incorrect if the sender does not have the same protocol id as the receiver, thus saving 8 bytes per-packet:</p><br><pre><del>[protocol id] (64bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32bits)<br>(packet data)<br></pre><br><p>One final technique, perhaps as much a check against programmer error on your part and malicious senders (although redundant once you encrypt and sign your packet) is the <em>serialization check</em>. Basically, somewhere mid-packet, either before or after a complicated serialization section, just write out a known 32 bit integer value, and check that it reads back in on the other side with the same value. If the serialize check value is incorrect <em>abort read and discard the packet</em>.</p><br><p>I like to do this between sections of my packet as I write them, so at least I know which part of my packet serialization has desynced read and write as I&rsquo;m developing my protocol. Another cool trick I like to use is to always serialize a protocol check at the very end of the packet, to detect accidental packet truncation (which happens more often than you would think).</p><br><p>Now the packet looks something like this:</p><br><pre><del>[protocol id] (64bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32bits)<br>(packet data)<br>[end of packet serialize check] (32 bits)<br></pre><br><p>This is great packet structure to use during development.</p>


<h1 id="译文">译文</h1>

<p>注意 ：这篇译文对应的是下面的原作者<a href="#原文旧版本">原文旧版本</a>。</p>
<p><a href="http://gad.qq.com/program/translateview/7161833" target="_blank" rel="noopener">译文出处</a></p>
<div class="WordSection1"><b><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">译者：崔嘉艺（</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">milan21</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">） 审校：陈敬凤</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">(nunu)</span></b><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;"> </span></p><p class="MsoNormal" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">在这个系列文章中，我将完全从头开始构建一个专业级别的客户端<span>/</span>服务器游戏网络协议，只使用了<span>C++</span>编译器和一组<span>UDP</span>套接字。如果你正在寻找一个关于如何实现你自己的游戏网络协议方面的详细、实用实现，那么这个系列的文章对你来说就再适合不过了。</span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#2B2B2B;background:#F8F8F8"><br><br></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">大家好，我是<span>Glenn Fiedler</span>，欢迎阅读《构建游戏网络协议》系列教程的第二篇文章。</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">在前面的文章里，我们讨论了在多人在线网络游戏里面读取和写入网络包的不同方法。我们很快就否决了通过文本的格式比如<span>XML</span>和<span>JSON</span>来发送游戏状态的办法因为它们确实在效率上存在比较大的问题，因此我们决定用自定义的二进制格式进行代替。</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们实现了一个位打包器<span>(bitpacker)</span>，所以我们无需手动将几个布尔变量聚成一个<span>8</span>位比特值<span>(</span>以便为了节省空间<span>)</span>，也无需考虑大端小端问题，可以每次写入一个完整的单词而不需要将单词拆成一个个字符，再考虑如何用字节表示它们，这使得位打包器既非常简单也工作的非常快，也无需考虑与平台有关的细节。</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333"> </span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但是我们仍然遗留了以下这些问题需要解决：</span></p><p class="MsoListParagraph" align="left" style="margin-l : initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">1.<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &quot;Times New Roman&quot;;">    </span></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">我们需要实现一个方法来判断整数值是否超出预期范围，如果超出了就要中止网络包的读取和解析，因为会有一些不怀好意的人给我们发送恶意网络包希望我们的程序和内存崩溃掉。网络包的读取和解析的中止必须是自动化的，而且不能使用异常处理，因为异常处理太慢了会拖累我们的程序。</span></p><p class="MsoListParagraph" align="left" style="margin-l : initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">2.<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &quot;Times New Roman&quot;;">    </span></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333">如果独立的读取和写入函数是手动编解码的，那么维护它们真的是一个噩梦。我们希望能够为包一次性的编写好序列化代码并且没有任何运行时的性能消耗（主要是额外的分支、虚化等等）。</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们应该如何实现上面的这些目标<span>? </span>请继续阅读，我将向你展示如何用Ｃ＋＋来实现这些功能。开发和完善这些技术花费了我不少时间，所以我希望这些内容对你来说是有帮助的，至少是一个很好的选择值得考虑是否要替换你目前采用的方案，或者可以与你在其他游戏看到的这个问题解决方案相结合，看是否能得到更好的解决方案。</span></p><p class="MsoNormal" align="left"><span style="font-size:10.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-size:10.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><h2 id="统一的数据包序列化功能"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">统一的数据包序列化功能</span></h2><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">让我们从我们的目标开始。这就是我们在本文结束的时候希望得到的东西：</span></p><div><div id="highlighter_882458" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div><div class="line number35 index34 alt2">35</div><div class="line number36 index35 alt1">36</div><div class="line number37 index36 alt2">37</div><div class="line number38 index37 alt1">38</div><div class="line number39 index38 alt2">39</div><div class="line number40 index39 alt1">40</div><div class="line number41 index40 alt2">41</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">PacketA</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">x,y,z;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces"> </code> </div><div class="line number5 index4 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">template &lt;typename Stream&gt;</code> <code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">       </code><code class="cpp plain">serialize_bits( stream, x, 32 );</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_bits( stream, y, 32 );</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">       </code><code class="cpp plain">serialize_bits( stream, z, 32 );</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number12 index11 alt1"><code class="cpp plain">};</code></div><div class="line number13 index12 alt2"><code class="cpp spaces"> </code> </div><div class="line number14 index13 alt1"><code class="cpp keyword bold">struct</code> <code class="cpp plain">PacketB</code></div><div class="line number15 index14 alt2"><code class="cpp plain">{</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numElements;</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">elements[MaxElements];</code></div><div class="line number18 index17 alt1"><code class="cpp spaces"> </code> </div><div class="line number19 index18 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">template &lt;typename Stream&gt;</code> <code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, numElements, 0, MaxElements );</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; numElements; ++i )</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">           </code><code class="cpp plain">serialize_bits( buffer, elements[i], 32 );</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number26 index25 alt1"><code class="cpp plain">};</code></div><div class="line number27 index26 alt2"><code class="cpp spaces"> </code> </div><div class="line number28 index27 alt1"><code class="cpp keyword bold">struct</code> <code class="cpp plain">PacketC</code></div><div class="line number29 index28 alt2"><code class="cpp plain">{</code></div><div class="line number30 index29 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">x;</code></div><div class="line number31 index30 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">short</code> <code class="cpp plain">y;</code></div><div class="line number32 index31 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">z;</code></div><div class="line number33 index32 alt2"><code class="cpp spaces"> </code> </div><div class="line number34 index33 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">template &lt;typename Stream&gt;</code> <code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number35 index34 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number36 index35 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, x, 8 );</code></div><div class="line number37 index36 alt2"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, y, 16 );</code></div><div class="line number38 index37 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, z, 32 );</code></div><div class="line number39 index38 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number40 index39 alt1"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number41 index40 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">看下上面的代码片段，可以看到每个数据包结构里面都只有一个单独的序列化函数，而不是有互相独立的序列化读取和序列化写入函数。这非常的棒！它把整个序列化代码一分为二，你可能需要做很多努力来实现序列化读取和写入（因为读取的过程是数据解析并装入本地内存，写入的的过程是将本地的数据写到消息体，会有比较大的差异，所以代码基本是一分为二，一半用于读取，一半用于写入）。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果要让这项工作变得有效，诀窍在于让流类型的序列化函数模板化。在我的系统中有两个流类型：<span>ReadStream</span>类和<span>WriteStream</span>类。每个类都有相同的一套方法，但实际上它们没有任何关系。一个类负责从比特流读取值到变量中，另外一个类负责把变量的值写到流中。<span>ReadStream</span>和<span>WriteStream</span>只是上一篇文章中<span>BitReader</span>和<span>BitWriter</span>类的一个高层次封装。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">当然也有其他方法可以用来代替。如果你不喜欢用模板的话，你可以使用一个纯虚的基类作为流的接口，然后分别实现读取和写入类来实现这个流接口。但是如果你这么做的话，就要在每个序列化调用的时候发生了一次虚函数调用。这种方法对我来说开销似乎比较大。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">实现这个功能的另外一种方法是实现一个超级棒的流类型，可以通过配置而在运行时进入读取或者写入模式。这种方法会比虚函数方法快一些，但是仍然会在每次序列化调用的时候存在分支判断到底应该是读还是写，所以它不如硬编码读取和写入函数那么快。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我更喜欢模板方法，因为它可以让编译器为项目产生经过优化的读取<span>/</span>写入函数。你甚至可以把序列化代码也这样实现以便让编译器为特定的读取和写入优化一大堆东西：</span></p><div><div id="highlighter_37287" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">struct RigidBody</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">   </code><code class="cpp plain">vec3f position;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">   </code><code class="cpp plain">quat3f orientation;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">   </code><code class="cpp plain">vec3f linear_velocity;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">   </code><code class="cpp plain">vec3f angular_velocity;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces"> </code> </div><div class="line number8 index7 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">template &lt;typename Stream&gt;</code> <code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_vector( stream, position );</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">       </code><code class="cpp plain">serialize_quaternion( stream, orientation );</code></div><div class="line number12 index11 alt1"><code class="cpp spaces"> </code> </div><div class="line number13 index12 alt2"><code class="cpp spaces">       </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">at_rest = Stream::IsWriting ? velocity.length() == 0 : 1;</code></div><div class="line number14 index13 alt1"><code class="cpp spaces"> </code> </div><div class="line number15 index14 alt2"><code class="cpp spaces">       </code><code class="cpp plain">serialize_bool( stream, at_rest );</code></div><div class="line number16 index15 alt1"><code class="cpp spaces"> </code> </div><div class="line number17 index16 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !at_rest )</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">       </code><code class="cpp plain">{</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">           </code><code class="cpp plain">serialize_vector( stream, linear_velocity );</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">           </code><code class="cpp plain">serialize_vector( stream, angular_velocity );</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">       </code><code class="cpp plain">}</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">else</code> <code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">       </code><code class="cpp plain">{</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">           </code><code class="cpp plain">linear_velocity = vec3f(0,0,0);</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">           </code><code class="cpp plain">angular_velocity = vec3f(0,0,0);</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">       </code><code class="cpp plain">}</code></div><div class="line number27 index26 alt2"><code class="cpp spaces"> </code> </div><div class="line number28 index27 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number29 index28 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number30 index29 alt1"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">虽然这看起来很没有效率，但是实际上并不是！这个函数经过模板特化以后会根据流的类型优化了所有分支。这很整齐漂亮吧？</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><br><br>而ReadStream和WriteStream是这样的 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class WriteStream</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    enum &#123; IsWriting = 1 &#125;;</span><br><span class="line">    enum &#123; IsReading = 0 &#125;;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ReadStream</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    enum &#123; IsWriting = 0 &#125;;</span><br><span class="line">    enum &#123; IsReading = 1 &#125;;</span><br><span class="line">    // ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2 id="边界检查和终止读取"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">边界检查和终止读取</span></h2><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在我们通过编译器实现了生成优化过的序列化读取<span>/</span>写入函数，我们还需要一些方法来做序列化读取时候的自动错误检测以便让我们不受恶意网络包的影响。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们要做的第一件事情是把允许的大小范围也传给序列化函数而不仅仅是所需的比特数量。试想一下如果有了最小和最大的范围，序列化函数就能自己算出所需的比特数量：</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:10.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">serialize_int(stream, numElements, 0, MaxElements );</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这种做法开辟了一类新的方法，可以非常容易地支持带符号整数的序列化并且序列化函数可以检测从网络中读取的值并确保这个值一定在期望的范围内。如果这个值超出范围了，就立即中止序列化读取并丢弃这个数据包。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">因为我们没有办法使用异常来处理这种中止（因为异常太慢了），所以上面的方式是我比较喜欢的处理方式。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">在我的环境中，<span>serialize_int</span>其实并不是一个函数，它实际是一个如下面代码所示的宏：</span></p><div><div id="highlighter_611774" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp preprocessor">#define serialize_int( stream, value, min, max)                   \</code></div><div class="line number2 index1 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">do</code>                                                             <code class="cpp plain">\</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{                                                              \</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">       </code><code class="cpp functions bold">assert</code><code class="cpp plain">( min &lt; max);                                       \</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">       </code><code class="cpp plain">int32_tint32_value;                                       \</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting)                                   \</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">       </code><code class="cpp plain">{                                                          \</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">           </code><code class="cpp functions bold">assert</code><code class="cpp plain">( value &gt;= min);                                \</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">           </code><code class="cpp functions bold">assert</code><code class="cpp plain">( value &lt;= max);                                 \</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">           </code><code class="cpp plain">int32_value = (int32_t)value;                         \</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">       </code><code class="cpp plain">}                                                          \</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !stream.SerializeInteger( int32_value, min, max ) )    \</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">           </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;                                          \</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading)                                   \</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">       </code><code class="cpp plain">{                                                          \</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">           </code><code class="cpp plain">value =int32_value;                                   \</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">           </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( value &lt; min || value &gt; max)                      \</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">               </code><code class="cpp plain">return false;                                      \</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">       </code><code class="cpp plain">}                                                          \</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">    </code><code class="cpp plain">} </code><code class="cpp keyword bold">while</code> <code class="cpp plain">(0)</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left" style="margin: 0cm 18.05pt 0.0001pt; line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">我让人觉得恐怖害怕的原因是我竟然使用了宏来插入代码来检测</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">SerializeInteger</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">函数的结果以及在发生错误的时候返回</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">false</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">。这会让人感觉到这种行为和异常处理很像，它会在出错的时候回溯堆栈到序列化调用堆栈的最顶上，但是这种处理不会带来任何的问题比如性能的消耗。在回溯的时候出现分支是非常罕见的（序列化错误非常少见）所以分支预测应该不会带来什么性能上的问题。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">还有一种情况我们也需要中止序列化读取：如果流读取超出了结尾。这种情况其实也是非常罕见的，但是我们必须在每次序列化操作都进行这个检查，这是因为流读取超出结尾会造成的影响是未定义的（也就是说我们对于它能造成什么样子的结果完全是未知的，最糟糕的情况并不是代码崩溃，而是把我们的内容数据完全搞乱了，相信我，你会无比痛恨这件事情）。如果我们没有做这个检测，可能会出现程序无限循环的情况，因为读取的位置超出了缓冲区的结尾。虽然在读取的时候如果发现超出比特流结尾的时候返回<span>0</span>值是很常见的做法（如以前的文章提到的那样），但是返回<span>0</span>值也不能保证序列化函数在有循环的时候能够正确的中止。如果要确保程序是有良好定义的行为，那么这种缓冲溢出检测总是必须的。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">最后一点，在序列化写入的时候如果遇到范围检测失败或者写入的地址超出流的结尾的时候，我并没有采用中止这种做法。在写入数据的时候你可能会轻松很多，因为如果有任何事情出错了，那几乎肯定是你自己导致的错误。在序列化写入的时候我们只是对每个序列化写入做了断言来确保一切是符合预期的（在范围内、写入的地址没有超出流的结尾），其他的一切都任由你来发挥。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><h2 id="序列化浮点数和向量"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">序列化浮点数和向量</span></h2><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这个比特流现在只序列化类型整数的值。如果我们要序列化一个类型为浮点数的值，我们该怎么做？</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们的做法虽然看上去有点投机取巧但实际上并不是。在内存中浮点数也是像整数那样保存成一个<span>32</span>位的值。你的计算机根本不知道内存中的这个<span>32</span>位的值到底是一个整数还是一个浮点数还是一个字符串的部分。它知道的就是这仅仅是一个<span>32</span>位的值。幸运的是，<span>C++</span>语言使得我们可以直接对这个基础属性进行控制（其他语言不行，因为底层被封装掉了，这也是<span>C++</span>被认为不好的地方之一，很多现代语言都禁止了这种做法）。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">你可以通过一个联合体来访问看上去是整数的浮点数：</span></p><div><div id="highlighter_59188" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">union</code> <code class="cpp plain">FloatInt</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">float</code> <code class="cpp plain">float_value;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">   </code><code class="cpp plain">uint32_t int_value;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">};</code></div><div class="line number6 index5 alt1"><code class="cpp spaces"> </code> </div><div class="line number7 index6 alt2"><code class="cpp plain">FloatInt tmp;</code></div><div class="line number8 index7 alt1"><code class="cpp plain">tmp.float_value= 10.0f;</code></div><div class="line number9 index8 alt2"><code class="cpp functions bold">printf</code><code class="cpp plain">(</code><code class="cpp string">“float value as an integer: %x\n”</code><code class="cpp plain">, tmp.int_value );</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">你也可以通过别名<span>uint32_t<em></em></span>的指针来做到这一点，但是因为<span>GCC -O2</span>会导致这种做法有些性能问题，所以我更倾向于使用联合体这种做法。我的朋友们指出（很有可能是正确的）从一个整数类型的值转换到浮点值的唯一真正标准的做法是将浮点数指针转换成<span>uint8_t</span>指针然后通过这个字节指针来分别引用<span>4</span>个字节来对这个值进行重建。虽然这对我来说似乎是一个非常愚蠢的做法。女士们，先生们。。。这毕竟是<span>C++</span>啊！（作者的意思是<span>C++</span>提供了很多接触底层的方法，我们可以尽情利用这一优势，只要能保证结果是正确的就可以了，哪怕使用一些取巧的办法也无所谓！）。</span></p><p class="MsoNormal" align="left"><span style="font-size:10.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">与此同时，在过去的<span>5</span>年里，在使用联合体这个技巧方面我还没有遇到过什么问题。下面是我如何序列化一个未压缩的浮点值：</span></p><div><div id="highlighter_22654" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">bool serialize_float_internal( Stream &amp; stream,</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">                              </code><code class="cpp color1 bold">float</code> <code class="cpp plain">&amp; value )</code></div><div class="line number4 index3 alt1"><code class="cpp plain">{</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">union</code> <code class="cpp plain">FloatInt</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">       </code><code class="cpp color1 bold">float</code> <code class="cpp plain">float_value;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">       </code><code class="cpp plain">uint32_t int_value;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">   </code><code class="cpp plain">};</code></div><div class="line number10 index9 alt1"><code class="cpp spaces"> </code> </div><div class="line number11 index10 alt2"><code class="cpp spaces">   </code><code class="cpp plain">FloatInt tmp;</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">       </code><code class="cpp plain">tmp.float_value = value;</code></div><div class="line number14 index13 alt1"><code class="cpp spaces"> </code> </div><div class="line number15 index14 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">result = stream.SerializeBits( tmp.int_value, 32 );</code></div><div class="line number16 index15 alt1"><code class="cpp spaces"> </code> </div><div class="line number17 index16 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">       </code><code class="cpp plain">value = tmp.float_value;</code></div><div class="line number19 index18 alt2"><code class="cpp spaces"> </code> </div><div class="line number20 index19 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp plain">result;</code></div><div class="line number21 index20 alt2"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin: 0cm 18.05pt 0.0001pt; line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">通过一个<span>serialize_float</span>宏来包装这个部分以方便在序列化读取的时候方便进行一致的错误检测：</span></p><div><div id="highlighter_519243" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp preprocessor">#define serialize_float( stream, value)                            \</code></div><div class="line number2 index1 alt1"><code class="cpp spaces"> </code><code class="cpp keyword bold">do</code>                                                                <code class="cpp plain">\</code></div><div class="line number3 index2 alt2"><code class="cpp spaces"> </code><code class="cpp plain">{                                                                 \</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !protocol2::serialize_float_internal( stream, value ))     \</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">       </code><code class="cpp plain">return false;                                               \</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">  </code><code class="cpp plain">} </code><code class="cpp keyword bold">while</code><code class="cpp plain">(0)</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">有些时候，你并不想把一个完整精度的浮点数进行传递。那么该如何压缩这个浮点值？第一步是将它的值限制在某个确定的范围内然后用一个整数表示方式来将它量化。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">举个例子来说，如果你知道一个浮点类型的值是在区间<span>[-10,+10]</span>，对于这个值来说可以接受的精确度是<span>0.01</span>，那么你可以把这个浮点数乘以<span>100.0</span>让它的值在区间<span>[-1000,+1000]</span>并在网络上将其作为一个整数进行序列化。而在接收的那一端，仅仅需要将它除以<span>100.0</span>来得到最初的浮点值。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">下面是这个概念用序列化实现的版本：</span></p><div><div id="highlighter_981553" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">boolserialize_compressed_float_internal( Stream &amp; stream,</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">                                         </code><code class="cpp color1 bold">float</code> <code class="cpp plain">&amp; value,</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">                                         </code><code class="cpp color1 bold">float</code> <code class="cpp plain">min,</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">                                         </code><code class="cpp color1 bold">float</code> <code class="cpp plain">max,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">                                         </code><code class="cpp color1 bold">float</code> <code class="cpp plain">res )</code></div><div class="line number7 index6 alt2"><code class="cpp plain">{</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">float</code> <code class="cpp plain">delta = max - min;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">float</code> <code class="cpp plain">values = delta / res;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">const</code> <code class="cpp plain">uint32_t maxIntegerValue = (uint32_t) </code><code class="cpp functions bold">ceil</code><code class="cpp plain">( values );</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">bits = bits_required( 0, maxIntegerValue );</code></div><div class="line number12 index11 alt1"><code class="cpp spaces"> </code> </div><div class="line number13 index12 alt2"><code class="cpp spaces">   </code><code class="cpp plain">uint32_t integerValue = 0;</code></div><div class="line number14 index13 alt1"><code class="cpp spaces"> </code> </div><div class="line number15 index14 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">       </code><code class="cpp color1 bold">float</code> <code class="cpp plain">normalizedValue =</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">           </code><code class="cpp plain">clamp( ( value - min ) / delta, 0.0f, 1.0f );</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">       </code><code class="cpp plain">integerValue = (uint32_t) </code><code class="cpp functions bold">floor</code><code class="cpp plain">( normalizedValue <em></em></code></div><div class="line number20 index19 alt1"><code class="cpp spaces">                                        </code><code class="cpp plain">maxIntegerValue + 0.5f );</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number22 index21 alt1"><code class="cpp spaces"> </code> </div><div class="line number23 index22 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !stream.SerializeBits( integerValue, bits ) )</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;</code></div><div class="line number25 index24 alt2"><code class="cpp spaces"> </code> </div><div class="line number26 index25 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">float</code> <code class="cpp plain">normalizedValue =</code></div><div class="line number29 index28 alt2"><code class="cpp spaces">           </code><code class="cpp plain">integerValue / </code><code class="cpp color1 bold">float</code><code class="cpp plain">( maxIntegerValue );</code></div><div class="line number30 index29 alt1"><code class="cpp spaces">       </code><code class="cpp plain">value = normalizedValue  delta + min;</code></div><div class="line number31 index30 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number32 index31 alt1"><code class="cpp spaces"> </code> </div><div class="line number33 index32 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number34 index33 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin: 0cm 18.05pt 0.0001pt; line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">一旦你实现了对浮点数的序列化，那么将方法拓展下通过网络序列化向量和四元数就非常容易了。我在我自己的项目中使用了这个超赞的针对向量数学的向量库（<span><a href="https://github.com/scoopr/vectorial" target="_blank" rel="noopener">https://github.com/scoopr/vectorial</a></span>）的一个修改版本，并且我对这些类型实现的序列化方法如下所示：</span></p><div><div id="highlighter_3804" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div><div class="line number35 index34 alt2">35</div><div class="line number36 index35 alt1">36</div><div class="line number37 index36 alt2">37</div><div class="line number38 index37 alt1">38</div><div class="line number39 index38 alt2">39</div><div class="line number40 index39 alt1">40</div><div class="line number41 index40 alt2">41</div><div class="line number42 index41 alt1">42</div><div class="line number43 index42 alt2">43</div><div class="line number44 index43 alt1">44</div><div class="line number45 index44 alt2">45</div><div class="line number46 index45 alt1">46</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">boolserialize_vector_internal( Stream &amp; stream,</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">                               </code><code class="cpp plain">vec3f &amp; vector )</code></div><div class="line number4 index3 alt1"><code class="cpp plain">{</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">float</code> <code class="cpp plain">values[3];</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">       </code><code class="cpp plain">vector.store( values );</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">   </code><code class="cpp plain">serialize_float( stream, values[0] );</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_float( stream, values[1] );</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">   </code><code class="cpp plain">serialize_float( stream, values[2] );</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">       </code><code class="cpp plain">vector.load( values );</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number14 index13 alt1"><code class="cpp plain">}</code></div><div class="line number15 index14 alt2"><code class="cpp spaces"> </code> </div><div class="line number16 index15 alt1"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number17 index16 alt2"><code class="cpp plain">boolserialize_quaternion_internal( Stream &amp; stream,</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">                                   </code><code class="cpp plain">quat4f &amp; quaternion )</code></div><div class="line number19 index18 alt2"><code class="cpp plain">{</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">float</code> <code class="cpp plain">values[4];</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">       </code><code class="cpp plain">quaternion.store( values );</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_float( stream, values[0] );</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">   </code><code class="cpp plain">serialize_float( stream, values[1] );</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_float( stream, values[2] );</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">   </code><code class="cpp plain">serialize_float( stream, values[3] );</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">       </code><code class="cpp plain">quaternion.load( values );</code></div><div class="line number29 index28 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number30 index29 alt1"><code class="cpp plain">}</code></div><div class="line number31 index30 alt2"><code class="cpp spaces"> </code> </div><div class="line number32 index31 alt1"><code class="cpp preprocessor">#defineserialize_vector( stream, value)                      \</code></div><div class="line number33 index32 alt2"><code class="cpp spaces"> </code><code class="cpp keyword bold">do</code>                                                            <code class="cpp plain">\</code></div><div class="line number34 index33 alt1"><code class="cpp spaces"> </code><code class="cpp plain">{                                                             \</code></div><div class="line number35 index34 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !serialize_vector_internal( stream, value ))         \</code></div><div class="line number36 index35 alt1"><code class="cpp spaces">        </code><code class="cpp plain">return false;                                         \</code></div><div class="line number37 index36 alt2"><code class="cpp spaces"> </code><code class="cpp plain">}                                                             \</code></div><div class="line number38 index37 alt1"><code class="cpp spaces"> </code><code class="cpp keyword bold">while</code><code class="cpp plain">(0)</code></div><div class="line number39 index38 alt2"><code class="cpp spaces"> </code> </div><div class="line number40 index39 alt1"><code class="cpp preprocessor">#defineserialize_quaternion( stream, value)                  \</code></div><div class="line number41 index40 alt2"><code class="cpp spaces"> </code><code class="cpp keyword bold">do</code>                                                            <code class="cpp plain">\</code></div><div class="line number42 index41 alt1"><code class="cpp spaces"> </code><code class="cpp plain">{                                                             \</code></div><div class="line number43 index42 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !serialize_quaternion_internal( stream, value ) )    \</code></div><div class="line number44 index43 alt1"><code class="cpp spaces">        </code><code class="cpp plain">return false;                                         \</code></div><div class="line number45 index44 alt2"><code class="cpp spaces"> </code><code class="cpp plain">}                                                             \</code></div><div class="line number46 index45 alt1"><code class="cpp spaces"> </code><code class="cpp keyword bold">while</code><code class="cpp plain">(0)</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果你知道你的向量的取值会限制在某个范围内，你可以像下面这样对它进行压缩：</span></p><div><div id="highlighter_90817" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code> <code class="cpp plain">&lt;</code><code class="cpp keyword bold">typename</code> <code class="cpp plain">stream=</code><code class="cpp string">“”</code><code class="cpp plain">&gt;</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp color1 bold">bool</code> <code class="cpp plain">serialize_compressed_vector_internal( Stream &amp; stream,</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp spaces">                                           </code><code class="cpp plain">vec3f &amp; vector,</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">                                           </code><code class="cpp color1 bold">float</code> <code class="cpp plain">min,</code></div><div class="line number8 index7 alt1"> </div><div class="line number9 index8 alt2"><code class="cpp spaces">                                           </code><code class="cpp color1 bold">float</code> <code class="cpp plain">max,</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp spaces">                                           </code><code class="cpp color1 bold">float</code> <code class="cpp plain">res )</code></div><div class="line number12 index11 alt1"> </div><div class="line number13 index12 alt2"><code class="cpp plain">{</code></div><div class="line number14 index13 alt1"> </div><div class="line number15 index14 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">float</code> <code class="cpp plain">values[3];</code></div><div class="line number16 index15 alt1"> </div><div class="line number17 index16 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number18 index17 alt1"> </div><div class="line number19 index18 alt2"><code class="cpp spaces">        </code><code class="cpp plain">vector.store( values );</code></div><div class="line number20 index19 alt1"> </div><div class="line number21 index20 alt2"><code class="cpp spaces">    </code><code class="cpp plain">serialize_compressed_float( stream, values[0], min, max, res );</code></div><div class="line number22 index21 alt1"> </div><div class="line number23 index22 alt2"><code class="cpp spaces">    </code><code class="cpp plain">serialize_compressed_float( stream, values[1], min, max, res );</code></div><div class="line number24 index23 alt1"> </div><div class="line number25 index24 alt2"><code class="cpp spaces">    </code><code class="cpp plain">serialize_compressed_float( stream, values[2], min, max, res );</code></div><div class="line number26 index25 alt1"> </div><div class="line number27 index26 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number28 index27 alt1"> </div><div class="line number29 index28 alt2"><code class="cpp spaces">        </code><code class="cpp plain">vector.load( values );</code></div><div class="line number30 index29 alt1"> </div><div class="line number31 index30 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number32 index31 alt1"> </div><div class="line number33 index32 alt2"><code class="cpp plain">}&lt;/</code><code class="cpp keyword bold">typename</code><code class="cpp plain">&gt;</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">你如果想要在网络上压缩一个方向，不要把它视为四个取值范围在<span>[-1,+1]</span>的成员变量的结构。如果使用这个四元数的三个最小值来表示它效果会好的多，请看下这篇文章的示例代码<span>(</span>地址在<span><a href="https://www.patreon.com/gafferongames?ty=h" target="_blank" rel="noopener">https://www.patreon.com/gafferongames?ty=h</a>)</span>来得到一个这方面的实现。</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span><a rel="nofollow" href="http://baike.baidu.com/view/319754.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>四元数</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">是简单的</span><span><a rel="nofollow" href="http://baike.baidu.com/view/1383306.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>超复数</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">。 </span><span><a rel="nofollow" href="http://baike.baidu.com/view/10078.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>复数</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">是由</span><span><a rel="nofollow" href="http://baike.baidu.com/view/14749.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>实数</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">加上虚数单位<span> i </span>组成，其中<span>i^2 = -1</span>。 相似地，</span><span><a rel="nofollow" href="http://baike.baidu.com/view/319754.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>四元数</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">都是由实数加上三个虚数单位<span> i</span>、<span>j</span>、<span>k </span>组成，而且它们有如下的关系：<span> i^2 = j^2 = k^2 = -1</span>，<span> i^0 = j^0 = k^0 = 1 , </span>每个四元数都是<span> 1</span>、<span>i</span>、<span>j </span>和<span> k </span>的线性组合，即是四元数一般可表示为<span>a + bk+ cj + di</span>，其中<span>a</span>、<span>b</span>、<span>c </span>、<span>d</span>是实数。</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">对于<span>i</span>、<span>j</span>、<span>k</span>本身的几何意义可以理解为一种旋转，其中<span>i</span>旋转代表<span>X</span>轴与<span>Y</span>轴相交平面中<span>X</span>轴正向向<span>Y</span>轴正向的旋转，<span>j</span>旋转代表<span>Z</span>轴与<span>X</span>轴相交平面中<span>Z</span>轴正向向<span>X</span>轴正向的旋转，<span>k</span>旋转代表<span>Y</span>轴与<span>Z</span>轴相交平面中<span>Y</span>轴正向向<span>Z</span>轴正向的旋转，<span>-i</span>、<span>-j</span>、<span>-k</span>分别代表<span>i</span>、<span>j</span>、<span>k</span>旋转的反向旋转。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><h2 id="序列化字符串和数组"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">序列化字符串和数组</span></h2><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果你想序列化字符串并通过网络传输该怎么办？</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">在网络上发送字符串的时候用<span>Null</span>作为终止符是个好主意么？我不这么认为。我认为这么做只是在自找麻烦！我们应该把字符串作为带长度作为前缀的字符数组。所以，要通过网络发送字符串，我们必须解决如何有效的发送字符数组的问题。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">观察到的第一个事情：为什么要费那么大精力把一个字节数组按比特打包到你的比特流里?只是为了让它们随机的偏移<span>[0,7]</span>比特？为什么不在序列化写入之前进行按字节进行对齐？Why not align to byte so you can memcpy the array of bytes directly into the packet?如果这么处理的话，数据包里面的字节数组数据就很对齐的很准，数组的每个字节都对应着数据包里面的一个实际字节。对于每个要序列化的字节数组，你只损失了<span>[0,7]</span>个比特，这取决于对齐的方式，但是以我的观点来看这没什么好在意的。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如何将比特流按字节对齐？只需要在流的当前位置做些计算就可以了，找出还差写入多少个比特就能让当前比特流的比特数量被<span>8</span>整除，然后按照这个数字插入填充比特（比如当前比特流的比特数量是<span>323</span>，那么<span>323+5</span>才能被<span>8</span>整除，所以需要插入<span>5</span>个填充比特）。对于填充比特来说，填充的比特值都是<span>0</span>，这样当你序列化读取的时候你可以进行检测，如果检测的结果是正确的，那么就确实是在读取填充的部分，并且填充的部分确实是<span>0</span>。一直读取到下一个完整字节的比特起始位置（可以被<span>8</span>整除的位置）。如果检测的结果是在应该填充的地方发现了非<span>0</span>的比特值，那么就中止序列化读取并丢弃这个数据包。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">下面是我用来将比特流按比特对齐的代码：</span></p><div><div id="highlighter_972905" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">void BitWriter::WriteAlign()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">remainderBits = m_bitsWritten % 8;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( remainderBits != 0 )</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">       </code><code class="cpp plain">uint32_t zero = 0;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">       </code><code class="cpp plain">WriteBits( zero, 8 - remainderBits );</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">       </code><code class="cpp functions bold">assert</code><code class="cpp plain">( ( m_bitsWritten % 8 ) == 0 );</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number10 index9 alt1"><code class="cpp plain">}</code></div><div class="line number11 index10 alt2"><code class="cpp spaces"> </code> </div><div class="line number12 index11 alt1"><code class="cpp plain">bool BitReader::ReadAlign()</code></div><div class="line number13 index12 alt2"><code class="cpp plain">{</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">remainderBits = m_bitsRead % 8;</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( remainderBits != 0 )</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">       </code><code class="cpp plain">uint32_t value = ReadBits( 8 - remainderBits );</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">       </code><code class="cpp functions bold">assert</code><code class="cpp plain">( m_bitsRead % 8 == 0 );</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( value != 0 )</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">           </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number23 index22 alt2"><code class="cpp plain">}</code></div><div class="line number24 index23 alt1"><code class="cpp spaces"> </code> </div><div class="line number25 index24 alt2"><code class="cpp preprocessor">#define serialize_align( stream)           \</code></div><div class="line number26 index25 alt1"><code class="cpp spaces"> </code><code class="cpp keyword bold">do</code>                                       <code class="cpp plain">\</code></div><div class="line number27 index26 alt2"><code class="cpp spaces"> </code><code class="cpp plain">{                                        \</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">     </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !stream.SerializeAlign() )       \</code></div><div class="line number29 index28 alt2"><code class="cpp spaces">         </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">false</code><code class="cpp plain">;                    \</code></div><div class="line number30 index29 alt1"><code class="cpp spaces">  </code><code class="cpp plain">} </code><code class="cpp keyword bold">while</code><code class="cpp plain">(0)</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在我们可以使用这个对齐操作来有效率的将字节数组写入比特流：因为我们已经将比特流按照字节对齐了，所以我们可以使用<span>memcpy</span>方法来做大部分的工作。唯一的问题在于比特读取器和比特写入器是按照双字进行工作的，所以需要一些特殊的代码来处理字节数组的头部和尾部，以确保头部的零散比特会被写入内存，并且在头部处理完毕以后，读取的位置会被正确设置到下一个字节。</span></p><div><div id="highlighter_313109" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div><div class="line number35 index34 alt2">35</div><div class="line number36 index35 alt1">36</div><div class="line number37 index36 alt2">37</div><div class="line number38 index37 alt1">38</div><div class="line number39 index38 alt2">39</div><div class="line number40 index39 alt1">40</div><div class="line number41 index40 alt2">41</div><div class="line number42 index41 alt1">42</div><div class="line number43 index42 alt2">43</div><div class="line number44 index43 alt1">44</div><div class="line number45 index44 alt2">45</div><div class="line number46 index45 alt1">46</div><div class="line number47 index46 alt2">47</div><div class="line number48 index47 alt1">48</div><div class="line number49 index48 alt2">49</div><div class="line number50 index49 alt1">50</div><div class="line number51 index50 alt2">51</div><div class="line number52 index51 alt1">52</div><div class="line number53 index52 alt2">53</div><div class="line number54 index53 alt1">54</div><div class="line number55 index54 alt2">55</div><div class="line number56 index55 alt1">56</div><div class="line number57 index56 alt2">57</div><div class="line number58 index57 alt1">58</div><div class="line number59 index58 alt2">59</div><div class="line number60 index59 alt1">60</div><div class="line number61 index60 alt2">61</div><div class="line number62 index61 alt1">62</div><div class="line number63 index62 alt2">63</div><div class="line number64 index63 alt1">64</div><div class="line number65 index64 alt2">65</div><div class="line number66 index65 alt1">66</div><div class="line number67 index66 alt2">67</div><div class="line number68 index67 alt1">68</div><div class="line number69 index68 alt2">69</div><div class="line number70 index69 alt1">70</div><div class="line number71 index70 alt2">71</div><div class="line number72 index71 alt1">72</div><div class="line number73 index72 alt2">73</div><div class="line number74 index73 alt1">74</div><div class="line number75 index74 alt2">75</div><div class="line number76 index75 alt1">76</div><div class="line number77 index76 alt2">77</div><div class="line number78 index77 alt1">78</div><div class="line number79 index78 alt2">79</div><div class="line number80 index79 alt1">80</div><div class="line number81 index80 alt2">81</div><div class="line number82 index81 alt1">82</div><div class="line number83 index82 alt2">83</div><div class="line number84 index83 alt1">84</div><div class="line number85 index84 alt2">85</div><div class="line number86 index85 alt1">86</div><div class="line number87 index86 alt2">87</div><div class="line number88 index87 alt1">88</div><div class="line number89 index88 alt2">89</div><div class="line number90 index89 alt1">90</div><div class="line number91 index90 alt2">91</div><div class="line number92 index91 alt1">92</div><div class="line number93 index92 alt2">93</div><div class="line number94 index93 alt1">94</div><div class="line number95 index94 alt2">95</div><div class="line number96 index95 alt1">96</div><div class="line number97 index96 alt2">97</div><div class="line number98 index97 alt1">98</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">void BitWriter::WriteBytes( </code><code class="cpp keyword bold">const</code> <code class="cpp plain">uint8_t<em> data, </em></code><code class="cpp color1 bold">int</code> <code class="cpp plain">bytes )</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( GetAlignBits() == 0 );</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( m_bitsWritten + bytes  8 &lt;= m_numBits );</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( ( m_bitsWritten % 32 ) == 0 ||</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">           </code><code class="cpp plain">( m_bitsWritten % 32 ) == 8||             </code></div><div class="line number7 index6 alt2"><code class="cpp spaces">           </code><code class="cpp plain">( m_bitsWritten % 32 ) == 16 ||</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">           </code><code class="cpp plain">( m_bitsWritten % 32 ) == 24 );</code></div><div class="line number9 index8 alt2"><code class="cpp spaces"> </code> </div><div class="line number10 index9 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">headBytes = ( 4 - ( m_bitsWritten % 32 ) / 8 ) % 4;</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( headBytes &gt; bytes )</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">       </code><code class="cpp plain">headBytes = bytes;</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; headBytes; ++i )</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">       </code><code class="cpp plain">WriteBits( data[i], 8 );</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( headBytes == bytes )</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code><code class="cpp plain">;</code></div><div class="line number17 index16 alt2"><code class="cpp spaces"> </code> </div><div class="line number18 index17 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( GetAlignBits() == 0 );</code></div><div class="line number19 index18 alt2"><code class="cpp spaces"> </code> </div><div class="line number20 index19 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numWords = ( bytes - headBytes ) / 4;</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( numWords &gt; 0 )</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">       </code><code class="cpp functions bold">assert</code><code class="cpp plain">( ( m_bitsWritten % 32 ) == 0 );</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">       </code><code class="cpp functions bold">memcpy</code><code class="cpp plain">( &amp;m_data[m_wordIndex], data+headBytes, numWords<em>4 );</em></code></div><div class="line number25 index24 alt2"><code class="cpp spaces">       </code><code class="cpp plain">m_bitsWritten += numWords  32;</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">       </code><code class="cpp plain">m_wordIndex += numWords;</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">       </code><code class="cpp plain">m_scratch = 0;</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number29 index28 alt2"><code class="cpp spaces"> </code> </div><div class="line number30 index29 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( GetAlignBits() == 0 );</code></div><div class="line number31 index30 alt2"><code class="cpp spaces"> </code> </div><div class="line number32 index31 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">tailStart = headBytes + numWords <em> 4;</em></code></div><div class="line number33 index32 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">tailBytes = bytes - tailStart;</code></div><div class="line number34 index33 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( tailBytes &gt;= 0 &amp;&amp; tailBytes &lt; 4 );</code></div><div class="line number35 index34 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; tailBytes; ++i )</code></div><div class="line number36 index35 alt1"><code class="cpp spaces">       </code><code class="cpp plain">WriteBits( data[tailStart+i], 8 );</code></div><div class="line number37 index36 alt2"><code class="cpp spaces"> </code> </div><div class="line number38 index37 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( GetAlignBits() == 0 );</code></div><div class="line number39 index38 alt2"><code class="cpp spaces"> </code> </div><div class="line number40 index39 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( headBytes + numWords  4 + tailBytes == bytes );</code></div><div class="line number41 index40 alt2"><code class="cpp plain">}</code></div><div class="line number42 index41 alt1"><code class="cpp spaces"> </code> </div><div class="line number43 index42 alt2"><code class="cpp plain">void ReadBytes( uint8_t<em> data, </em></code><code class="cpp color1 bold">int</code> <code class="cpp plain">bytes )</code></div><div class="line number44 index43 alt1"><code class="cpp plain">{</code></div><div class="line number45 index44 alt2"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( GetAlignBits() == 0 );</code></div><div class="line number46 index45 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( m_bitsRead + bytes  8 &lt;= m_numBits );</code></div><div class="line number47 index46 alt2"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( ( m_bitsRead % 32 ) == 0 ||</code></div><div class="line number48 index47 alt1"><code class="cpp spaces">           </code><code class="cpp plain">( m_bitsRead % 32 ) == 8 ||</code></div><div class="line number49 index48 alt2"><code class="cpp spaces">           </code><code class="cpp plain">( m_bitsRead % 32 ) == 16 ||</code></div><div class="line number50 index49 alt1"><code class="cpp spaces">           </code><code class="cpp plain">( m_bitsRead % 32 ) == 24 );</code></div><div class="line number51 index50 alt2"><code class="cpp spaces"> </code> </div><div class="line number52 index51 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">headBytes = ( 4 - ( m_bitsRead % 32 ) / 8 ) % 4;</code></div><div class="line number53 index52 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( headBytes &gt; bytes )</code></div><div class="line number54 index53 alt1"><code class="cpp spaces">   </code><code class="cpp plain">headBytes = bytes;</code></div><div class="line number55 index54 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; headBytes; ++i )</code></div><div class="line number56 index55 alt1"><code class="cpp spaces">   </code><code class="cpp plain">data[i] = ReadBits( 8 );</code></div><div class="line number57 index56 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( headBytes == bytes )</code></div><div class="line number58 index57 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code><code class="cpp plain">;</code></div><div class="line number59 index58 alt2"><code class="cpp spaces"> </code> </div><div class="line number60 index59 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( GetAlignBits() == 0 );</code></div><div class="line number61 index60 alt2"><code class="cpp spaces"> </code> </div><div class="line number62 index61 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numWords = ( bytes - headBytes ) / 4;</code></div><div class="line number63 index62 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( numWords &gt; 0 )</code></div><div class="line number64 index63 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number65 index64 alt2"><code class="cpp spaces">       </code><code class="cpp functions bold">assert</code><code class="cpp plain">( ( m_bitsRead % 32 ) == 0 );</code></div><div class="line number66 index65 alt1"><code class="cpp spaces">       </code><code class="cpp functions bold">memcpy</code><code class="cpp plain">( data + headBytes, &amp;m_data[m_wordIndex], numWords <em> 4 );</em></code></div><div class="line number67 index66 alt2"><code class="cpp spaces">       </code><code class="cpp plain">m_bitsRead += numWords  32;</code></div><div class="line number68 index67 alt1"><code class="cpp spaces">       </code><code class="cpp plain">m_wordIndex += numWords;</code></div><div class="line number69 index68 alt2"><code class="cpp spaces">       </code><code class="cpp plain">m_scratchBits = 0;</code></div><div class="line number70 index69 alt1"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number71 index70 alt2"><code class="cpp spaces"> </code> </div><div class="line number72 index71 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( GetAlignBits() == 0 );</code></div><div class="line number73 index72 alt2"><code class="cpp spaces"> </code> </div><div class="line number74 index73 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">tailStart = headBytes + numWords <em> 4;</em></code></div><div class="line number75 index74 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">tailBytes = bytes - tailStart;</code></div><div class="line number76 index75 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( tailBytes &gt;= 0 &amp;&amp; tailBytes &lt; 4 );</code></div><div class="line number77 index76 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; tailBytes; ++i )</code></div><div class="line number78 index77 alt1"><code class="cpp spaces">       </code><code class="cpp plain">data[tailStart+i] = ReadBits( 8 );</code></div><div class="line number79 index78 alt2"><code class="cpp spaces"> </code> </div><div class="line number80 index79 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( GetAlignBits() == 0 );</code></div><div class="line number81 index80 alt2"><code class="cpp spaces"> </code> </div><div class="line number82 index81 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">assert</code><code class="cpp plain">( headBytes + numWords  4 + tailBytes == bytes );</code></div><div class="line number83 index82 alt2"><code class="cpp plain">}</code></div><div class="line number84 index83 alt1"><code class="cpp spaces"> </code> </div><div class="line number85 index84 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number86 index85 alt1"><code class="cpp plain">bool serialize_bytes_internal( Stream &amp; stream,</code></div><div class="line number87 index86 alt2"><code class="cpp spaces">                              </code><code class="cpp plain">uint8_t<em> data,</em></code></div><div class="line number88 index87 alt1"><code class="cpp spaces">                              </code><code class="cpp color1 bold">int</code> <code class="cpp plain">bytes )</code></div><div class="line number89 index88 alt2"><code class="cpp plain">{</code></div><div class="line number90 index89 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp plain">stream.SerializeBytes( data, bytes );</code></div><div class="line number91 index90 alt2"><code class="cpp plain">}</code></div><div class="line number92 index91 alt1"><code class="cpp spaces"> </code> </div><div class="line number93 index92 alt2"><code class="cpp preprocessor">#define serialize_bytes( stream, data, bytes)                   \</code></div><div class="line number94 index93 alt1"><code class="cpp spaces"> </code><code class="cpp keyword bold">do</code>                                                             <code class="cpp plain">\</code></div><div class="line number95 index94 alt2"><code class="cpp spaces"> </code><code class="cpp plain">{                                                              \</code></div><div class="line number96 index95 alt1"><code class="cpp spaces">     </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !serialize_bytes_internal( stream, data, bytes ) )    \</code></div><div class="line number97 index96 alt2"><code class="cpp spaces">         </code><code class="cpp plain">return false;                                          \</code></div><div class="line number98 index97 alt1"><code class="cpp spaces">  </code><code class="cpp plain">} </code><code class="cpp keyword bold">while</code><code class="cpp plain">(0)</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 10pt;"> </span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在，我们可以通过先序列化字符串长度然后序列化字符串数据的方法来序列化一个字符串：</span></p><div><div id="highlighter_278980" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number2 index1 alt1"><code class="cpp color1 bold">bool</code> <code class="cpp plain">serialize_string_internal(Stream &amp; stream,</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">                               </code><code class="cpp color1 bold">char</code><code class="cpp plain"> string,</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">                               </code><code class="cpp color1 bold">int</code> <code class="cpp plain">buffer_size )</code></div><div class="line number5 index4 alt2"><code class="cpp plain">{</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">   </code><code class="cpp plain">uint32_t length;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">       </code><code class="cpp plain">length = </code><code class="cpp functions bold">strlen</code><code class="cpp plain">( string );</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">       </code><code class="cpp functions bold">assert</code><code class="cpp plain">( length &lt; buffer_size - 1 );</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">   </code><code class="cpp plain">serialize_int( stream, length, 0, buffer_size - 1 );</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_bytes( stream, (uint8_t*)string, length );</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">       </code><code class="cpp plain">string[length] = </code><code class="cpp string">‘\0’</code><code class="cpp plain">;</code></div><div class="line number16 index15 alt1"><code class="cpp plain">}</code></div><div class="line number17 index16 alt2"><code class="cpp spaces"> </code> </div><div class="line number18 index17 alt1"><code class="cpp preprocessor">#define serialize_string( stream, string, buffer_size)             \</code></div><div class="line number19 index18 alt2"><code class="cpp keyword bold">do</code>                                                                  <code class="cpp plain">\</code></div><div class="line number20 index19 alt1"><code class="cpp plain">{                                                                   \</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !serialize_string_internal(stream,                        \</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">                                    </code><code class="cpp plain">string,buffer_size ) )         \</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">       </code><code class="cpp plain">return false;                                               \</code></div><div class="line number24 index23 alt1"><code class="cpp plain">} </code><code class="cpp keyword bold">while</code> <code class="cpp plain">(0)</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left" style="margin: 0cm 18.05pt 0.0001pt; line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt 18pt 0cm;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">正如你看到的那样，可以从基本元素的序列化开始构建一个相当复杂的序列化体系。</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt 18pt 0cm;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><h2 id="序列化数组的子集"><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">序列化数组的子集</span></h2><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt 18pt 0cm;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">当实现一个游戏网络协议的时候，或早或晚总会需要序列化一个对象数组然后在网络上传递。比如说服务器也许需要把所有的物体发送给客户端，或者有时候需要发送一组事件或者消息。如果你要发送所有的物体到客户端，这是相当简单直观的，但是如果你只是想发送一个数组的一个子集怎么办？</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">最先想到也是最容易的办法是遍历数组的所有物体然后序列化一个<span>bool</span>数组，这个<span>bool</span>数组标记的是对应的物体是否通过网络发送。如果<span>bool</span>值为<span>1</span>那么后面会跟着物体的数据，否则就会被忽略然后下一个物体的<span>bool</span>值取决于流的下一个值。</span></p><div><div id="highlighter_16412" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">bool serialize_scene_a( Stream &amp; stream, Scene &amp; scene )</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; MaxObjects; ++i )</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_bool( stream, scene.objects[i].send );</code></div><div class="line number7 index6 alt2"><code class="cpp spaces"> </code> </div><div class="line number8 index7 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !scene.objects[i].send )</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">       </code><code class="cpp plain">{</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">           </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">               </code><code class="cpp functions bold">memset</code><code class="cpp plain">( &amp;scene.objects[i], 0, </code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">( Object ) );</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">           </code><code class="cpp keyword bold">continue</code><code class="cpp plain">;</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">       </code><code class="cpp plain">}</code></div><div class="line number14 index13 alt1"><code class="cpp spaces"> </code> </div><div class="line number15 index14 alt2"><code class="cpp spaces">       </code><code class="cpp plain">serialize_object( stream, scene.objects[i] );</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number17 index16 alt2"><code class="cpp spaces"> </code> </div><div class="line number18 index17 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number19 index18 alt2"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但是如果物体的数组很大怎么办？举个例子，比如场景中有<span>4000</span>个物体。<span>4000 / 8 = 500</span>。光是标记物体是否发送的<span>BOOL</span>数组就要<span>500</span>个字节的开销，即使你只发送了一两个物体也是这样！这种方法。。。。不是太好。所以我们是否能够找到一种办法来让额外的开销正比于发送的物体数目而不是正比于数组中的物体数目？</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们可以找到这么一个方法，但是现在我们已经做了一些有意思的事情。我们在序列化写入的时候遍历一个物体的集合（数组里面的所有物体）但是序列化读取的时候遍历的是一个不同的物体集合（发送物体数组的子集）。在这一点上统一的序列化函数概念就不能维系了。对于这种情况最好是把读取和写入分解成单独的函数：</span></p><div><div id="highlighter_730107" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div><div class="line number35 index34 alt2">35</div><div class="line number36 index35 alt1">36</div><div class="line number37 index36 alt2">37</div><div class="line number38 index37 alt1">38</div><div class="line number39 index38 alt2">39</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">bool write_scene_b( protocol2::WriteStream &amp; stream, Scene &amp; scene )</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">num_objects_sent = 0;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces"> </code> </div><div class="line number5 index4 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; MaxObjects; ++i )</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( scene.objects[i].send )</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">           </code><code class="cpp plain">num_objects_sent++;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number10 index9 alt1"><code class="cpp spaces"> </code> </div><div class="line number11 index10 alt2"><code class="cpp spaces">   </code><code class="cpp plain">write_int( stream, num_objects_sent, 0, MaxObjects );</code></div><div class="line number12 index11 alt1"><code class="cpp spaces"> </code> </div><div class="line number13 index12 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; MaxObjects; ++i )</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !scene.objects[i].send )</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">           </code><code class="cpp keyword bold">continue</code><code class="cpp plain">;</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">       </code><code class="cpp plain">write_int( stream, i, 0, MaxObjects - 1 );</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">       </code><code class="cpp plain">write_object( stream, scene.objects[i] );</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number20 index19 alt1"><code class="cpp spaces"> </code> </div><div class="line number21 index20 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number22 index21 alt1"><code class="cpp plain">}</code></div><div class="line number23 index22 alt2"><code class="cpp spaces"> </code> </div><div class="line number24 index23 alt1"><code class="cpp plain">bool read_scene_b( protocol2::ReadStream &amp; stream, Scene &amp; scene )</code></div><div class="line number25 index24 alt2"><code class="cpp plain">{</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">memset</code><code class="cpp plain">( &amp;scene, 0, </code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">( scene ) );</code></div><div class="line number27 index26 alt2"><code class="cpp spaces"> </code> </div><div class="line number28 index27 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">num_objects_sent;</code></div><div class="line number29 index28 alt2"><code class="cpp spaces">   </code><code class="cpp plain">read_int( stream, num_objects_sent, 0, MaxObjects );</code></div><div class="line number30 index29 alt1"><code class="cpp spaces"> </code> </div><div class="line number31 index30 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; num_objects_sent; ++i )</code></div><div class="line number32 index31 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number33 index32 alt2"><code class="cpp spaces">       </code><code class="cpp color1 bold">int</code> <code class="cpp plain">index;</code></div><div class="line number34 index33 alt1"><code class="cpp spaces">       </code><code class="cpp plain">read_int( stream, index, 0, MaxObjects - 1 );</code></div><div class="line number35 index34 alt2"><code class="cpp spaces">       </code><code class="cpp plain">read_object( stream, scene.objects[index] );</code></div><div class="line number36 index35 alt1"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number37 index36 alt2"><code class="cpp spaces"> </code> </div><div class="line number38 index37 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number39 index38 alt2"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">此外，你可以用发生变化的对象集合来生成一个单独的数据结构，并且针对发生变化的对象集合实现序列化。但是对每个你期望能够序列化的数据结构都产生<span>C++</span>代码对应的数据结构体是一件非常痛苦的事情。最终你可能想要同时遍历几个数据结构然后高效的将一个动态数据结构写入比特流。这在写一些更高级的序列化方法比如增量编码的时候是一种非常平常的做法。只要你采用了这种做法，统一序列化这种做法就不再有什么意义。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我对此的建议是如果任何时候你想这么做，那么请不要担心，就把序列化读取和序列化写入分开好了。将序列化读取和序列化写入统一起来是一种非常简单的方式，但是这种方式带来的简单易用与序列化写入时动态生成数据结构的痛苦相比是不划算的。我的经验是复杂的序列化功能有时候可能会需要单独的序列化读取和序列化写入功能，但是如果可能的话，尽量让具体的序列化函数是统一读取和写入的（举个例子来说，实际的物体和事件无论何时序列化都尽量保持序列化读取和序列化写入是统一的）。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">多说一点。上面的代码在一次序列化写入的时候对物体集合进行了两次遍历。一次遍历用来确定发生变化的物体数目，第二次遍历用来对发生变化的物体集合进行实际的序列化。我们是否能只用一次遍历就能处理好发生变化的物体集合的序列化？当然可以！你可以使用另外一个技巧，用一个哨兵值（<span>sentinel value</span>）来标记数组的结尾位置，而不是一直序列化数组中的物体直到遇到<span>#</span>。使用这种方法你可以在发送的时候只遍历整个数组一遍，当没有更多物体需要发送的时候，就把哨兵值序列化进数据包以表示数组结束了：</span></p><div><div id="highlighter_951032" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">bool write_scene_c( protocol2::WriteStream &amp; stream, Scene &amp; scene )</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; MaxObjects; ++i )</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !scene.objects[i].send )</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">           </code><code class="cpp keyword bold">continue</code><code class="cpp plain">;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">       </code><code class="cpp plain">write_int( stream, i, 0, MaxObjects );</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">       </code><code class="cpp plain">write_object( stream, scene.objects[i] );</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number10 index9 alt1"><code class="cpp spaces"> </code> </div><div class="line number11 index10 alt2"><code class="cpp spaces">   </code><code class="cpp plain">write_int( stream, MaxObjects, 0, MaxObjects );</code></div><div class="line number12 index11 alt1"><code class="cpp spaces"> </code> </div><div class="line number13 index12 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number14 index13 alt1"><code class="cpp plain">}</code></div><div class="line number15 index14 alt2"><code class="cpp spaces"> </code> </div><div class="line number16 index15 alt1"><code class="cpp plain">bool read_scene_c( protocol2::ReadStream &amp; stream, Scene &amp; scene )</code></div><div class="line number17 index16 alt2"><code class="cpp plain">{</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">   </code><code class="cpp functions bold">memset</code><code class="cpp plain">( &amp;scene, 0, </code><code class="cpp keyword bold">sizeof</code><code class="cpp plain">( scene ) );</code></div><div class="line number19 index18 alt2"><code class="cpp spaces"> </code> </div><div class="line number20 index19 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">while</code> <code class="cpp plain">( </code><code class="cpp keyword bold">true</code> <code class="cpp plain">)</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">       </code><code class="cpp color1 bold">int</code> <code class="cpp plain">index; read_int( stream, index, 0, MaxObjects );</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( index == MaxObjects )</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">           </code><code class="cpp keyword bold">break</code><code class="cpp plain">;</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">       </code><code class="cpp plain">read_object( stream, scene.objects[index] );</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number27 index26 alt2"><code class="cpp spaces"> </code> </div><div class="line number28 index27 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number29 index28 alt2"><code class="cpp plain">}</code><span style="color: rgb(34, 34, 34); font-family: &quot;Courier New&quot;; font-size: 12pt;"> </span></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt 18pt 0cm;"><span style="font-size:10.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这种做法非常的简单，并且在发送的物体集合相比较全部物体集合比例非常小的时候工作的很棒。但是如果有大量的物体需要发送，举个例子来说，整个场景中有<span>4000</span>个物体，有一半的物体也就是<span>2000</span>个需要通过网络进行发送。每个物体需要一个序号，那么就需要<span>2000</span>个序号，每个序号需要<span>12</span>比特。。。。这就是说数据包里面<span>24000</span>比特或者说接近<span>30000</span>比特（几乎是<span>30000</span>，不是严格是，译注：原文如此）的数据被序号浪费掉了。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">可以把序号的编码方式修改下来节省数据，序号不再是全局序号，而是相对上一个物体的相对序号。想下这个问题，我们从左到右遍历一个数组，所以数组中物体的序号从<span>0</span>开始并且逐步增大到<span>MaxObjects – 1</span>。从统计学的角度来说，要发送的物体有可能是挨着很近的，这样下一个序号可能就是<span>+1</span>或者<span>+10</span>再或者是<span>+30</span>这样的小数字，因为我们这里用的序号是相对上一个发送的物体的，所以数字从统计意义上来说都会比较小，所以平均来讲，相比较之前的解决方案你可能需要更少的比特来表示物体的序号。（其实最差情况下我们所需的比特位也只是和前一个方案相同而已，可以证明每个序号，后一方案都比前一方案的要小，那么每个序号花费的比特位无疑不会更多，但是这种方案的主要问题在于健壮性，需要确保关于数据集合的数据包中间都不能丢，一旦中间某个包被丢掉了，那么后面的解析就完全乱掉了，实现起来更加困难一些<span>)</span>。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">下面就是这么一种编码物体序号的方式，每个序号都是相对上一个物体序号而言的，不再是全局序号，从统计的角度来讲它们会消耗更少的比特位（但是如果非常大的集合，但是发送的数组所占的比例很小，那么两种方法的差异其实是比较小的）：</span></p><div><div id="highlighter_750294" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div><div class="line number35 index34 alt2">35</div><div class="line number36 index35 alt1">36</div><div class="line number37 index36 alt2">37</div><div class="line number38 index37 alt1">38</div><div class="line number39 index38 alt2">39</div><div class="line number40 index39 alt1">40</div><div class="line number41 index40 alt2">41</div><div class="line number42 index41 alt1">42</div><div class="line number43 index42 alt2">43</div><div class="line number44 index43 alt1">44</div><div class="line number45 index44 alt2">45</div><div class="line number46 index45 alt1">46</div><div class="line number47 index46 alt2">47</div><div class="line number48 index47 alt1">48</div><div class="line number49 index48 alt2">49</div><div class="line number50 index49 alt1">50</div><div class="line number51 index50 alt2">51</div><div class="line number52 index51 alt1">52</div><div class="line number53 index52 alt2">53</div><div class="line number54 index53 alt1">54</div><div class="line number55 index54 alt2">55</div><div class="line number56 index55 alt1">56</div><div class="line number57 index56 alt2">57</div><div class="line number58 index57 alt1">58</div><div class="line number59 index58 alt2">59</div><div class="line number60 index59 alt1">60</div><div class="line number61 index60 alt2">61</div><div class="line number62 index61 alt1">62</div><div class="line number63 index62 alt2">63</div><div class="line number64 index63 alt1">64</div><div class="line number65 index64 alt2">65</div><div class="line number66 index65 alt1">66</div><div class="line number67 index66 alt2">67</div><div class="line number68 index67 alt1">68</div><div class="line number69 index68 alt2">69</div><div class="line number70 index69 alt1">70</div><div class="line number71 index70 alt2">71</div><div class="line number72 index71 alt1">72</div><div class="line number73 index72 alt2">73</div><div class="line number74 index73 alt1">74</div><div class="line number75 index74 alt2">75</div><div class="line number76 index75 alt1">76</div><div class="line number77 index76 alt2">77</div><div class="line number78 index77 alt1">78</div><div class="line number79 index78 alt2">79</div><div class="line number80 index79 alt1">80</div><div class="line number81 index80 alt2">81</div><div class="line number82 index81 alt1">82</div><div class="line number83 index82 alt2">83</div><div class="line number84 index83 alt1">84</div><div class="line number85 index84 alt2">85</div><div class="line number86 index85 alt1">86</div><div class="line number87 index86 alt2">87</div><div class="line number88 index87 alt1">88</div><div class="line number89 index88 alt2">89</div><div class="line number90 index89 alt1">90</div><div class="line number91 index90 alt2">91</div><div class="line number92 index91 alt1">92</div><div class="line number93 index92 alt2">93</div><div class="line number94 index93 alt1">94</div><div class="line number95 index94 alt2">95</div><div class="line number96 index95 alt1">96</div><div class="line number97 index96 alt2">97</div><div class="line number98 index97 alt1">98</div><div class="line number99 index98 alt2">99</div><div class="line number100 index99 alt1">100</div><div class="line number101 index100 alt2">101</div><div class="line number102 index101 alt1">102</div><div class="line number103 index102 alt2">103</div><div class="line number104 index103 alt1">104</div><div class="line number105 index104 alt2">105</div><div class="line number106 index105 alt1">106</div><div class="line number107 index106 alt2">107</div><div class="line number108 index107 alt1">108</div><div class="line number109 index108 alt2">109</div><div class="line number110 index109 alt1">110</div><div class="line number111 index110 alt2">111</div><div class="line number112 index111 alt1">112</div><div class="line number113 index112 alt2">113</div><div class="line number114 index113 alt1">114</div><div class="line number115 index114 alt2">115</div><div class="line number116 index115 alt1">116</div><div class="line number117 index116 alt2">117</div><div class="line number118 index117 alt1">118</div><div class="line number119 index118 alt2">119</div><div class="line number120 index119 alt1">120</div><div class="line number121 index120 alt2">121</div><div class="line number122 index121 alt1">122</div><div class="line number123 index122 alt2">123</div><div class="line number124 index123 alt1">124</div><div class="line number125 index124 alt2">125</div><div class="line number126 index125 alt1">126</div><div class="line number127 index126 alt2">127</div><div class="line number128 index127 alt1">128</div><div class="line number129 index128 alt2">129</div><div class="line number130 index129 alt1">130</div><div class="line number131 index130 alt2">131</div><div class="line number132 index131 alt1">132</div><div class="line number133 index132 alt2">133</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">bool serialize_object_index_internal( Stream &amp; stream,</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">                                     </code><code class="cpp color1 bold">int</code> <code class="cpp plain">&amp; previous,</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">                                     </code><code class="cpp color1 bold">int</code> <code class="cpp plain">&amp; current )</code></div><div class="line number5 index4 alt2"><code class="cpp plain">{</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">   </code><code class="cpp plain">uint32_t difference;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">       </code><code class="cpp functions bold">assert</code><code class="cpp plain">( previous &lt; current );</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">       </code><code class="cpp plain">difference = current - previous;</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">       </code><code class="cpp functions bold">assert</code><code class="cpp plain">( difference &gt; 0 );</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number13 index12 alt2"><code class="cpp spaces"> </code> </div><div class="line number14 index13 alt1"><code class="cpp spaces">   </code><code class="cpp comments">// +1 (1 bit)</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">   </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">plusOne;</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">      </code><code class="cpp plain">plusOne = difference == 1;</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">   </code><code class="cpp plain">serialize_bool( stream, plusOne );</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( plusOne )</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">           </code><code class="cpp plain">current = previous + 1;</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">       </code><code class="cpp plain">previous = current;</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number26 index25 alt1"><code class="cpp spaces"> </code> </div><div class="line number27 index26 alt2"><code class="cpp spaces">   </code><code class="cpp comments">// [+2,5] -&gt; [0,3] (2 bits)</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">twoBits;</code></div><div class="line number29 index28 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number30 index29 alt1"><code class="cpp spaces">       </code><code class="cpp plain">twoBits = difference &lt;= 5;</code></div><div class="line number31 index30 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_bool( stream, twoBits );</code></div><div class="line number32 index31 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( twoBits )</code></div><div class="line number33 index32 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number34 index33 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, difference, 2, 5 );</code></div><div class="line number35 index34 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number36 index35 alt1"><code class="cpp spaces">           </code><code class="cpp plain">current = previous + difference;</code></div><div class="line number37 index36 alt2"><code class="cpp spaces">       </code><code class="cpp plain">previous = current;</code></div><div class="line number38 index37 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number39 index38 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number40 index39 alt1"><code class="cpp spaces"> </code> </div><div class="line number41 index40 alt2"><code class="cpp spaces">   </code><code class="cpp comments">// [6,13] -&gt; [0,7] (3 bits)</code></div><div class="line number42 index41 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">threeBits;</code></div><div class="line number43 index42 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number44 index43 alt1"><code class="cpp spaces">       </code><code class="cpp plain">threeBits = difference &lt;= 13;</code></div><div class="line number45 index44 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_bool( stream, threeBits );</code></div><div class="line number46 index45 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( threeBits )</code></div><div class="line number47 index46 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number48 index47 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, difference, 6, 13 );</code></div><div class="line number49 index48 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number50 index49 alt1"><code class="cpp spaces">           </code><code class="cpp plain">current = previous + difference;</code></div><div class="line number51 index50 alt2"><code class="cpp spaces">       </code><code class="cpp plain">previous = current;</code></div><div class="line number52 index51 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number53 index52 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number54 index53 alt1"><code class="cpp spaces"> </code> </div><div class="line number55 index54 alt2"><code class="cpp spaces">   </code><code class="cpp comments">// [14,29] -&gt; [0,15] (4 bits)</code></div><div class="line number56 index55 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">fourBits;</code></div><div class="line number57 index56 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number58 index57 alt1"><code class="cpp spaces">       </code><code class="cpp plain">fourBits = difference &lt;= 29;</code></div><div class="line number59 index58 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_bool( stream, fourBits );</code></div><div class="line number60 index59 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( fourBits )</code></div><div class="line number61 index60 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number62 index61 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, difference, 14, 29 );</code></div><div class="line number63 index62 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number64 index63 alt1"><code class="cpp spaces">           </code><code class="cpp plain">current = previous + difference;</code></div><div class="line number65 index64 alt2"><code class="cpp spaces">       </code><code class="cpp plain">previous = current;</code></div><div class="line number66 index65 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number67 index66 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number68 index67 alt1"><code class="cpp spaces"> </code> </div><div class="line number69 index68 alt2"><code class="cpp spaces">    </code><code class="cpp comments">//[30,61] -&gt; [0,31] (5 bits)</code></div><div class="line number70 index69 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">fiveBits;</code></div><div class="line number71 index70 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number72 index71 alt1"><code class="cpp spaces">       </code><code class="cpp plain">fiveBits = difference &lt;= 61;</code></div><div class="line number73 index72 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_bool( stream, fiveBits );</code></div><div class="line number74 index73 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( fiveBits )</code></div><div class="line number75 index74 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number76 index75 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, difference, 30, 61 );</code></div><div class="line number77 index76 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number78 index77 alt1"><code class="cpp spaces">           </code><code class="cpp plain">current = previous + difference;</code></div><div class="line number79 index78 alt2"><code class="cpp spaces">       </code><code class="cpp plain">previous = current;</code></div><div class="line number80 index79 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number81 index80 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number82 index81 alt1"><code class="cpp spaces"> </code> </div><div class="line number83 index82 alt2"><code class="cpp spaces">   </code><code class="cpp comments">// [62,125] -&gt; [0,63] (6 bits)</code></div><div class="line number84 index83 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">sixBits;</code></div><div class="line number85 index84 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number86 index85 alt1"><code class="cpp spaces">       </code><code class="cpp plain">sixBits = difference &lt;= 125;</code></div><div class="line number87 index86 alt2"><code class="cpp spaces">   </code><code class="cpp plain">serialize_bool( stream, sixBits );</code></div><div class="line number88 index87 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( sixBits )</code></div><div class="line number89 index88 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number90 index89 alt1"><code class="cpp spaces">       </code><code class="cpp plain">serialize_int( stream, difference, 62, 125 );</code></div><div class="line number91 index90 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number92 index91 alt1"><code class="cpp spaces">           </code><code class="cpp plain">current = previous + difference;</code></div><div class="line number93 index92 alt2"><code class="cpp spaces">       </code><code class="cpp plain">previous = current;</code></div><div class="line number94 index93 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number95 index94 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number96 index95 alt1"><code class="cpp spaces"> </code> </div><div class="line number97 index96 alt2"><code class="cpp spaces">   </code><code class="cpp comments">// [126,MaxObjects+1]</code></div><div class="line number98 index97 alt1"><code class="cpp spaces">   </code><code class="cpp plain">serialize_int( stream, difference, 126, MaxObjects + 1 );</code></div><div class="line number99 index98 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number100 index99 alt1"><code class="cpp spaces">       </code><code class="cpp plain">current = previous + difference;</code></div><div class="line number101 index100 alt2"><code class="cpp spaces">   </code><code class="cpp plain">previous = current;</code></div><div class="line number102 index101 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number103 index102 alt2"><code class="cpp plain">}</code></div><div class="line number104 index103 alt1"><code class="cpp spaces"> </code> </div><div class="line number105 index104 alt2"><code class="cpp keyword bold">template &lt;typename Stream&gt;</code></div><div class="line number106 index105 alt1"><code class="cpp plain">bool serialize_scene_d( Stream &amp; stream, Scene &amp; scene )</code></div><div class="line number107 index106 alt2"><code class="cpp plain">{</code></div><div class="line number108 index107 alt1"><code class="cpp spaces">   </code><code class="cpp color1 bold">int</code> <code class="cpp plain">previous_index = -1;</code></div><div class="line number109 index108 alt2"><code class="cpp spaces">   </code> </div><div class="line number110 index109 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsWriting )</code></div><div class="line number111 index110 alt2"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number112 index111 alt1"><code class="cpp spaces">       </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; MaxObjects; ++i )</code></div><div class="line number113 index112 alt2"><code class="cpp spaces">       </code><code class="cpp plain">{</code></div><div class="line number114 index113 alt1"><code class="cpp spaces">           </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !scene.objects[i].send )</code></div><div class="line number115 index114 alt2"><code class="cpp spaces">               </code><code class="cpp keyword bold">continue</code><code class="cpp plain">;</code></div><div class="line number116 index115 alt1"><code class="cpp spaces">           </code><code class="cpp plain">write_object_index( stream, previous_index, i );</code></div><div class="line number117 index116 alt2"><code class="cpp spaces">           </code><code class="cpp plain">write_object( stream, scene.objects[i] );</code></div><div class="line number118 index117 alt1"><code class="cpp spaces">       </code><code class="cpp plain">}</code></div><div class="line number119 index118 alt2"><code class="cpp spaces">       </code><code class="cpp plain">write_object_index( stream, previous_index, MaxObjects );</code></div><div class="line number120 index119 alt1"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number121 index120 alt2"><code class="cpp spaces">   </code><code class="cpp keyword bold">else</code></div><div class="line number122 index121 alt1"><code class="cpp spaces">   </code><code class="cpp plain">{</code></div><div class="line number123 index122 alt2"><code class="cpp spaces">       </code><code class="cpp keyword bold">while</code> <code class="cpp plain">( </code><code class="cpp keyword bold">true</code> <code class="cpp plain">)</code></div><div class="line number124 index123 alt1"><code class="cpp spaces">       </code><code class="cpp plain">{</code></div><div class="line number125 index124 alt2"><code class="cpp spaces">           </code><code class="cpp color1 bold">int</code> <code class="cpp plain">index;</code></div><div class="line number126 index125 alt1"><code class="cpp spaces">           </code><code class="cpp plain">read_object_index( stream, previous_index, index );</code></div><div class="line number127 index126 alt2"><code class="cpp spaces">           </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( index == MaxObjects )</code></div><div class="line number128 index127 alt1"><code class="cpp spaces">               </code><code class="cpp keyword bold">break</code><code class="cpp plain">;</code></div><div class="line number129 index128 alt2"><code class="cpp spaces">           </code><code class="cpp plain">read_object( stream, scene.objects[index] );</code></div><div class="line number130 index129 alt1"><code class="cpp spaces">       </code><code class="cpp plain">}</code></div><div class="line number131 index130 alt2"><code class="cpp spaces">   </code><code class="cpp plain">}</code></div><div class="line number132 index131 alt1"><code class="cpp spaces">   </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number133 index132 alt2"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left"><br></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">通常情况下，这将节省大量的带宽，因为要发送的物体的序号往往倾向于聚在一起。在这种情况下，如果下一个物体也要被发送，那么它的的序号就是<span>+1</span>只需要一个比特大小。如果是<span>+2</span>到<span>+5</span>的情况每个序号需要<span>5</span>个比特。平均下来序号所占的数据大小方面可以降低<span>2-3</span>倍。但是要注意的是如果是间隔序号比较大的序号的消耗将比不相关序号编码方案（每个序号都是占<span>12</span>比特空间）要大。这看上去非常糟糕，但是实际上并不会这么差，试想一下，即使你遇到了“最差情况”（要发送的物体的序号间隔均匀都是相差<span>128</span>），那么在一个<span>4000</span>物体的大数组里面你实际才发送几个物体？只有<span>32</span>个而已，所以不用担心这个问题<span>!</span></span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><span><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><br></p><h2 id="协议ID和CRC32和序列化检测">协议ID和CRC32和序列化检测</h2><br><p></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">阅读到这里，你可能会有一个疑惑。“哦哦哦，整个体系看上去非常脆弱啊，只有一个完全不带任何属性信息的二进制流。流里面只有一个个数据协议。你该怎么对这些信息进行反序列化读取和写入？如果某些人发送一些包含随机信息的数据包给你的服务器。你会不会在解析的时候把服务器弄崩溃掉？”</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">确实大部分游戏服务器就是这样工作的，但是我有个好消息告诉你和其他之前是这么做服务器的人，存在这样的技术可以减少或者几乎杜绝由于序列化层传过来的数据导致的崩溃可能性。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">第一种技术是在你的数据包里面包含协议<span>ID</span>。一般典型的做法是，头<span>4</span>个字节你可以设定一些比较罕见而且独特的值，比如<span>0x12345678</span>，反正是这种其他人不会想着去使用的值就好了。但是说真的，把你的序列<span>ID</span>和协议版本的数字用散列得到一个散列值放到每个数据包的前面<span>32</span>比特的位置，这种方法真的工作的很好。至少如果是其他应用程序的数据包发送到了你的端口（要记住，<span>UDP</span>的数据包可以从任何<span>IP</span>任何端口在任何时间发送过来），你可以通过这３２比特的数据判断出来根本就不是你的应用程序的包，然后就可以直接丢弃了。</span></p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[protocol id] (32bits)</span><br><span class="line">(packet data)</span><br></pre></td></tr></table></figure><br><br><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&ququot;,&quot;sans-serif&quot;;color:#222222">下一个级别的防护是对你的数据包整体做一个<span>CRC32</span>的校验，并把这个校验码放到数据包的包头。这可以让你在接收的时候偶然会放过一些错误的数据包进来处理（这确实是会发生，<span>IP</span>的校验和是<span>16</span>位的，所以一堆东西不会使用<span>16</span>位的校验和。。。其实是通过协议<span>ID</span>来避免这种小概率事件的）。现在你的数据包头文件看起来像下面这样：</span></p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[protocol id](32bits)</span><br><span class="line"></span><br><span class="line">[crc32](32bits)</span><br><span class="line"></span><br><span class="line">(packet data)</span><br></pre></td></tr></table></figure><br><br><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果你按着这个顺序做下来的话，现在你可能会有点畏惧。<span>”</span>请等一下，我需要为每个数据包花费<span>8</span>个额外的字节来实现我自己的校验和以及协议<span>ID</span>么？<span>“</span>事实上，你可以不这么做。你可以学习下看看<span>IPv4</span>是如何进行校验的，并让协议<span>ID</span>变成一个魔术前缀(Magical Prefix)。也就是说你可以不发送这个协议<span>ID</span>，但是发送方和接收方提前确认过这个协议<span>ID</span>是什么，并在计算数据包<span>CRC32</span>值的时候装作这个数据包带上了这个协议<span>ID</span>的前缀来参与计算。这样如果发送方使用的协议<span>ID</span>与接收方不一致的时候，<span>CRC32</span>的校验就会失败，这将为每个数据包节省<span>4</span>个字节：</span></p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[protocol id] (32bits)  // not actually sent, but used to calc crc32</span><br><span class="line"></span><br><span class="line">[crc32](32bits)</span><br><span class="line"></span><br><span class="line">(packet data)</span><br></pre></td></tr></table></figure><br><br><p class="MsoNormal" align="left"><span style="font-size:10.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">当然，<span>CRC32</span>只是防止有些随机的数据包误打误撞的情况，但是对于可以轻易修改或者构建恶意数据包的头<span>4</span>个字节以便修正<span>CRC32</span>值的那些恶意发送者来说它起不到什么防护作用。要防止那些恶意发送者，你需要使用一个保密性更好的密码哈希函数，同时还需要一个密钥，这个密钥最好是在客户端尝试登陆游戏服务器之前就通过<span>HTTPS</span>协议在客户端和服务器之间统一好<span>(</span>而且要确保每个客户端的密钥都不一样，只有服务器和对应的客户端才知道密钥是什么<span>)</span>。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">最后一项技术，也可能是最有效的阻止恶意发送者的技术了（虽然会导致数据包的加密和签名有很多冗余信息），这就是序列化检查（<span>serialization check</span>）。这个技术基本上来说是在包的中间，在一段复杂的序列化写入之前或者之后写上一个已知的<span>32</span>比特整数，并在另外一端序列化读取的时候用相同的值进行检测判断。如果序列化检查值是不正确的，那么就中止序列化读取并丢弃这个数据包。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我喜欢在我的数据包每个部分之间写入一些序列化检查值，这样我至少知道我的数据包那部分已经被成功的序列化读取和写入（有些问题无论你如何努力避免都很难完全避免的）。我喜欢使用的另外一个很酷的技巧是在数据包的结尾序列化一个协议检查值，这非常非常的有用，因为它能够帮我判断是否遇到了数据包截断（非常像上一篇文章最后提到的臭名昭著的大端截断和小端截断，在开发的时候也是很让人头疼的地方）。</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">所以现在网络包看起来应该是像这样：</span></p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[protocol id] (32bits)  // not actually sent, but used to calc crc32</span><br><span class="line"></span><br><span class="line">[crc32](32bits)</span><br><span class="line"></span><br><span class="line">(packet data)</span><br><span class="line"></span><br><span class="line">[end of packet serialize check] (32 bits)</span><br></pre></td></tr></table></figure><br><br><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果你喜欢的话，你可以把这些协议编译出来然后在你的发布版本中检查这些数据包的内容，特别是在有非常棒的数据包加密和数据包签名支持的情况下，不过不编译也没关系，反正不再需要它们了。</span></p><b><span style="font-family:宋体"><br></span></b><b><span style="font-family:宋体">下一篇预告：数据包的分包和重组</span></b><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">请继续阅读这个系列的下一篇文章，在这篇文章里我将向大家介绍如何拓展本章中实现的网络协议来实现数据包的分包和重组以确保你的网络包的大小在<span>MTU</span>限制以下。</span></p><p class="MsoNormal" align="left"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">MTU</span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">：最大<i>传输</i>单元，<span>Maximum Transmission Unit</span>，是指一种通信协议的某一层上面所能通过的最大</span><span><a rel="nofollow" href="http://baike.baidu.com/view/25880.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>数据包</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">大，以</span><span><a rel="nofollow" href="http://baike.baidu.com/view/60408.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>字节</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">为单位。</span><span><a rel="nofollow" href="http://baike.baidu.com/view/545115.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>最大传输单元</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这个参数通常与</span><span><a rel="nofollow" href="http://baike.baidu.com/view/1296283.htm" target="_blank"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;text-decoration:none"><span>通信接口</span></span></a></span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">有关，比如网络接口卡、串口等。因为协议数据单元的包头和包尾的长度是固定的，<span>MTU</span>越大，则一个协议数据单元的承载的有效数据就越长，通信效率也越高。<span>MTU</span>越大，传送相同的用户数据所需的数据包个数也越低。<span>MTU</span>也不是越大越好，因为<span>MTU</span>越大， 传送一个数据包的延迟也越大；并且<span>MTU</span>越大，数据包中<span> bit</span>位发生错误的概率也越大。<span>MTU</span>越大，通信效率越高而传输延迟增大，所以要权衡通信效率和传输延迟选择合适的<span>MTU</span>。以以太网传送<span>IPv4</span>报文为例。<span>MTU</span>表示的长度包含<span>IP</span>包头的长度，如果<span>IP</span>层以上的协议层发送的数据报文的长度超过了<span>MTU</span>，则在发送者的<span>IP</span>层将对数据报文进行分片，在接收者的<span>IP</span>层对接收到的分片进行重组。</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#333333"> </span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果你觉得这篇文章有价值的话，请在<span>patreon</span>上支持我的写作，这样我会写的更快。你可以在<span>BSD 3.0</span>许可下访问到这篇文章里面的代码。非常感谢你的支持！</span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">【版权声明】</span></p><p class="MsoNormal"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权。</span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><span style="font-size:10.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"> </span></p></div>                    <br>                


<h1 id="原文旧版本">原文旧版本</h1>

<div class="WordSection1"><p class="MsoNormal" align="left" style="line-height: 21pt;"><br></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Hi, I’mGlenn Fiedler and welcome to the second article in <b><u>Building a GameNetwork Protocol</u></b>.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">In the </span><span><a rel="noopener" href="http://gafferongames.com/building-a-game-network-protocol/reading-and-writing-packets/" target="_blank"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;">previous article</span></a></span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222"> we discussed different ways to read and write packets in multiplayer games. Wequickly shot down sending game state via text formats like XML and JSON becausethey’re really inefficient and decided to write own binary protocolinstead. We implemented a bitpacker so we don’t have to round boolsup to 8 bits, solved endianness issues, wrote words at a time instead of bytesand pretty much made the bitpacker as simple and as fast as possible withoutplatform specific tricks.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Where weleft off we still had the following problems to solve:</span></p><p class="MsoNormal" align="left" style="margin-left: 36.05pt; text-indent: -18pt;"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">1.<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">    </span></span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Weneed a way to check if integer values are outside the expected rangeand abort packet read because people will send malicious packets tryingto make us trash memory. The packet read abort must be automatic and notuse exceptions because they’re really slow.</span></p><p class="MsoNormal" align="left" style="margin-left: 36.05pt; text-indent: -18pt;"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">2.<span style="font-stretch: normal; font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;">    </span></span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Separateread and write functions are a maintainance nightmare if those functions arecoded manually. We’d like to write the serialization code for a packet <u>once</u> but not pay any runtime cost (in terms of additional branching, virtuals and soon) when doing so.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">How can wedo this? Read on and I’ll show you how exactly I do it in C++. It’s taken awhile for me to develop and refine this technique so I hope you’ll find ituseful and at least a good alternative to consider vs. the way youcurrently do it or how you’ve seen it done in other game engines.</span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><b><span style="font-size:18.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Unified Packet Serialize Function</span></b></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Lets startwith the goal. Here’s where we want to end up:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">struct PacketA</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int x,y,z;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   template &lt;typename Stream&gt; <typename stream="stream"> bool Serialize( Stream &amp; stream )</typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_bits( stream, x, 32 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_bits( stream, y, 32 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_bits( stream, z, 32 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">};</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">struct PacketB</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int numElements;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int elements[MaxElements];</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   template &lt;typename Stream&gt; <typename stream="stream"> bool Serialize( Stream &amp; stream )</typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, numElements, 0, MaxElements );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       for ( int i = 0; i &lt; numElements; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           serialize_bits( buffer, elements[i], 32 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">};</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">struct PacketC</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   bool x;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   short y;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int z;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   template &lt;typename Stream&gt; <typename stream="stream"> bool Serialize( Stream &amp; stream )</typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, x, 8 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, y, 16 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, z, 32 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">};</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Noticethere is a single serialize function per-packet struct instead of separate readand write functions. This is great! It halves the amount of serialization codeand now you have put in some serious effort in order to desync read andwrite.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">The trickto making this work <u>efficiently</u><i> </i>is having thestream class templated in the serialize function. There are two stream types inmy system: ReadStream and WriteStream. Each class has the same set of methods,but otherwise are not related in any way. One class reads values in from a bitstream to variables, and the other writes variables values out to a bit stream.ReadStream and WriteStream are just wrappers on top of BitReader andBitWriter classes from the previous article.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">There areof course alternatives to this approach. If you dislike templates you couldhave a pure virtual base stream interface and implement that interfacewith read and write stream classes. But now you’re taking a virtualfunction for each serialize call. Seems like an excessive amount of overhead tome.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Anotheroption is to have an uber-stream class that can be configured to act in read orwrite mode at runtime. This can be faster than the virtual functionmethod, but you still have to branch per-serialize call to decide if you shouldread or write so it’s not going to be as fast as hand-coded read and write.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">I preferthe templated method because it lets the compiler do the work of generatingoptimized read/write functions for you. You can even code serializefunctions like this and let the compiler optimize out a bunch of stuff whenspecializing read and write:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">structRigidBody</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   vec3f position;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   quat3f orientation;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   vec3f linear_velocity;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   vec3f angular_velocity;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   template &lt;typename Stream&gt; <typename stream="stream"> bool Serialize( Stream &amp; stream )</typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_vector( stream, position );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_quaternion( stream, orientation );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       bool at_rest = Stream::IsWriting ? velocity.length() == 0 : 1;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_bool( stream, at_rest );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( !at_rest )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           serialize_vector( stream, linear_velocity );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           serialize_vector( stream, angular_velocity );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       else if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           linear_velocity = vec3f(0,0,0);</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           angular_velocity = vec3f(0,0,0);</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">};</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">While thismay <u>look</u> inefficient, it’s actually not! The templatespecialization of this function optimizes out all of the branchesaccording to the stream type. Pretty neat huh?</span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><b><span style="font-size:18.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Bounds Checking and Abort Read</span></b></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Now thatwe’ve twisted the compiler’s arm to generate optimized read/writefunctions, we need some way to automate error checking on readso we’re not vulnerable to malicious packets.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">The firststep is to pass in the range of the integer to the serialize functioninstead of just the number of bits required. Think about it. The serializefunction can work out the number of bits required from the min/max values:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">serialize_int(stream, numElements, 0, MaxElements );</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">This opensup the interface to support easy serialization of signed integer quantities andthe serialize function can check the value read in from the networkand make sure it’s within the expected range. If the value is outsiderange, <u>abort serialize read immediately and discard the packet</u>.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Since wecan’t use exceptions to handle this abort (too slow), here’s how I like to doit.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">In mysetup <b>serialize_int</b> is not actually a function, it’s a sneaky macro likethis:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">#defineserialize_int( stream, value, min, max)                   \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   do                                                             \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {                                                              \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       assert( min &lt; max);                                       \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       int32_tint32_value;                                       \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( Stream::IsWriting)                                   \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       {                                                          \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           assert( value &gt;= min);                                \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           assert( value &lt;= max);                                 \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           int32_value = (int32_t)value;                         \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       }                                                          \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( !stream.SerializeInteger( int32_value, min, max ) )    \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           return false;                                          \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( Stream::IsReading)                                   \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       {                                                          \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           value =int32_value;                                   \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           if ( value &lt; min || value &gt; max)                      \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">               return false;                                      \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       }                                                          \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">    } while (0)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">The reasonI’m being a terrible person here is that I’m using the macro to insert codethat checks the result of SerializeInteger and returns false onerror. This gives you exception-like behavior in the sense that itunwinds the stack back to the top of the serialization callstack on error, butyou don’t pay anything like the cost of exceptions to do this. The branch tounwind is super uncommon (serialization errors are <u>rare</u>) so branchprediction should have no trouble at all.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Anothercase where we need to abort is if the stream reads past the end. This is also arare branch but it’s one we do have to check on each serialization operationbecause reading past the end is undefined. If we fail to do this check, weexpose ourselves to infinite loops as we read past the end of the buffer.While it’s common to return 0 values when reading past the end of a bit stream(as per-the previous article) there is no guarantee that reading zerovalues will always result in the serialize function terminating correctlyif it has loops. This overflow check is necessary for well defined behavior.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">One finalpoint. On serialize write I don’t do any abort on range checksor write past the end of the stream. You can be a lot more relaxed on thewrite since if anything goes wrong it’s pretty much guaranteed to be <u>yourfault</u>. Just assert that everything is as expected (in range, not past theend of stream) for each serialize write and you’re good to go.</span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><b><span style="font-size:18.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Serializing Floats and Vectors</span></b></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">The bitstream only serializes integer values. How can we serialize a float value?</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Seemstrickly but it’s not actually. A floating point number stored inmemory is just a 32 bit value like any other. Your computer doesn’t knowif a 32 bit word in memory is an integer, a floating point value or partof a string. <u>It’s just a 32 bit value</u>. Luckily, the C++ language (unlikea few others) lets us work with this fundamental property.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">You canaccess the integer value behind a floating point number with a union:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">union FloatInt</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   float float_value;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   uint32_t int_value;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">};</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">FloatInt tmp;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">tmp.float_value= 10.0f;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">printf(“float value as an integer: %x\n”, tmp.int_value );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">You canalso do it via an aliased uint32_t<em> pointer, but I’ve experienced thisbreak with GCC -O2, so I prefer the union trick instead. Friends of minepoint out (likely correctly) that the only <i><u>truly standard way</u></i> to get the float as an integer is to cast a pointer to the float value touint8_t</em> and reconstruct the integer value from the four bytevalues accessed individually through the byte pointer. Seems a prettydumb way to do it to me though. Ladies and gentlemen… <b>C++!</b></span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Meanwhilein the past 5 years I’ve had no actual problems in the field with the uniontrick. Here’s how I serialize an uncompressed float value:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">boolserialize_float_internal( Stream &amp; stream, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                              float &amp; value )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   union FloatInt</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       float float_value;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       uint32_t int_value;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   };</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   FloatInt tmp;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       tmp.float_value = value;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   bool result = stream.SerializeBits( tmp.int_value, 32 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       value = tmp.float_value;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return result;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Wrap thiswith a <b>serialize_float</b> macro for convenient error checking on read:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">#define serialize_float( stream, value)                            \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> do                                                                \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> {                                                                 \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( !protocol2::serialize_float_internal( stream, value ))     \ </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return false;                                               \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">  } while(0)</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Sometimesyou don’t want to transmit a full precision float. How can you compress a floatvalue? The first step is to <u>bound</u> that value in some known rangethen <u>quantize</u> it down to an integer representation.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Forexample, if you know a floating point number in is range [-10,+10] and anacceptable resolution for that value is 0.01, then you can just multiply thatfloating point number by 100.0 to get it in the range [-1000,+1000] andserialize that as an integer over the network. On the other side, justdivide by 100.0 to get back to the floating point value.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Here is ageneralized version of this concept:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">boolserialize_compressed_float_internal( Stream &amp; stream, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                         float &amp; value, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                         float min, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                         float max, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                         float res )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   const float delta = max - min;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   const float values = delta / res;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   const uint32_t maxIntegerValue = (uint32_t) ceil( values );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   const int bits = bits_required( 0, maxIntegerValue );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   uint32_t integerValue = 0;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       float normalizedValue = </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           clamp( ( value - min ) / delta, 0.0f, 1.0f );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       integerValue = (uint32_t) floor( normalizedValue <em> </em></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                        maxIntegerValue + 0.5f );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( !stream.SerializeBits( integerValue, bits ) )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return false;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       const float normalizedValue = </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           integerValue / float( maxIntegerValue );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       value = normalizedValue  delta + min;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Once youcan serialize float values it’s trivial extend to serialize vectorsand quaternions over the network. I use a modified version of  the awesome </span><span><a rel="noopener" href="https://github.com/scoopr/vectorial" target="_blank"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;">vectorial library</span></a></span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222"> for vector math in my projects and I implement serialization for thosetypes like this:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">boolserialize_vector_internal( Stream &amp; stream, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                               vec3f &amp; vector )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   float values[3];</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       vector.store( values );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_float( stream, values[0] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_float( stream, values[1] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_float( stream, values[2] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       vector.load( values );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">boolserialize_quaternion_internal( Stream &amp; stream, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                   quat4f &amp; quaternion )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   float values[4];</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       quaternion.store( values );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_float( stream, values[0] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_float( stream, values[1] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_float( stream, values[2] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_float( stream, values[3] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       quaternion.load( values );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">#defineserialize_vector( stream, value)                      \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> do                                                            \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> {                                                             \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">    if ( !serialize_vector_internal( stream, value ))         \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">        return false;                                         \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> }                                                             \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> while(0)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">#defineserialize_quaternion( stream, value)                  \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> do                                                            \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> {                                                             \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">    if ( !serialize_quaternion_internal( stream, value ) )    \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">        return false;                                         \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> }                                                             \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> while(0)</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">If youknow your vector is bounded in some range, you can compress it like this:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">boolserialize_compressed_vector_internal( Stream &amp; stream, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                          vec3f &amp; vector,</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                          float min,</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                          float max,</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                          float res )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   float values[3];</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       vector.store( values );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_compressed_float( stream, values[0], min, max, res );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_compressed_float( stream, values[1], min, max, res );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_compressed_float( stream, values[2], min, max, res );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       vector.load( values );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">If youwant to compress an orientation over the network, don’t just compress it as avector with 8.8.8.8 bounded in the range [-1,+1]. You can do much better if youuse the smallest three representation of the quaternion. See the </span><span><a rel="noopener" href="http://www.patreon.com/gafferongames" target="_blank"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;">sample code</span></a></span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222"> for this article for an implementation.</span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><b><span style="font-size:18.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Serializing Strings and Arrays</span></b></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">What ifyou want to serialize a string over the network?</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Is it agood idea to send a string over the network with null termination? I don’tthink so. You’re just asking for trouble! Instead, treat the string as an arrayof bytes with length prefixed. So, in order to send a string over thenetwork, we have to work out how to efficiently send an array of bytes.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Firstobservation: why waste effort bitpacking an array of bytes into your bit streamjust so they are randomly shifted by shifted by [0,7] bits? Why not just <u>alignto byte</u> before writing the array, so the array data sits in the packetnicely aligned, each byte of the array corresponding to an actual byte in thepacket. You lose only [0,7] bits for each array of bytes serialized,depending on the alignment, but that’s nothing to be too concerned about in myopinion.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">How toalign the bit stream to byte? Just work out your current bit index in thestream and how many bits are left to write until the current bit number in thebit stream divides evenly into 8, then insert that number of paddingbits. For bonus points, pad up with zero bits to add entropy so that onread you can verify that yes, you are reading a byte align and yes, it isindeed padded up with zero bits to the next whole byte bit index. If a non-zerobit is discovered in the pad bits, <u>abort serialize read and discard thepacket</u>.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Here’s mycode to align a bit stream to byte:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">void BitWriter::WriteAlign()</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   const int remainderBits = m_bitsWritten % 8;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( remainderBits != 0 )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       uint32_t zero = 0;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       WriteBits( zero, 8 - remainderBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       assert( ( m_bitsWritten % 8 ) == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool BitReader::ReadAlign()</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   const int remainderBits = m_bitsRead % 8;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( remainderBits != 0 )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       uint32_t value = ReadBits( 8 - remainderBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       assert( m_bitsRead % 8 == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( value != 0 )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           return false;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">#define serialize_align( stream)           \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> do                                       \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> {                                        \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">     if ( !stream.SerializeAlign() )       \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">         return false;                    \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">  } while(0)</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Now we canuse this align operation to write an array of bytes into the bit streamefficiently: since we are aligned to bytes we can do most of the workusing memcpy. The only wrinkle is because the bit reader and bit writer work atthe word level, so it’s neccessary to have special code to handle the head andtail portion of the byte array, to make sure any previous scratch bits areflushed to memory at the head, and the scratch is properly setup for the nextbytes after the array in the tail section.</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">void BitWriter::WriteBytes( const uint8_t<em> data, int bytes )</em></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( GetAlignBits() == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( m_bitsWritten + bytes  8 &lt;= m_numBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( ( m_bitsWritten % 32 ) == 0 || </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           ( m_bitsWritten % 32 ) == 8||              </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           ( m_bitsWritten % 32 ) == 16 || </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           ( m_bitsWritten % 32 ) == 24 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int headBytes = ( 4 - ( m_bitsWritten % 32 ) / 8 ) % 4;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( headBytes &gt; bytes )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       headBytes = bytes;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; headBytes; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       WriteBits( data[i], 8 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( headBytes == bytes )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( GetAlignBits() == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int numWords = ( bytes - headBytes ) / 4;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( numWords &gt; 0 )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       assert( ( m_bitsWritten % 32 ) == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       memcpy( &amp;m_data[m_wordIndex], data+headBytes, numWords<em>4 );</em></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       m_bitsWritten += numWords  32;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       m_wordIndex += numWords;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       m_scratch = 0;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( GetAlignBits() == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int tailStart = headBytes + numWords <em> 4;</em></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int tailBytes = bytes - tailStart;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( tailBytes &gt;= 0 &amp;&amp; tailBytes &lt; 4 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; tailBytes; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       WriteBits( data[tailStart+i], 8 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( GetAlignBits() == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( headBytes + numWords  4 + tailBytes == bytes );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">void ReadBytes( uint8_t<em> data, int bytes )</em></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( GetAlignBits() == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( m_bitsRead + bytes  8 &lt;= m_numBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( ( m_bitsRead % 32 ) == 0 || </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           ( m_bitsRead % 32 ) == 8 || </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           ( m_bitsRead % 32 ) == 16 || </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           ( m_bitsRead % 32 ) == 24 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int headBytes = ( 4 - ( m_bitsRead % 32 ) / 8 ) % 4;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( headBytes &gt; bytes )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   headBytes = bytes;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; headBytes; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   data[i] = ReadBits( 8 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( headBytes == bytes )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( GetAlignBits() == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int numWords = ( bytes - headBytes ) / 4;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( numWords &gt; 0 )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       assert( ( m_bitsRead % 32 ) == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       memcpy( data + headBytes, &amp;m_data[m_wordIndex], numWords <em> 4 );</em></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       m_bitsRead += numWords  32;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       m_wordIndex += numWords;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       m_scratchBits = 0;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( GetAlignBits() == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int tailStart = headBytes + numWords <em> 4;</em></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int tailBytes = bytes - tailStart;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( tailBytes &gt;= 0 &amp;&amp; tailBytes &lt; 4 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; tailBytes; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       data[tailStart+i] = ReadBits( 8 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( GetAlignBits() == 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   assert( headBytes + numWords  4 + tailBytes == bytes );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool serialize_bytes_internal( Stream &amp; stream, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                              uint8_t<em> data, </em></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                              int bytes )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return stream.SerializeBytes( data, bytes );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">#define serialize_bytes( stream, data, bytes)                   \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> do                                                             \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> {                                                              \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">     if ( !serialize_bytes_internal( stream, data, bytes ) )    \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">         return false;                                          \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">  } while(0)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Now we canserialize a string by by serializing its length followed by the stringdata:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool serialize_string_internal(Stream &amp; stream, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                               char string, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                               int buffer_size )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   uint32_t length;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       length = strlen( string );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       assert( length &lt; buffer_size - 1 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_int( stream, length, 0, buffer_size - 1 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_bytes( stream, (uint8_t*)string, length );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       string[length] = ‘\0’;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">#define serialize_string( stream, string, buffer_size)             \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">do                                                                  \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{                                                                   \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( !serialize_string_internal(stream,                        \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                    string,buffer_size ) )         \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return false;                                               \</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">} while (0)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">As you cansee, you can build up quite complicated serialization from basicprimitives.</span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><b><span style="font-size:18.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Serializing Array Subsets</span></b></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Whenimplemeting a game network protocol, sooner or later you need to serialize anarray of objects over the network. Perhaps the server needs to send all objectsdown to the client, or an array of events or messages to be sent. This isfairly straightforward if you are sending <u>all</u> objects in the array downto the client, but what if you want to send only a subset of the array?</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">The firstand simplest approach is to iterate across all objects in the array andserialize a bool per-object if that object is to be sent. If the value of thatbool 1 then the object data follows, otherwise it’s ommitted and the bool forthe next object is up next in the stream.</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool serialize_scene_a( Stream &amp; stream, Scene &amp; scene )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; MaxObjects; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_bool( stream, scene.objects[i].send );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( !scene.objects[i].send )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">               memset( &amp;scene.objects[i], 0, sizeof( Object ) );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           continue;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_object( stream, scene.objects[i] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">But whatif the array of objects is very large, like 4000 objects in the scene? 4000 / 8= 500. Ruh roh. That’s an overhead of 500 bytes, even if you only send oneor two objects! That’s… not good. Can we switch it around so we take overheadpropertional to the number of objects sent instead of the total number ofobjects in the array?</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Wecan but now, we’ve done something interesting. We’re walking one set of objectsin the serialize write (all objects in the array) and are walking over adifferent set of objects in the serialize read (subset of objects sent). Atthis point the unified serialize function concept breaks down. It’s best toseparate the read and write back into separate functions in cases like this:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool write_scene_b( protocol2::WriteStream &amp; stream, Scene &amp; scene )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int num_objects_sent = 0;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; MaxObjects; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( scene.objects[i].send )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           num_objects_sent++;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   write_int( stream, num_objects_sent, 0, MaxObjects );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; MaxObjects; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( !scene.objects[i].send )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           continue;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       write_int( stream, i, 0, MaxObjects - 1 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       write_object( stream, scene.objects[i] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool read_scene_b( protocol2::ReadStream &amp; stream, Scene &amp; scene )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   memset( &amp;scene, 0, sizeof( scene ) );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int num_objects_sent; </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   read_int( stream, num_objects_sent, 0, MaxObjects );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; num_objects_sent; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       int index; </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       read_int( stream, index, 0, MaxObjects - 1 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       read_object( stream, scene.objects[index] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Alternativelyyou could generate a separate data structure with the set of changed objects,and implement a serialize for that array of changed objects. But having togenerate a C++ data structure for each data structure you want serialized is ahuge pain in the ass. Eventually you want to walk several datastructures at the same time and effectively write out a dynamic data structureto the bit stream. This is a really common thing to do when writing moreadvanced serialization methods like delta encoding. As soon as you do it thisway, unified serialize no longer makes sense.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">My adviceis that when you want to do this, don’t worry, just separate read and write.Unifying read and write are simply not worth the hassle when dynamicallygenerating a data structure on write. My rule of thumb is that complicatedserialization <i><u>probably</u></i> justifies separate read and writefunctions, but if possible, try to keep the leaf nodes unified if you can (eg.the actual objects / events, whatever being serialized).</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">One morepoint. The code above walks over the set of objects <u>twice</u> onserialize write. Once to determine the number of changed objects and a secondtime to actually serialize the set of changed objects. Can we do it in onepass instead? Absolutely! You can use another trick, a <u>sentinel value</u> toindicate the end of the array, rather than serializing the # of objects in thearray up front. This way you can iterate over the array only once onsend, and when there are no more objects to send, serialize the sentinalvalue to indicate the end of the array:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool write_scene_c( protocol2::WriteStream &amp; stream, Scene &amp; scene )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   for ( int i = 0; i &lt; MaxObjects; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( !scene.objects[i].send )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           continue;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       write_int( stream, i, 0, MaxObjects );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       write_object( stream, scene.objects[i] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   write_int( stream, MaxObjects, 0, MaxObjects );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool read_scene_c( protocol2::ReadStream &amp; stream, Scene &amp; scene )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   memset( &amp;scene, 0, sizeof( scene ) );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   while ( true )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       int index; read_int( stream, index, 0, MaxObjects );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( index == MaxObjects )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           break;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       read_object( stream, scene.objects[index] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">This ispretty simple and it works great if the set of objects sent is a smallpercentage of total objects. But what if a large number of objects are sent,lets say half of the 4000 objects in the scene. That’s 2000 object indices witheach index costing 12 bits… that’s 24000 bits or 3000 bytes (almost 3k!) inyour packet wasted indexing objects.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">You canreduce this by encoding each object index relative to the previous objectindex. Think about it, we’re walking left to right along an array, so objectindices start at 0 and go up to MaxObjects – 1. Statistically speaking, you’relikely to have objects that are close to each other and if the next index is +1or even +10 or +30 from the previous one, on average, you’ll need quite a fewless bits to represent that difference than youneed to represent an absolute index.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Here’s oneway to encode the object index as an integer relative to the previous objectindex, while spending less bits on statistically more likely values (eg. smalldifferences between successive object indices, vs. large ones):</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool serialize_object_index_internal( Stream &amp; stream, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                     int &amp; previous, </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">                                     int &amp; current )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   uint32_t difference;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       assert( previous &lt; current );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       difference = current - previous;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       assert( difference &gt; 0 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   // +1 (1 bit)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   bool plusOne;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">      plusOne = difference == 1;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_bool( stream, plusOne );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( plusOne )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           current = previous + 1;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       previous = current;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   // [+2,5] -&gt; [0,3] (2 bits)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   bool twoBits;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       twoBits = difference &lt;= 5;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_bool( stream, twoBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( twoBits )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, difference, 2, 5 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           current = previous + difference;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       previous = current;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   // [6,13] -&gt; [0,7] (3 bits)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   bool threeBits;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       threeBits = difference &lt;= 13;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_bool( stream, threeBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( threeBits )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, difference, 6, 13 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           current = previous + difference;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       previous = current;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   // [14,29] -&gt; [0,15] (4 bits)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   bool fourBits;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       fourBits = difference &lt;= 29;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_bool( stream, fourBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( fourBits )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, difference, 14, 29 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           current = previous + difference;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       previous = current;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">    //[30,61] -&gt; [0,31] (5 bits)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   bool fiveBits;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       fiveBits = difference &lt;= 61;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_bool( stream, fiveBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( fiveBits )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, difference, 30, 61 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           current = previous + difference;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       previous = current;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   // [62,125] -&gt; [0,63] (6 bits)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   bool sixBits;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       sixBits = difference &lt;= 125;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_bool( stream, sixBits );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( sixBits )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       serialize_int( stream, difference, 62, 125 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           current = previous + difference;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       previous = current;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   // [126,MaxObjects+1] </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   serialize_int( stream, difference, 126, MaxObjects + 1 );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsReading )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       current = previous + difference;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   previous = current;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">template &lt;typename Stream&gt;<typename stream="stream"> </typename></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">bool serialize_scene_d( Stream &amp; stream, Scene &amp; scene )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">{</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   int previous_index = -1;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">    </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   if ( Stream::IsWriting )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       for ( int i = 0; i &lt; MaxObjects; ++i )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           if ( !scene.objects[i].send )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">               continue;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           write_object_index( stream, previous_index, i );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           write_object( stream, scene.objects[i] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       write_object_index( stream, previous_index, MaxObjects );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   else</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       while ( true )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       {</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           int index; </span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           read_object_index( stream, previous_index, index );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           if ( index == MaxObjects )</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">               break;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">           read_object( stream, scene.objects[index] );</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">       }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   }</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">   return true;</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">}</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">In thecommon case this saves a bunch of bandwidth because object indices tend to beclustered together. In the case where the next object is sent, that’s just onebit for the next index being +1 and 5 bits per-index for +2 to +5. On averagethis gives somewhere between a 2-3X reduction in indexing overhead. But noticethat larger indices far apart cost a lot more for each index than thenon-relative encoding (12 bits per index). This <u>seems</u> bad but it’snot because think about it, even if you hit the ‘worst case’ (objectsindices spaced apart evenly with by +128 apart) how many of these can youactually fit into an object array 4000 large? Just 32. No worries!</span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><b><span style="font-size:18.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Protocol IDs, CRC32 and Serialization Checks</span></b></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">At thispoint you may wonder. <u>Wow</u>. This whole thing seems reallyfragile. It’s a totally unattributed binary stream. A stack of cards. Whatif you somehow desync read and write? What if somebody just sent packetscontaining random bytes to your server. How long until you hit a sequence ofbytes that crashes you out?</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">I havegood news for you and the rest of the game industry since most game serversbasically work this way. There are techniques you can use to reduce orvirtually eliminate the possibility of corrupt data getting past theserialization layer.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">The firsttechnique is to include a protocol id in your packet. Typically, the first 4bytes you can set to some reasonable rare and unique value, maybe 0x12345678because nobody else will ever think to use that. But seriously, put in a hashof your protocol id and your protocol version number in the first 32 bits ofeach packet and you’re doing pretty good. At least if a random packet gets sentto your port from some other application (remember UDP packets can come in fromany IP/port combination at any time) you can trivially discard it:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">[protocol id] (32bits)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">(packet data)</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">The nextlevel of protection is to pass a CRC32 over your packet and include that in theheader. This lets you pick up corrupt packets (these do happen, rememberthat the IP checksum is just 16 bits, and a bunch of stuff will not get pickedup by a checksum of 16bits…). Now your packet header looks ilke this:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"><a href="32bits">protocol id</a></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"><a href="32bits">crc32</a></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">(packet data)</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">At thispoint you may be wincing. Wait. I have to take 8 bytes of overhead per-packetjust to implement my own checksum and protocol id? Well actually, <u>you don’t</u>.You can take a leaf out of how IPv4 does their checksum, and make the protocolid a <i><u>magical prefix</u></i>. eg: you don’t actually send it, but if bothsender and receiver <u>knows</u> the protocol id and the CRC32 iscalculated <u>as if</u> the packet were prefixed by the protocol id, the CRC32will be incorrect if the sender does not have the same protocol id as thereceiver, saving 4 bytes per-packet:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">[<span class="msoDel">protocol id] (32bits)</span></span><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">  // not actually sent, but used to calc crc32</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"><a href="32bits">crc32</a></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">(packet data)</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Of courseCRC32 is only protection against random packet correction, and is no actualprotection against a malicious sender who can easily modify or construct amalicious packet and then properly adjust the CRC32 in the first four bytes. Toprotect against this you need to use a more cryptographically secure hashfunction combined with a secret key perhaps exchanged between client andserver over HTTPS by the matchmaker prior to the client attempting to connectto the game server (different key for each client, known only by the server andthat particular client).</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">One finaltechnique, perhaps as much a check against programmer error on your part andmalicious senders (although redundant once you encrypt and sign your packet) isthe <u>serialization check</u>. Basically, somewhere mid-packet, either beforeor after a complicated serialization section, just write out a known 32 bitinteger value, and check that it reads back in on the other side with the samevalue. If the serialize check value is incorrect <u>abort read and discardthe packet</u>.</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">I like todo this between sections of my packet as I write them, so at least I know whichpart of my packet serialization has desynced read and write as I’m developingmy protocol (it’s going to happen no matter how hard you try to avoid it…).Another cool trick I like to use is to serialize a protocol check at the veryend of the packet, this is super, super useful because it helps pick up packettruncations (like the infamous, little endian vs. big endian truncation of thelast word from the </span><span><a rel="noopener" href="http://gafferongames.com/building-a-game-network-protocol/reading-and-writing-packets/" target="_blank"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;">previous article</span></a></span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">).</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">So now thepacket looks something like this:</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">[<span class="msoDel">protocol id] (32bits)</span></span><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">  // not actually sent, but used to calc crc32</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222"><a href="32bits">crc32</a></span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">(packet data)</span></p><p class="MsoNormal" align="left" style="margin: 18pt 18.05pt;"><span style="font-size:12.0pt;font-family:&quot;Courier New&quot;;color:#222222">[end of packetserialize check] (32 bits)</span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">You canjust compile these protocol checks out in your retail build if you like,especially if you have a good encryption and packet signature, as they shouldno longer be necessary.</span></p><p class="MsoNormal" align="left" style="line-height: 22.5pt;"><b><span style="font-size:18.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Up next: </span></b><span><a rel="noopener" href="http://gafferongames.com/building-a-game-network-protocol/packet-fragmentation-and-reassembly/" target="_blank"><b><span style="font-size:18.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;text-decoration:none">Packet Fragmentation and Reassembly</span></b></a></span></p><p class="MsoNormal" align="left"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">Read onfor the next article in this series where I show you how to extend your networkprotocol to perform packet fragmentation and reassembly so you can keep yourpacket payload under MTU.</span></p><p class="MsoNormal" align="left"><span><a rel="noopener" href="http://www.patreon.com/gafferongames" target="_blank"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;">Pleasesupport my writing on patreon</span></a></span><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">, and I’llwrite new articles faster, plus you get access to example source code for thisarticle under BSD 3.0 licence. <b><u>Thanks for your support</u>!</b></span></p><p class="MsoNormal"><span> </span></p></div><br>                <br>                

      


      

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/GafferOnGames/" rel="tag"><i class="fa fa-tag"></i> GafferOnGames</a>
            
          </div>
        

        
        
        

        
          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2017/02/24/reading_and_writing_packets/" rel="next" title="构建游戏网络协议一之数据包的读取和写入">
                  <i class="fa fa-chevron-left"></i> 
                  <p class="post-nav-pre-next-title">
                    构建游戏网络协议一之数据包的读取和写入
                  </p> 
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2017/02/26/packet_fragmentation_and_reassembly/" rel="prev" title="构建游戏网络协议三之数据包的分包和重组">
                <p class="post-nav-pre-next-title">
                    构建游戏网络协议三之数据包的分包和重组
                </p> 
                <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        

        
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="no5ix">
          </a>
          <p class="site-author-name" itemprop="name">no5ix</p>
           
              <p class="site-description motion-element" itemprop="description">推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">215</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">关于</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
          
          <!-- 网易云音乐 -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- 网易云音乐 -->

        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://119.23.17.57" title="ksun的博客" target="_blank">ksun的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzU3MTUyNzg0NQ==&hid=1&sn=7a3ae61b7af714f75d68e7ae826a2d2c&scene=18#wechat_redirect" title="你有图么我有故事" target="_blank">你有图么我有故事</a>
                </li>
              
            </ul>
          </div>
        

        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#自我总结本篇概要"><span class="nav-number">1.</span> <span class="nav-text">自我总结本篇概要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原文"><span class="nav-number">2.</span> <span class="nav-text">原文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#introduction"><span class="nav-number">2.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serializing-bits"><span class="nav-number">2.2.</span> <span class="nav-text">Serializing Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implementation-in-c"><span class="nav-number">2.3.</span> <span class="nav-text">Implementation in C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serializing-floating-point-values"><span class="nav-number">2.4.</span> <span class="nav-text">Serializing Floating Point Values</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serializing-vectors-and-quaternions"><span class="nav-number">2.5.</span> <span class="nav-text">Serializing Vectors and Quaternions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serializing-strings-and-arrays"><span class="nav-number">2.6.</span> <span class="nav-text">Serializing Strings and Arrays</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serializing-array-subsets"><span class="nav-number">2.7.</span> <span class="nav-text">Serializing Array Subsets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protocol-ids-crc32-and-serialization-checks"><span class="nav-number">2.8.</span> <span class="nav-text">Protocol IDs, CRC32 and Serialization Checks</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#译文"><span class="nav-number">3.</span> <span class="nav-text">译文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#统一的数据包序列化功能"><span class="nav-number">3.1.</span> <span class="nav-text">统一的数据包序列化功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#边界检查和终止读取"><span class="nav-number">3.2.</span> <span class="nav-text">边界检查和终止读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化浮点数和向量"><span class="nav-number">3.3.</span> <span class="nav-text">序列化浮点数和向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化字符串和数组"><span class="nav-number">3.4.</span> <span class="nav-text">序列化字符串和数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化数组的子集"><span class="nav-number">3.5.</span> <span class="nav-text">序列化数组的子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议ID和CRC32和序列化检测"><span class="nav-number">3.6.</span> <span class="nav-text">协议ID和CRC32和序列化检测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原文旧版本"><span class="nav-number">4.</span> <span class="nav-text">原文旧版本</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">no5ix</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/dist/jquery.fancybox.js?v=3.2.10"></script>


  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">

    var is_load_xml_finished = 0;

    var searchFunc = function (path, search_id, content_id) {
      // 0x00. environment initialization
      'use strict';

      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      // var datas = [];

      /* loading css1 : Dot Css Loader*/
      var DotLoader = "<div class='loader'>Loading...</div>";

      /* loading css2 : Pure Css Loader - Square */
      var SquareLoader = 
        "<div class='loader'>" +
          "<div class='square' ></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square '></div>" +
          "<div class='square last'></div>" +
        "</div>";

      var ProgressBar = 
          "<div class='progress-bar'>" +
            "<div class='progress-bar-charge'></div>" +
          "</div>";

      var str = "";
      var keywords = [];
      var temp_keyword = "";

      // 是否为第一个字母被键入的标志位
      var first_char_flag = 0;

      // 因为在移动设备上, 点击搜索之后会 scroll 到页面顶部, 所以需要记录之前的页面x, y坐标值, 以便于搜索完点击 close 按钮之后 scroll 回原来的页面坐标值.
      var last_page_x = 0;
      var last_page_y = 0;

      var local_search_tips = 
            "<span class='local-search-empty'>" + "第一次搜索可能较慢, 先思考一个经典算法问题, 跳台阶:" + "</span>" +
            "<span class='local-search-empty'>" + "一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个6级的台阶总共有多少种跳法?n级呢?" + "</span>";

      function CloseLocalSearch()
      {
        first_char_flag = 0;

        $('#local-search-input').val('');
        $('#local-search-close').hide();

        // $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownOut', 200);

        $('#' + content_id).attr("headroom_special_attr","true"); 
        
        if (isMobile())
        {
          // $('body').scrollTop(last_page_y);  // scrollTop 有兼容性问题
          scrollTo(last_page_x, last_page_y);

          $('#' + content_id).hide();
        }
        else
        {
          $('#' + content_id).velocity('stop').velocity( 'transition.bounceUpOut', 200 );
        }

        // $('#' + content_id).velocity('stop').velocity( isMobile() ? 'transition.fadeOut' : 'transition.bounceUpOut', {
        //   // delay: isMobile() ? 50 : 0,
        //   duration: isMobile() ? 500 : 200,
        //   // begin: function() { 
        //   //   if (isMobile())
        //   //   {
        //   //     $('body').scrollTop(last_page_y);
        //   //   } 
        //   // }
        //   complete: function () {
        //     if (isMobile())
        //     {
        //       if (last_page_y < 20000)
        //       {
        //         $('body').velocity('scroll', { offset: last_page_y+"px", duration: last_page_y < 10000 ? 1000 : 2000 });
        //       }
        //       else
        //       {
        //         $('body').scrollTop(last_page_y);
        //       }
        //       // $('body').velocity('scroll');

        //       // $('html,body').animate({
        //       //   scrollTop: last_page_y
        //       // },400);
        //       // $('body').velocity('transition.slideDownIn', 1000);
        //       // $('body').velocity('scroll', { offset: last_page_y+"px", duration: document.body.scrollHeight < 20000 ? 1500 : 3000 });
        //     }
        //   }
        // });
      }

      function handleSearch()
      {
        if (keywords.length <= 0) {
          return;
        }
        $resultContent.innerHTML = "";
        $('#local-search-close').show();

        // 0x04. perform local searching
        if (is_load_xml_finished == 0)
        {
          $resultContent.innerHTML = 
            "<ul class='local-search-empty-ul'>" + 
            local_search_tips +
            ProgressBar;
        }
        else
        {
          // Retrieve the object from local storage
          var xml_resp = retrieve_search_xml()

          xml_resp.forEach(function (data) {
          // datas.forEach(function (data) {
            var isMatch = true;
            var content_index = [];
            if (!data.title || data.title.trim() === '') {
              data.title = "Untitled";
            }
            var is_encrypted = data.encrypted.trim() == '1'
            var is_sensitive = CONFIG.local_search.sensitive_word && data_content.indexOf(CONFIG.local_search.sensitive_word) >= 0
            var orig_data_title = data.title.trim();
            var data_title = orig_data_title.toLowerCase();
            var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
            var data_content = orig_data_content.toLowerCase();
            var data_url = decodeURIComponent(data.url);
            var index_title = -1;
            var index_content = -1;
            var first_occur = -1;
            // only match artiles with not empty contents
            if (data_content !== '') {
              keywords.forEach(function (keyword, i) {
                index_title = data_title.indexOf(keyword);
                index_content = (is_sensitive || is_encrypted) ? -1 : data_content.indexOf(keyword);

                if (index_title < 0 && index_content < 0) {
                  isMatch = false;
                } else {
                  if (index_content < 0) {
                    index_content = 0;
                  }
                  if (i == 0) {
                    first_occur = index_content;
                  }
                  // content_index.push({index_content:index_content, keyword_len:keyword_len});
                }
              });
            } else {
              isMatch = false;
            }
            // 0x05. show search results
            if (isMatch) {
              var content = orig_data_content;
              if (first_occur >= 0) {
                var match_content = "";
                if (!is_sensitive && !is_encrypted)
                {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  match_content = content.substr(start, end);
                }

                // highlight all keywords
                var regS = "";
                if (match_content != "")
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                else
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                str += "<li><a href='" + data_url + "' class='search-result-title' target='_blank'>" + orig_data_title + "</a>";
                str += "<p class=\"search-result\">" + match_content + "...</p>"
              }
              str += "</li>";
            }
          });

          str += "</ul>";
          if (str.indexOf('<li>') === -1) {
            return $resultContent.innerHTML = 
              "<ul class='local-search-empty-ul'><span class='local-search-empty'>找不到, 换个搜索关键字试一哈.<span></ul>";
          }
          $resultContent.innerHTML = str;
        }
      }

      $input.addEventListener('input', function () {
        // 0x03. parse query to keywords list
        str = '<ul class=\"search-result-list\">';
        temp_keyword = this.value.trim();
        if (temp_keyword.length <= 0) {
          CloseLocalSearch();
          return;
        }

        keywords = temp_keyword.toLowerCase().split(/[\s\-]+/);
        handleSearch();

        // 当用户键入第一个字母的时候的动画处理逻辑 : 
        // 当 first_char_flag 为 0 的时候, 
        // 要播放一个动画
        if (first_char_flag == 0)
        {
            // $('body').scrollTop(0);
          if (isMobile())
          {
            last_page_x = window.pageXOffset;
            last_page_y = window.pageYOffset;
            // $('body').scrollTop(0);
            scrollTo(0,0);

          }
          first_char_flag = 1;
          $('#' + content_id).removeAttr("headroom_special_attr");
          
          $('#' + content_id).velocity('stop').velocity('transition.slideDownIn', 300);

          $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 1000);
        }
      });


      var local_search_xml_data = localStorage.getItem('local_search_xml_data');
      if (!local_search_xml_data) {
        $.ajax({
          // 0x01. load xml file
          url: path,
          dataType: "xml",
          success: function (xmlResponse) {
            store_search_xml(xmlResponse);

            // setTimeout(function(){
            //   is_load_xml_finished = 1;

            //   handleSearch();
            //   $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
            // }, 2000);
            
            // is_load_xml_finished = 1;

            handleSearch();
            $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
          }
        });
      }

      $(document).on('click', '#local-search-close', function() {
        CloseLocalSearch();
      });

      $(document).keyup(function(event){
        switch(event.keyCode) {
          case 27:
            // alert("ESC");
            CloseLocalSearch();
        }
      });

      // $(document).on('blur', '#local-search-input', function(e) {
      //   // console.log(document.activeElement.getAttribute('class'));
        
      //   if (isMobile() == false)
      //   {
      //     CloseLocalSearch();
      //   }
      // });
    }

    function isMobile() {
      // console.log(document.body.clientWidth);
      return document.body.clientWidth < 768

      // var userAgent = window.navigator.userAgent;

      // var isiPad = userAgent.match(/iPad/i) !== null;
      // var mobileUA = [
      //   'iphone', 'android', 'phone', 'mobile',
      //   'wap', 'netfront', 'x11', 'java', 'opera mobi',
      //   'opera mini', 'ucweb', 'windows ce', 'symbian',
      //   'symbianos', 'series', 'webos', 'sony',
      //   'blackberry', 'dopod', 'nokia', 'samsung',
      //   'palmsource', 'xda', 'pieplus', 'meizu',
      //   'midp' ,'cldc' , 'motorola', 'foma',
      //   'docomo', 'up.browser', 'up.link', 'blazer',
      //   'helio', 'hosin', 'huawei', 'novarra',
      //   'coolpad', 'webos', 'techfaith', 'palmsource',
      //   'alcatel', 'amoi', 'ktouch', 'nexian',
      //   'ericsson', 'philips', 'sagem', 'wellcom',
      //   'bunjalloo', 'maui', 'smartphone', 'iemobile',
      //   'spice', 'bird', 'zte-', 'longcos',
      //   'pantech', 'gionee', 'portalmmm', 'jig browser',
      //   'hiptop', 'benq', 'haier', '^lct',
      //   '320x320', '240x320', '176x220'
      // ];
      // var pattern = new RegExp(mobileUA.join('|'), 'i');

      // return !isiPad && userAgent.match(pattern);
    }

    function store_search_xml(xmlResponse) {
        datas = $("entry", xmlResponse).map(function () {
          return {
            title: $("title", this).text(),
            content: $("content", this).text(),
            url: $("url", this).text(),
            encrypted: $("encrypted", this).text(),
          };
        }).get();
        // Put the object into storage
        localStorage.setItem('local_search_xml_data', JSON.stringify(datas));
        is_load_xml_finished = 1;

        console.log("store search.xml finished.");
    }

    function ajax_store_search_xml() {
      $.ajax({
        url: "/search.xml",
        dataType: "xml",
        success: function (xmlResponse) {
            store_search_xml(xmlResponse);
        }
      });
    }

    function retrieve_search_xml() {
        // Retrieve the object from local storage
        var retrievedObject = localStorage.getItem('local_search_xml_data');
        var xml_resp = JSON.parse(retrievedObject)
        return xml_resp
    }

    var getSearchFile = function(){
      var path = "/search.xml";
      var local_search_result_name = isMobile() ? "local-search-result-mobile" : "local-search-result-pc";
      searchFunc(path, 'local-search-input', local_search_result_name);
    }

    var local_search_xml_data = localStorage.getItem('local_search_xml_data');
    if (local_search_xml_data) {
      is_load_xml_finished = 1;
      console.log("load search.xml finished.");
    }
    var last_use_local_search_date = localStorage.getItem('last_use_local_search_date');
    var curDate = new Date();
    // 只有在 localStorage 没有 search.xml数据或者 距离上次使用local search已经超过一天了才去取search.xml
    // 节省流量
    if (last_use_local_search_date != curDate.getDate() || !local_search_xml_data) {
      // preload search.xml
      ajax_store_search_xml();
    }

    localStorage.setItem('last_use_local_search_date', curDate.getDate());
    

  </script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>


<!-- 页面点击小红心 -->





<script type="text/javascript" src="/js/src/headroom.js"></script> 

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
